<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Attestation Unlinkability Test · mDoc BLE</title>
    <meta name="robots" content="index, follow" />
    <meta
      name="description"
      content="Unlinkability test for EU PID,  Age Verification or mDL attestations comparing MSO deviceKey values."
    />
    <link rel="canonical" href="unlikability_test.html" />

    <!-- Open Graph / Twitter for rich previews -->
    <meta
      property="og:title"
      content="Attestation Unlinkability Test · mDoc BLE"
    />
    <meta
      property="og:description"
      content="Unlinkability test for EU PID,  Age Verification or mDL attestations comparing MSO deviceKey values."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://mdoc-web-verifier.stelau.com/unlikability_test.html"
    />
    <meta name="twitter:card" content="summary" />
    <meta
      name="twitter:title"
      content="Attestation Unlinkability Test · mDoc BLE"
    />
    <meta
      name="twitter:description"
      content="Unlinkability test for EU PID,  Age Verification or mDL attestations comparing MSO deviceKey values."
    />
    <meta name="theme-color" content="#0f172a" />

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300..700;1,9..40,300..700&family=JetBrains+Mono:wght@400;500&family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* ── Design tokens ─────────────────────────────── */
      :root {
        color-scheme: light;
        --font-display: "Outfit", "DM Sans", system-ui, sans-serif;
        --font-body: "DM Sans", system-ui, sans-serif;
        --font-mono: "JetBrains Mono", "SFMono-Regular", ui-monospace, monospace;

        --c-bg: #f0f2f5;
        --c-surface: #ffffff;
        --c-surface-alt: #f7f8fa;
        --c-border: rgba(15, 23, 42, 0.08);
        --c-border-strong: rgba(15, 23, 42, 0.14);

        --c-text: #1a1d23;
        --c-text-secondary: #5e6577;
        --c-text-tertiary: #8b92a5;

        --c-navy-900: #0b1120;
        --c-navy-800: #0f172a;
        --c-navy-700: #1a2640;

        --c-accent: #2563eb;
        --c-accent-hover: #1d4ed8;
        --c-accent-subtle: rgba(37, 99, 235, 0.08);

        --c-green: #059669;
        --c-green-subtle: rgba(5, 150, 105, 0.08);

        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-xl: 20px;
        --radius-pill: 999px;

        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04), 0 1px 3px rgba(0, 0, 0, 0.03);
        --shadow-card: 0 1px 3px rgba(0, 0, 0, 0.04), 0 8px 24px -8px rgba(15, 23, 42, 0.08);
        --shadow-lg: 0 8px 30px rgba(0, 0, 0, 0.07), 0 2px 8px rgba(0, 0, 0, 0.04);

        --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
        --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      /* ── Reset & base ──────────────────────────────── */
      *, *::before, *::after { box-sizing: border-box; }

      body {
        margin: 0;
        background: var(--c-bg);
        color: var(--c-text);
        font-family: var(--font-body);
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
      }

      /* ── Page header ───────────────────────────────── */
      .page-header {
        background: var(--c-navy-900);
        color: #f8fafc;
        padding: 2rem 1.5rem 2.25rem;
        text-align: center;
        position: relative;
        overflow: hidden;
      }
      .page-header::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          radial-gradient(ellipse 80% 60% at 50% 0%, rgba(37, 99, 235, 0.12), transparent),
          radial-gradient(ellipse 60% 50% at 80% 100%, rgba(139, 92, 246, 0.08), transparent);
        pointer-events: none;
      }
      .page-header h1 {
        position: relative;
        margin: 0;
        font-family: var(--font-display);
        font-size: clamp(1.5rem, 3vw, 2rem);
        font-weight: 600;
        letter-spacing: -0.02em;
      }
      .page-header p {
        position: relative;
      }
      .breadcrumb-nav {
        position: absolute;
        left: 1.25rem;
        top: 1.25rem;
        font-size: 0.8rem;
        z-index: 2;
      }
      .breadcrumb-nav a {
        color: rgba(248, 250, 252, 0.5);
        text-decoration: none;
        transition: color 0.2s ease;
      }
      .breadcrumb-nav a:hover {
        color: rgba(248, 250, 252, 0.85);
      }
      .breadcrumb-nav span {
        color: rgba(248, 250, 252, 0.35);
      }
      .breadcrumb-nav span:last-child {
        color: rgba(248, 250, 252, 0.7);
      }

      /* ── Main ──────────────────────────────────────── */
      main {
        max-width: 840px;
        margin: 0 auto;
        padding: 1rem 1.25rem 2rem;
      }

      /* ── Cards ─────────────────────────────────────── */
      .card {
        background: var(--c-surface);
        border-radius: var(--radius-xl);
        padding: 1.75rem;
        margin-top: 1rem;
        box-shadow: var(--shadow-card);
        border: 1px solid var(--c-border);
        transition: box-shadow 0.3s var(--ease-out);
        animation: fadeInUp 0.4s var(--ease-out) backwards;
      }
      .card:nth-child(1) { animation-delay: 0.05s; }
      .card:nth-child(2) { animation-delay: 0.1s; }
      .card:hover { box-shadow: var(--shadow-lg); }

      .card h2 {
        font-family: var(--font-display);
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--c-text);
      }

      /* ── Layout ────────────────────────────────────── */
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
      }

      /* ── Buttons ───────────────────────────────────── */
      button {
        font-family: var(--font-body);
        font-weight: 600;
        font-size: 0.875rem;
        padding: 0.6rem 1.15rem;
        border-radius: var(--radius-sm);
        border: none;
        background: var(--c-accent);
        color: #fff;
        cursor: pointer;
        letter-spacing: 0.01em;
        transition:
          transform 0.15s var(--ease-spring),
          box-shadow 0.2s ease,
          background 0.15s ease;
      }
      button.secondary {
        background: var(--c-navy-800);
      }
      button:disabled {
        background: var(--c-border-strong);
        color: var(--c-text-tertiary);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 14px -4px rgba(37, 99, 235, 0.45);
        background: var(--c-accent-hover);
      }
      button.secondary:hover:not(:disabled) {
        background: var(--c-navy-700);
        box-shadow: 0 4px 14px -4px rgba(15, 23, 42, 0.4);
      }
      button:active:not(:disabled) {
        transform: translateY(0);
      }

      /* ── Form controls ─────────────────────────────── */
      label.inline {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      input, textarea {
        font-family: var(--font-body);
      }
      textarea {
        width: 100%;
        min-height: 60px;
        padding: 0.75rem 0.9rem;
        border-radius: var(--radius-sm);
        border: 1px solid var(--c-border-strong);
        font-family: var(--font-mono);
        font-size: 0.82rem;
        background: var(--c-surface-alt);
        color: var(--c-text);
        resize: vertical;
        box-sizing: border-box;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      textarea:focus {
        outline: none;
        border-color: var(--c-accent);
        box-shadow: 0 0 0 3px var(--c-accent-subtle);
      }

      /* ── Typography helpers ────────────────────────── */
      .muted {
        color: var(--c-text-secondary);
        font-size: 0.9rem;
      }

      /* ── Status panel ──────────────────────────────── */
      .status {
        background: var(--c-surface-alt);
        border-radius: var(--radius-md);
        padding: 0.85rem 1.1rem;
        font-size: 0.9rem;
        border: 1px solid var(--c-border);
        overflow: hidden;
        word-break: break-all;
        overflow-wrap: anywhere;
      }
      #lastDeviceKey {
        font-family: var(--font-mono);
        font-size: 0.75rem;
        word-break: break-all;
        overflow-wrap: anywhere;
      }

      /* ── Table ─────────────────────────────────────── */
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }
      th, td {
        text-align: left;
        padding: 0.6rem 0.75rem;
        border-bottom: 1px solid var(--c-border);
      }
      th {
        background: var(--c-surface-alt);
        color: var(--c-text-secondary);
        font-family: var(--font-display);
        font-weight: 600;
        font-size: 0.8rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      td {
        color: var(--c-text);
      }
      tbody tr {
        transition: background 0.15s ease;
      }
      tbody tr:hover {
        background: var(--c-accent-subtle);
      }

      /* ── Video / camera ────────────────────────────── */
      .video-frame {
        position: relative;
        border-radius: var(--radius-md);
        overflow: hidden;
        background: var(--c-navy-900);
        height: 100px;
        min-height: 100px;
        width: 200px;
        max-width: 60vw;
        border: 1px solid var(--c-border-strong);
      }
      video {
        width: 200px;
        max-width: 60vw;
        height: 100px;
        object-fit: cover;
        display: block;
      }
      canvas { display: none; }

      /* ── Footer & badge ────────────────────────────── */
      footer {
        text-align: center;
        padding: 2rem 1rem 3rem;
        color: var(--c-text-tertiary);
        font-size: 0.85rem;
      }
      .stelau-badge {
        position: fixed;
        left: 1rem;
        bottom: 1rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.45rem 0.85rem;
        border-radius: var(--radius-pill);
        background: var(--c-surface);
        color: var(--c-text);
        font-family: var(--font-display);
        font-size: 0.7rem;
        font-weight: 600;
        text-decoration: none;
        border: 1px solid var(--c-border-strong);
        box-shadow: var(--shadow-sm);
        transition: all 0.2s ease;
        z-index: 50;
        letter-spacing: 0.02em;
      }
      .stelau-badge:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-1px);
      }
      .stelau-badge .stelau-badge__prefix {
        font-weight: 400;
        color: var(--c-text-tertiary);
      }

      /* ── Animations ────────────────────────────────── */
      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(12px); }
        to   { opacity: 1; transform: translateY(0); }
      }

      /* ── Scrollbar ─────────────────────────────────── */
      ::-webkit-scrollbar { width: 6px; height: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 3px; }

      /* ── Responsive ────────────────────────────────── */
      @media (max-width: 640px) {
        .page-header {
          padding: 1.5rem 1rem 1.75rem;
        }
        .page-header h1 {
          font-size: clamp(1.2rem, 5.5vw, 1.5rem);
        }
        main {
          padding: 0.75rem 0.75rem 2rem;
        }
        .card {
          padding: 1.15rem;
          border-radius: var(--radius-lg);
        }
        button {
          width: 100%;
          justify-content: center;
        }
        th, td {
          font-size: 0.82rem;
          padding: 0.5rem 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <header class="page-header" role="banner">
      <nav aria-label="Breadcrumb" class="breadcrumb-nav">
        <a href="index.html">Home</a>
        <span aria-hidden="true"> / </span>
        <span>Unlinkability Test</span>
      </nav>
      <h1>Attestation Unlinkability Test</h1>
      <p class="muted" style="margin: 0.75rem auto 0; max-width: 580px; color: rgba(248,250,252,0.55); font-size: 0.92rem; line-height: 1.55">
        Check whether a digital ID wallet can be tracked across multiple scans. Each scan requests minimal data and compares device fingerprints.
      </p>
      <p class="muted" style="margin: 0.5rem auto 0; max-width: 580px; color: rgba(248,250,252,0.4); font-size: 0.82rem; line-height: 1.5">
        All data stays in your browser. Nothing is sent to any server.
      </p>
    </header>
    <main>
      <section class="card" id="linkSection">
        <h2 style="margin: 0 0 0.5rem 0; font-size: 1.15rem">
          Device Key Linkability
        </h2>
        <p class="muted" style="margin: 0 0 0.5rem 0">
          Each scan requests only minimal information (age or nationality). The device fingerprint is then compared with previous scans to see if the same device can be identified across sessions.
        </p>
        <div class="status" style="margin-top: 0.25rem">
          <div>
            <strong>Holder status:</strong>
            <span id="holderStatus">No attestation read yet.</span>
          </div>
          <div style="margin-top: 0.25rem">
            <strong>Last device key:</strong> <span id="lastDeviceKey">—</span>
          </div>
          <div style="margin-top: 0.25rem">
            <strong>Last document type:</strong> <span id="lastDocType">—</span>
          </div>
        </div>
        <div style="margin-top: 0.75rem">
          <div
            class="muted"
            style="
              margin-bottom: 0.25rem;
              display: flex;
              justify-content: space-between;
              align-items: center;
              gap: 0.5rem;
            "
          >
            <span>History (this browser only)</span>
            <button
              id="btnResetUnlinkability"
              class="secondary"
              title="Clear all unlinkability history stored in this browser"
              style="
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 6px 10px;
                font-size: 0.8rem;
              "
            >
              ♻️ Reset History
            </button>
          </div>
          <div style="overflow: auto; max-height: 40vh">
            <table id="historyTable">
              <thead>
                <tr>
                  <th>First seen</th>
                  <th>Last seen</th>
                  <th>Doc type</th>
                  <th>Seen</th>
                  <th>Device Key fingerprint</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="card" id="controls">
        <!-- Auto mode: no manual check-in/out controls -->
        <div class="row" style="margin-top: 0.75rem">
          <button id="btnScan">Scan QR Code</button>
          <label class="inline muted"
            >Request
            <select
              id="requestTypeSelect"
              style="
                padding: 0.4rem 0.55rem;
                border-radius: var(--radius-sm);
                border: 1px solid var(--c-border-strong);
                font-family: var(--font-body);
                font-size: 0.85rem;
                background: var(--c-surface-alt);
                color: var(--c-text);
              "
            >
              <option value="pid_nationality">EU PID : nationality</option>
              <option value="av_age18" selected>AV : age_over_18</option>
              <option value="mdl_age18">mDL : age_over_18</option>
            </select>
          </label>
          <label class="inline muted"
            >BLE MTU
            <input
              id="chunk"
              type="number"
              min="20"
              max="511"
              value="244"
              style="
                width: 80px;
                padding: 0.4rem 0.55rem;
                border-radius: var(--radius-sm);
                border: 1px solid var(--c-border-strong);
                font-family: var(--font-body);
                font-size: 0.85rem;
                background: var(--c-surface-alt);
                color: var(--c-text);
              "
            />
          </label>
        </div>
        <div class="video-frame" style="margin-top: 0.75rem">
          <video id="video" playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="status" style="margin-top: 0.75rem">
          <div><strong>Status:</strong> <span id="qrStatus">Idle</span></div>
        </div>
        <div style="margin-top: 0.75rem">
          <label class="muted" for="qrInput">Manual QR payload</label>
          <textarea
            id="qrInput"
            placeholder="Paste the full mdoc: URI here"
          ></textarea>
          <div class="row" style="margin-top: 0.5rem">
            <button id="btnParseQr" class="secondary">
              Use manual payload
            </button>
            <button id="btnClearQr">Clear</button>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <a
        href="https://www.stelau.com"
        target="_blank"
        rel="noreferrer"
        class="stelau-badge"
        aria-label="Powered by Stelau"
      >
        <span class="stelau-badge__prefix">Powered by</span>
        <span>Stelau</span>
      </a>
      <span
        id="appVersionFooter"
        style="
          display: block;
          margin-top: 0.5rem;
          color: var(--c-text-tertiary);
          font-size: 0.7rem;
          font-family: var(--font-mono);
        "
      ></span>
      <br />
      <span style="font-size: 0.82rem; color: var(--c-text-tertiary)"
        >&copy; 2026 Stelau. All rights reserved.</span
      >
    </footer>

    <!-- Libs -->
    <script src="js/jsQR.js"></script>
    <script src="js/cbor.min.js"></script>
    <script src="js/noble-curves.min.js"></script>
    <script src="js/session-crypto.js"></script>
    <script src="js/ble-transport.js"></script>
    <script src="js/session-establishment.js"></script>
    <script src="js/verification.js"></script>
    <!-- Feature modules used by visitor page -->
    <script src="js/device-engagement.js"></script>
    <script src="js/wallet-response.js"></script>
    <script src="js/request-builder.js"></script>

    <script type="module">
      // Structured data (JSON-LD) for SEO
      try {
        const ld = document.createElement("script");
        ld.type = "application/ld+json";
        ld.text = JSON.stringify({
          "@context": "https://schema.org",
          "@type": "WebPage",
          name: "Attestation Unlinkability Test · mDoc BLE",
          description:
            "Unlinkability test for EU PID,  Age Verification or mDL attestations comparing MSO deviceKey values.",
          url: location && location.href ? location.href : undefined,
          breadcrumb: {
            "@type": "BreadcrumbList",
            itemListElement: [
              {
                "@type": "ListItem",
                position: 1,
                name: "Home",
                item:
                  location && location.origin
                    ? location.origin + "index.html"
                    : "index.html",
              },
              {
                "@type": "ListItem",
                position: 2,
                name: "Unlinkability Test",
                item:
                  location && location.href
                    ? location.href
                    : "unlikability_test.html",
              },
            ],
          },
        });
        document.head.appendChild(ld);
      } catch {}

      // Footer: show APP_VERSION if available
      window.addEventListener("DOMContentLoaded", () => {
        const footerVersion = document.getElementById("appVersionFooter");
        const ver =
          typeof window.APP_VERSION !== "undefined" ? window.APP_VERSION : null;
        if (footerVersion && ver != null) {
          footerVersion.innerText = `v${ver}`;
        }
      });

      // ==== CBOR bootstrap ====
      let CBORRef = self.CBOR || self.cbor;
      if (!CBORRef) {
        try {
          CBORRef =
            await import("https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.mjs");
        } catch (e) {
          console.error("CBOR library load failed", e);
        }
      }
      if (!CBORRef) throw new Error("CBOR library unavailable");
      const CBOR = CBORRef;
      window.CBOR = CBOR;

      // ==== Globals / DOM ====
      const statusEl = document.getElementById("qrStatus");
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const qrInput = document.getElementById("qrInput");
      const btnParseQr = document.getElementById("btnParseQr");
      const btnClearQr = document.getElementById("btnClearQr");
      const btnScan = document.getElementById("btnScan");
      const requestTypeSelect = document.getElementById("requestTypeSelect");
      const chunkInput = document.getElementById("chunk");
      const holderStatusEl = document.getElementById("holderStatus");
      const lastDeviceKeyEl = document.getElementById("lastDeviceKey");
      const lastDocTypeEl = document.getElementById("lastDocType");
      const historyBodyEl = document.getElementById("historyBody");
      const btnResetUnlinkability = document.getElementById(
        "btnResetUnlinkability",
      );

      // Auto mode: each scan establishes a fresh session and evaluates linkability

      // ==== Minimal logger ====
      function log(msg) {
        console.log(msg);
        if (statusEl) {
          statusEl.textContent = String(msg).slice(0, 140);
        }
      }

      // ==== State ====
      let scanRunning = false;
      let svcUUID = null,
        bleAddr = null;
      let deBytes = null;
      let mdocPubKey = null;
      let readerKeyPair = null;
      let skReader = null,
        skDevice = null;
      let transcriptAAD = null;
      let sessionEstablished = false;
      window.skDevice = skDevice;

      function resetSessionState() {
        try {
          sessionEstablished = false;
        } catch {}
        try {
          readerKeyPair = null;
        } catch {}
        try {
          skReader = null;
          skDevice = null;
          window.skDevice = null;
        } catch {}
        try {
          transcriptAAD = null;
        } catch {}
      }

      function disconnectBLE() {
        try {
          if (window.BLE && typeof window.BLE.disconnect === "function") {
            window.BLE.disconnect();
          }
        } catch (e) {
          console.warn("Error disconnecting BLE device:", e);
        }
        resetSessionState();
      }

      // BLE UUIDs are managed by the BLE transport module

      // ==== QR Camera ====
      async function startCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
        });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        scanRunning = true;
        statusEl.textContent = "Scanning…";
        requestAnimationFrame(tick);
      }
      function stopCamera() {
        scanRunning = false;
        try {
          video.pause();
        } catch {}
        if (video.srcObject) {
          for (const t of video.srcObject.getTracks()) {
            t.stop();
          }
          video.srcObject = null;
        }
      }
      function tick() {
        if (!scanRunning) return;
        const ctx2d = canvas.getContext("2d", { willReadFrequently: true });
        ctx2d.drawImage(video, 0, 0, canvas.width, canvas.height);
        const img = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(img.data, img.width, img.height, {
          inversionAttempts: "dontInvert",
        });
        if (code?.data) {
          stopCamera();
          statusEl.textContent = "QR detected";
          handleQrPayload(code.data, "camera");
          return;
        }
        requestAnimationFrame(tick);
      }
      btnScan.addEventListener("click", () => {
        disconnectBLE();
        startCamera().catch((e) => log("Camera error: " + e.message));
      });
      btnParseQr.addEventListener("click", () => {
        handleQrPayload(qrInput.value, "manual");
      });
      btnClearQr.addEventListener("click", () => {
        qrInput.value = "";
        statusEl.textContent = "Idle";
      });

      // ==== DeviceEngagement helpers ====
      function parseMdocUriAndDE(uri) {
        const res = window.DeviceEngagement.parseMdocUriAndDE(uri);
        deBytes = res.deBytes;
        if (res.x && res.y) mdocPubKey = { x: res.x, y: res.y };
        return { uuid: res.uuid, addr: res.addr };
      }

      // ==== Session key + transcript via modules ====
      // Use SessionCrypto and SessionEstablishment provided by shared modules

      // ==== Messages ====
      async function buildLegacySessionEstablishmentWithData() {
        // Build a DeviceRequest based on the selected request type:
        // - PID : nationality
        // - AV  : age_over_18
        // - mDL : age_over_18
        const buildSelectedRequest = async () => {
          const deviceRequest = { version: "1.0", docRequests: [] };
          const sel =
            (requestTypeSelect && requestTypeSelect.value) || "av_age18";

          let docType, namespace, fields;
          if (sel === "pid_nationality") {
            docType = "eu.europa.ec.eudi.pid.1";
            namespace = "eu.europa.ec.eudi.pid.1";
            fields = { nationality: false };
          } else if (sel === "mdl_age18") {
            docType = "org.iso.18013.5.1.mDL";
            namespace = "org.iso.18013.5.1";
            fields = { age_over_18: false };
          } else {
            // 'av_age18' default
            docType = "eu.europa.ec.av.1";
            namespace = "eu.europa.ec.av.1";
            fields = { age_over_18: false };
          }

          const items = {
            docType,
            nameSpaces: { [namespace]: fields },
            requestInfo: {},
          };
          const tagged = new CBOR.Tagged(24, CBOR.encode(items));
          deviceRequest.docRequests.push({ itemsRequest: tagged });
          return CBOR.encode(deviceRequest);
        };

        const {
          message,
          keys,
          transcriptAAD: aad,
        } = await window.SessionEstablishment.buildLegacySessionEstablishmentWithData(
          {
            deBytes,
            mdocPubKey,
            readerKeyPair,
            transcriptAAD,
            skReader,
            buildRequestByType: buildSelectedRequest,
            log,
            CBOR,
          },
        );
        if (keys) {
          skReader = keys.readerKey;
          skDevice = keys.deviceKey;
          window.skDevice = skDevice;
          sessionEstablished = true;
          window.sessionEstablished = true;
        }
        if (aad) transcriptAAD = aad;
        return message;
      }

      // ==== BLE transport via module ====

      async function autoConnectFlow() {
        // Connect
        const connected = !!(
          window.BLE &&
          typeof window.BLE.isConnected === "function" &&
          window.BLE.isConnected()
        );
        if (!connected) {
          if (!svcUUID) throw new Error("Service UUID missing");
          if (
            !window.BLE ||
            typeof window.BLE.connect !== "function" ||
            typeof window.BLE.init !== "function"
          ) {
            throw new Error("BLE module not available");
          }
          window.BLE.init({
            onAssembled: processS2CAssembled,
            logger: log,
            defaultChunk: parseInt(chunkInput.value, 10) || 185,
          });
          statusEl.textContent = `Connecting…`;
          try {
            await window.BLE.connect(svcUUID);
          } catch (e) {
            // If the underlying cached service/characteristics were invalidated, force a full reset and retry once
            console.warn(
              "First connect attempt failed, retrying after reset:",
              e,
            );
            try {
              window.BLE.disconnect();
            } catch {}
            await new Promise((r) => setTimeout(r, 300));
            await window.BLE.connect(svcUUID);
          }
          await new Promise((r) => setTimeout(r, 300));
        }
        // Start session
        await window.BLE.writeState(0x01);
        await new Promise((r) => setTimeout(r, 300));
        // Ephemeral key + transcript
        readerKeyPair =
          await window.SessionEstablishment.makeReaderEphemeralKeyPair();
        await window.SessionEstablishment.exportReaderPublicToCoseKey(
          readerKeyPair,
        );
        transcriptAAD =
          await window.SessionEstablishment.buildTranscriptAAD(deBytes);
        // Build + send request
        const legacyMessage = await buildLegacySessionEstablishmentWithData();
        statusEl.textContent = `Sending request… (${legacyMessage.length} bytes)`;
        await window.BLE.sendFragmented(
          legacyMessage,
          parseInt(chunkInput.value, 10) || 185,
        );
        statusEl.textContent = "Request sent. Waiting for wallet…";
      }

      // ==== S->C assembly and processing ====
      async function processS2CAssembled(assembled, reason = "final-flag") {
        try {
          const decoded = CBOR.decode(assembled);
          // Treat as session response until keys are ready
          let isSessionResponse = !skReader || !skDevice;
          if (!isSessionResponse) {
            // still allow by heuristic
            if (decoded instanceof Map)
              isSessionResponse =
                decoded.has("eDeviceKey") ||
                decoded.has("data") ||
                decoded.has("status");
            else if (decoded && typeof decoded === "object")
              isSessionResponse =
                "eDeviceKey" in decoded ||
                "data" in decoded ||
                "status" in decoded;
          }
          if (isSessionResponse) {
            await processSessionResponse(assembled);
          } else {
            await decryptAndDisplayResponse(assembled);
          }
        } catch (e) {
          console.warn("CBOR decode failed, treating as binary", e);
        }
      }

      // BLE notifications assembly is handled in BLE transport module

      // Bridges to WalletResponse helpers
      // Avoid calling WalletResponse decryptors directly here because they render UI elements
      // that don't exist on this page. We'll do local decrypt-to-object and then call the
      // overridden display function.

      async function decryptSessionEstablishmentDataLocal(encryptedData) {
        // IV: mdoc identifier (8 bytes) || counter (4 bytes, big-endian 1)
        const mdocIdentifier = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
        const iv = new Uint8Array(12);
        iv.set(mdocIdentifier, 0);
        new DataView(iv.buffer, 8, 4).setUint32(0, 1, false);
        if (!window.skDevice) throw new Error("SKDevice key not set");
        const key = await crypto.subtle.importKey(
          "raw",
          new Uint8Array(window.skDevice),
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"],
        );
        const plaintext = await crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv,
            additionalData: new Uint8Array(0),
            tagLength: 128,
          },
          key,
          encryptedData,
        );
        return CBOR.decode(new Uint8Array(plaintext));
      }

      async function decryptCoseEncrypt0ToObjectLocal(encryptedCose) {
        const cose = CBOR.decode(encryptedCose);
        if (!Array.isArray(cose) || cose.length !== 3)
          throw new Error("Invalid COSE_Encrypt0");
        const [_prot, unprot, ciphertext] = cose;
        const iv =
          unprot instanceof Map ? unprot.get(5) : unprot ? unprot[5] : null;
        if (!iv) throw new Error("No IV in COSE unprotected header");
        if (!window.skDevice) throw new Error("SKDevice key not set");
        const key = await crypto.subtle.importKey(
          "raw",
          new Uint8Array(window.skDevice),
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"],
        );
        const plaintext = await crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv: new Uint8Array(iv),
            additionalData: new Uint8Array(0),
            tagLength: 128,
          },
          key,
          new Uint8Array(ciphertext),
        );
        return CBOR.decode(new Uint8Array(plaintext));
      }

      // ==== Session finalization (from index) simplified ====
      async function processSessionResponse(assembled) {
        if (!readerKeyPair)
          throw new Error("Reader ephemeral key pair not initialized");
        let decoded = null;
        try {
          decoded = CBOR.decode(assembled);
        } catch {}
        const toMap = (v) => {
          if (!v) return null;
          if (v instanceof Map) return v;
          if (typeof v === "object") {
            const m = new Map();
            for (const k of Object.keys(v)) m.set(k, v[k]);
            return m;
          }
          return null;
        };
        const decodedMap = toMap(decoded);
        // Derive keys using DeviceEngagement key
        const mdocPub = await window.SessionCrypto.importMdocPubKeyXY(
          mdocPubKey.x,
          mdocPubKey.y,
        );
        const sharedSecretBuffer =
          await window.SessionCrypto.deriveSharedSecretBits(
            readerKeyPair.privateKey,
            mdocPub,
          );
        transcriptAAD =
          await window.SessionEstablishment.buildTranscriptAAD(deBytes);
        const keys = await window.SessionCrypto.deriveSessionKey(
          new Uint8Array(sharedSecretBuffer),
          transcriptAAD,
        );
        skReader = keys.readerKey;
        skDevice = keys.deviceKey;
        window.skDevice = skDevice;
        sessionEstablished = true;
        // Decrypt raw data if present
        const responseData = decodedMap
          ? decodedMap.get("data") || decodedMap.get(4)
          : null;
        const toBytes = (v) => {
          try {
            if (v && v.constructor && v.constructor.name === "Tagged")
              v = v.value;
          } catch {}
          if (v instanceof Uint8Array) return v;
          if (ArrayBuffer.isView(v))
            return new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
          if (v instanceof ArrayBuffer) return new Uint8Array(v);
          if (Array.isArray(v)) return new Uint8Array(v);
          return null;
        };
        const dataBytes = toBytes(responseData);
        if (dataBytes && dataBytes.length > 0) {
          const deviceResponse =
            await decryptSessionEstablishmentDataLocal(dataBytes);
          await handleDeviceResponseForUnlinkability(deviceResponse);
        } else {
          // In alternate flow, wallet may send DeviceResponse directly as the first message
          try {
            const deviceResponse =
              await decryptCoseEncrypt0ToObjectLocal(assembled);
            await handleDeviceResponseForUnlinkability(deviceResponse);
          } catch (e) {
            console.warn("Fallback decrypt failed:", e);
          }
        }
      }

      // ==== DeviceKey extraction and unlinkability tracking ====

      const DEVICE_KEY_STORE_KEY = "unlinkability_device_keys";

      function loadDeviceKeyStore() {
        try {
          const raw = localStorage.getItem(DEVICE_KEY_STORE_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch {
          return {};
        }
      }

      function saveDeviceKeyStore(store) {
        try {
          localStorage.setItem(DEVICE_KEY_STORE_KEY, JSON.stringify(store));
        } catch {}
      }

      function renderDeviceKeyHistory() {
        if (!historyBodyEl) return;
        const store = loadDeviceKeyStore();
        const entries = Object.entries(store)
          .map(([fingerprint, info]) => ({ fingerprint, ...info }))
          .sort((a, b) => (a.firstSeen || "").localeCompare(b.firstSeen || ""));
        historyBodyEl.innerHTML = entries
          .map((row) => {
            const shortFp = row.fingerprint
              ? row.fingerprint.slice(0, 16) +
                (row.fingerprint.length > 16 ? "…" : "")
              : "—";
            return `<tr>
            <td>${row.firstSeen ? new Date(row.firstSeen).toLocaleString() : ""}</td>
            <td>${row.lastSeen ? new Date(row.lastSeen).toLocaleString() : ""}</td>
            <td>${row.lastDocType || ""}</td>
            <td>${row.count || 1}</td>
            <td>${shortFp}</td>
          </tr>`;
          })
          .join("");
      }

      function fingerprintDeviceKey(deviceKey) {
        try {
          let keyObj = deviceKey;
          console.log("Raw deviceKey for fingerprinting:", keyObj);
          // Unwrap CBOR Tag(24, bstr .cbor COSE_Key) if present
          if (
            keyObj &&
            typeof keyObj === "object" &&
            keyObj.tag === 24 &&
            keyObj.value
          ) {
            const inner = keyObj.value;
            let bytes = null;
            if (inner instanceof Uint8Array) bytes = inner;
            else if (Array.isArray(inner)) bytes = new Uint8Array(inner);
            else if (
              inner &&
              inner.type === "Buffer" &&
              Array.isArray(inner.data)
            )
              bytes = new Uint8Array(inner.data);
            else if (inner instanceof ArrayBuffer)
              bytes = new Uint8Array(inner);
            if (bytes) {
              keyObj = CBOR.decode(bytes);
            }
          }
          const toBytes = (v) => {
            if (!v) return null;
            if (v instanceof Uint8Array) return v;
            if (Array.isArray(v)) return new Uint8Array(v);
            if (v && v.type === "Buffer" && Array.isArray(v.data))
              return new Uint8Array(v.data);
            if (v instanceof ArrayBuffer) return new Uint8Array(v);
            return null;
          };

          // Prefer a fingerprint based solely on the COSE_Key public key
          // coordinates (labels -2 and -3) so different device keys always
          // yield different fingerprints even if other fields are similar.
          const getField = (o, k) => (o instanceof Map ? o.get(k) : o?.[k]);
          const xVal = getField(keyObj, -2) ?? getField(keyObj, "-2");
          const yVal = getField(keyObj, -3) ?? getField(keyObj, "-3");
          const xBytes = toBytes(xVal);
          const yBytes = toBytes(yVal);
          if (xBytes && yBytes) {
            const concat = new Uint8Array(xBytes.length + yBytes.length);
            concat.set(xBytes, 0);
            concat.set(yBytes, xBytes.length);
            return Array.from(concat)
              .map((b) => b.toString(16).padStart(2, "0"))
              .join("");
          }

          // Fallback: hash full COSE_Key structure via CBOR encoding
          const bytes = CBOR.encode(keyObj);
          return Array.from(bytes)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        } catch (e) {
          console.warn("Failed to fingerprint deviceKey:", e);
          return null;
        }
      }

      function msoToDebugJSON(mso) {
        try {
          if (
            window.WalletResponse &&
            typeof window.WalletResponse.convertToJSON === "function"
          ) {
            return window.WalletResponse.convertToJSON(mso);
          }
        } catch {}
        return mso;
      }

      function findDeviceKeyDeep(obj, visited) {
        if (!obj) return null;
        if (!visited) visited = new Set();
        if (visited.has(obj)) return null;
        visited.add(obj);

        const tryKey = (key, value) => {
          if (!key) return null;
          const k = String(key).toLowerCase();
          if (
            k.includes("devicekey") ||
            k.includes("device_key") ||
            k === "edevicekey" ||
            k === "e_device_key"
          ) {
            return value;
          }
          return null;
        };

        if (obj instanceof Map) {
          for (const [k, v] of obj.entries()) {
            const direct = tryKey(k, v);
            if (direct != null) return direct;
            const nested = findDeviceKeyDeep(v, visited);
            if (nested != null) return nested;
          }
          return null;
        }
        if (typeof obj === "object") {
          for (const k of Object.keys(obj)) {
            const v = obj[k];
            const direct = tryKey(k, v);
            if (direct != null) return direct;
            const nested = findDeviceKeyDeep(v, visited);
            if (nested != null) return nested;
          }
        }
        return null;
      }

      function extractDeviceKeyFromDeviceResponse(deviceResponse) {
        console.log(
          "Device Response for deviceKey extraction:",
          deviceResponse,
        );
        const getField = (o, k) => (o instanceof Map ? o.get(k) : o?.[k]);
        const documents = getField(deviceResponse, "documents");
        if (!Array.isArray(documents) || documents.length === 0) return null;

        for (const doc of documents) {
          try {
            const issuerSigned = getField(doc, "issuerSigned");
            if (!issuerSigned) continue;
            let issuerAuth = getField(issuerSigned, "issuerAuth");
            if (!issuerAuth) continue;

            let cose = issuerAuth;
            // Unwrap Tag(24, bstr .cbor COSE_Sign1)
            if (
              cose &&
              cose.constructor &&
              cose.constructor.name === "Tagged" &&
              cose.tag === 24
            ) {
              const value = cose.value;
              const bytes =
                value instanceof Uint8Array ? value : new Uint8Array(value);
              cose = CBOR.decode(bytes);
            } else if (
              cose &&
              typeof cose === "object" &&
              cose.tag === 24 &&
              cose.value !== undefined
            ) {
              const value = cose.value;
              const bytes =
                value instanceof Uint8Array
                  ? value
                  : Array.isArray(value)
                    ? new Uint8Array(value)
                    : null;
              if (bytes) cose = CBOR.decode(bytes);
            }

            if (!Array.isArray(cose) || cose.length < 3) continue;
            const payload = cose[2];
            const payloadBytes =
              payload instanceof Uint8Array ? payload : new Uint8Array(payload);
            let mso = CBOR.decode(payloadBytes);

            // Unwrap nested Tag(24) around MSO (MobileSecurityObjectBytes)
            let guard = 0;
            let changed = true;
            while (changed && guard++ < 3) {
              changed = false;
              if (
                mso &&
                typeof mso === "object" &&
                mso.tag === 24 &&
                mso.value
              ) {
                const inner = mso.value;
                let innerBytes = null;
                if (inner instanceof Uint8Array) innerBytes = inner;
                else if (Array.isArray(inner))
                  innerBytes = new Uint8Array(inner);
                else if (
                  inner &&
                  inner.type === "Buffer" &&
                  Array.isArray(inner.data)
                )
                  innerBytes = new Uint8Array(inner.data);
                else if (inner instanceof ArrayBuffer)
                  innerBytes = new Uint8Array(inner);
                if (innerBytes) {
                  mso = CBOR.decode(innerBytes);
                  changed = true;
                }
              }
            }

            // Log the raw CBOR-decoded MSO object for inspection
            console.log("MSO (raw CBOR-decoded):", mso);

            console.log(
              "MSO decoded for deviceKey extraction (debug JSON):",
              msoToDebugJSON(mso),
            );

            const mget = (obj, keys) => {
              if (!obj) return undefined;
              for (const k of keys) {
                const v = obj instanceof Map ? obj.get(k) : obj?.[k];
                if (v !== undefined) return v;
              }
              return undefined;
            };

            // In your MSO example, deviceKeyInfo is a named field, but
            // some implementations may use a numeric label (e.g. 4).
            let deviceKeyInfo = mget(mso, ["deviceKeyInfo", 4]);
            if (!deviceKeyInfo) {
              // Some implementations may use different labels; try heuristic search
              console.warn(
                "MSO has no deviceKeyInfo field under expected keys; attempting heuristic search.",
                msoToDebugJSON(mso),
              );
              const heuristic = findDeviceKeyDeep(mso);
              if (heuristic != null) {
                console.log("Heuristic found deviceKey-like value in MSO");
                return heuristic;
              }
              continue;
            }
            // In your MSO example, deviceKey is encoded under the numeric
            // key 1 inside deviceKeyInfo (converted to "deviceKey" in JSON
            // view). Prefer that, but also allow the old numeric 0 for
            // compatibility with other wallets.
            let deviceKey = mget(deviceKeyInfo, ["deviceKey", 1, 0]);
            if (!deviceKey) {
              // As a fallback, search inside deviceKeyInfo and the whole MSO
              console.warn(
                "deviceKeyInfo present but no deviceKey field; attempting heuristic search inside deviceKeyInfo.",
                msoToDebugJSON(deviceKeyInfo),
              );
              const inner =
                findDeviceKeyDeep(deviceKeyInfo) || findDeviceKeyDeep(mso);
              if (inner == null) continue;
              deviceKey = inner;
            }
            return deviceKey;
          } catch (e) {
            console.warn("Failed to extract deviceKey from document:", e);
          }
        }
        return null;
      }

      function determineDocTypeLabel(deviceResponse) {
        const getField = (o, k) => (o instanceof Map ? o.get(k) : o?.[k]);
        const documents = getField(deviceResponse, "documents");
        if (!Array.isArray(documents) || documents.length === 0)
          return "Unknown";
        const doc = documents[0];
        const docType = getField(doc, "docType") || "Unknown";
        if (docType === "eu.europa.ec.eudi.pid.1") return "EU PID";
        if (docType === "eu.europa.ec.av.1") return "EU Age Verification";
        return docType;
      }

      async function verifyDocumentModel(model) {
        const docs = Array.isArray(model?.documents) ? model.documents : [];
        if (!docs.length) return { allValid: true, results: [] };
        if (
          !window.Verification ||
          typeof window.Verification.verifyCredentialSignature !== "function"
        ) {
          return {
            allValid: false,
            results: [],
            error: "Verification module not loaded",
          };
        }
        const results = [];
        let allValid = true;
        for (const doc of docs) {
          try {
            const res =
              await window.Verification.verifyCredentialSignature(doc);
            results.push(res);
            const claimsOk = res?.claims?.allMatched !== false;
            const holderOk = res?.holderAuthValid !== false;
            const signatureOk = res?.signatureValid !== false;
            if (!claimsOk || !holderOk || !signatureOk) allValid = false;
          } catch (e) {
            allValid = false;
            results.push({
              signatureValid: false,
              errors: [String(e?.message || e)],
            });
          }
        }
        return { allValid, results };
      }

      async function handleDeviceResponseForUnlinkability(deviceResponse) {
        try {
          console.log("Device Response:", deviceResponse);
          const model =
            window.WalletResponse.buildResponseViewModel(deviceResponse);
          const verification = await verifyDocumentModel(model);
          if (!verification.allValid) {
            console.warn(
              "Verification failed for unlinkability response:",
              verification,
            );
            if (holderStatusEl)
              holderStatusEl.textContent =
                "Verification failed — cannot evaluate linkability.";
            disconnectBLE();
            statusEl.textContent = "Verification failed";
            return;
          }
          const deviceKey = extractDeviceKeyFromDeviceResponse(deviceResponse);
          const docTypeLabel = determineDocTypeLabel(deviceResponse);

          if (!deviceKey) {
            console.warn("No deviceKey found in MSO deviceKeyInfo");
            if (holderStatusEl)
              holderStatusEl.textContent =
                "No deviceKey found in MSO – cannot evaluate linkability.";
          } else {
            const fingerprint = fingerprintDeviceKey(deviceKey);
            const store = loadDeviceKeyStore();
            const nowIso = new Date().toISOString();
            const existing = fingerprint && store[fingerprint];

            if (existing) {
              existing.lastSeen = nowIso;
              existing.lastDocType = docTypeLabel;
              existing.count = (existing.count || 1) + 1;
              if (holderStatusEl)
                holderStatusEl.textContent =
                  "Same holder as a previous attestation (deviceKey already seen).";
            } else if (fingerprint) {
              store[fingerprint] = {
                firstSeen: nowIso,
                lastSeen: nowIso,
                lastDocType: docTypeLabel,
                count: 1,
              };
              if (holderStatusEl)
                holderStatusEl.textContent =
                  "New holder – this deviceKey has not been seen before.";
            }

            saveDeviceKeyStore(store);
            renderDeviceKeyHistory();

            if (lastDeviceKeyEl && fingerprint) {
              // Show full fingerprint for the last device key
              lastDeviceKeyEl.textContent = fingerprint;
            }
            if (lastDocTypeEl) lastDocTypeEl.textContent = docTypeLabel;
          }

          // Auto-disconnect once we have processed the response to avoid stale GATT objects on next scan
          disconnectBLE();
          statusEl.textContent = "Done — disconnected";
        } catch (e) {
          console.warn("Unlinkability processing failed:", e);
          if (holderStatusEl)
            holderStatusEl.textContent = "Error while processing attestation.";
        }
      }

      // Initial history render on load
      renderDeviceKeyHistory();

      // Reset unlinkability history (local storage + UI)
      if (btnResetUnlinkability) {
        btnResetUnlinkability.addEventListener("click", () => {
          try {
            localStorage.removeItem(DEVICE_KEY_STORE_KEY);
          } catch {}
          if (holderStatusEl)
            holderStatusEl.textContent = "No attestation read yet.";
          if (lastDeviceKeyEl) lastDeviceKeyEl.textContent = "—";
          if (lastDocTypeEl) lastDocTypeEl.textContent = "—";
          renderDeviceKeyHistory();
        });
      }

      // ==== QR payload handler → connection ====
      async function handleQrPayload(raw, sourceLabel) {
        const payload = (raw || "").trim();
        if (!payload) {
          statusEl.textContent = "No payload";
          return;
        }
        disconnectBLE();
        await new Promise((r) => setTimeout(r, 150));

        let parsed;
        try {
          parsed = parseMdocUriAndDE(payload);
        } catch (e) {
          const reason = e?.message || e;
          statusEl.textContent = `Parse failed${reason ? `: ${reason}` : ""}`;
          console.error("QR parse error:", e, payload);
          return;
        }

        svcUUID = parsed.uuid;
        bleAddr = parsed.addr;
        if (qrInput) qrInput.value = payload;
        statusEl.textContent = `Parsed from ${sourceLabel || "QR"}`;

        try {
          await autoConnectFlow();
        } catch (e) {
          statusEl.textContent = `BLE error: ${e.message || e}`;
          console.error("Auto-connect failed:", e);
        }
      }
    </script>
  </body>
</html>
