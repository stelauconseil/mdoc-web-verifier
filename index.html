<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ISO 18013-5 Mobile Driver's License (mDL) Reader & Verifier | Web Bluetooth PWA</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Free web-based ISO 18013-5 mobile Driver's License (mDL) and mDoc reader and verifier. Scan QR codes, connect via Web Bluetooth, verify digital credentials, and validate IACA certificates. Works offline as a Progressive Web App.">
  <meta name="keywords" content="ISO 18013-5, mobile driver's license, mDL, mdoc, digital identity, digital credentials, Web Bluetooth, QR code scanner, IACA, certificate validation, PWA, progressive web app, CBOR, COSE, AES-GCM encryption, eIDAS, EU Digital Identity Wallet">
  <meta name="author" content="Nicolas Chalanset">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  <meta name="revisit-after" content="7 days">
  <meta name="category" content="Technology">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://mdoc-web-verifier.stelau.com/">
  <meta property="og:title" content="ISO 18013-5 Mobile Driver's License Reader & Verifier">
  <meta property="og:description" content="Free web-based mDL reader with Web Bluetooth support. Scan, connect, and verify digital driver's licenses compliant with ISO 18013-5 standard.">
  <meta property="og:image" content="/assets/icon-512.png">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://mdoc-web-verifier.stelau.com/">
  <meta property="twitter:title" content="ISO 18013-5 mDL Reader & Verifier">
  <meta property="twitter:description" content="Free web-based mobile Driver's License reader with Web Bluetooth. Verify ISO 18013-5 digital credentials instantly.">
  <meta property="twitter:image" content="/assets/icon-512.png">
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#0f172a">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="mDL Reader">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://mdoc-web-verifier.stelau.com//">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Icons -->
  <link rel="icon" href="/assets/icon-192.png">
  <link rel="apple-touch-icon" href="/assets/icon-192.png">
  <link rel="mask-icon" href="/assets/icon-192.png" color="#0f172a">
  <style>
    :root { color-scheme: light dark; font-family: "Inter", "Segoe UI", sans-serif; line-height: 1.5; }
    body { margin: 0; background: #F2F4F8; color: #111827; }
    .page-header { background: linear-gradient(135deg,#0f172a,#1e293b); color: #f8fafc; margin-bottom: 3.5rem; padding: 1rem 1rem 1rem; text-align: center; }
    .page-header h1 { margin: 0; font-size: clamp(1.8rem,3vw,2.4rem); font-weight: 600; }
    .page-header p { margin: 0.75rem auto 0; max-width: 720px; color: rgba(248,250,252,0.8); }
    main { max-width: 1100px; margin: -2rem auto 3rem; padding: 0 1.5rem 3rem; }
    .card { background: #ffffff; border-radius: 18px; padding: 1.75rem; margin-top: 1.5rem; box-shadow: 0 20px 45px -25px rgba(15,23,42,0.35); border: 1px solid rgba(148,163,184,0.25); }
    .card h2 { margin-top: 0; font-size: 1.35rem; font-weight: 600; color: #0f172a; }
    .card h3 { margin-bottom: 0.5rem; margin-top: 1.5rem; font-size: 1.15rem; color: #0f172a; }
    .muted { color: #64748b; font-size: 0.95rem; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-top: 1rem; }
    .scanner { display: grid; gap: 1.5rem; margin-top: 1rem; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); align-items: start; }
    .video-frame { position: relative; border-radius: 16px; overflow: hidden; background: #020617; min-height: 220px; }
    video#video { width: 100%; height: 100%; object-fit: cover; display: block; }
    canvas#canvas { display: none; }
  .status-panel { background: #f1f5f9; border-radius: 14px; padding: 1rem 1.25rem; font-size: 0.8rem; line-height: 1.2; }
    .status-panel span { font-family: "SFMono-Regular", "JetBrains Mono", ui-monospace, monospace; word-break: break-all; }
    label.inline { display: flex; align-items: center; gap: 0.5rem; font-weight: 500; }
    label.inline input[type="text"],
    label.inline input[type="number"] { flex: 1; min-width: 12rem; padding: 0.45rem 0.65rem; border-radius: 8px; border: 1px solid rgba(148,163,184,0.6); font-size: 0.95rem; }
  .manual-entry { margin-top: 1.5rem; display: grid; gap: 0.75rem; }
  .manual-entry textarea { width: 97%; min-height: 60px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.9rem; background: #f8fafc; resize: vertical; }
  .manual-entry textarea:focus { outline: 2px solid rgba(37,99,235,0.4); outline-offset: 2px; }
    button { font: inherit; font-weight: 600; padding: 0.55rem 1rem; border-radius: 10px; border: 1px solid rgba(15,23,42,0.08); background: #1d4ed8; color: #fff; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease; }
    button.secondary { background: #0f172a; }
    button:disabled { background: rgba(15,23,42,0.2); color: rgba(15,23,42,0.4); cursor: not-allowed; transform: none; box-shadow: none; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 12px 24px -18px rgba(30,64,175,0.9); }
    .button-grid { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; }
    .radio-group { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.75rem; }
    .radio-chip { display: inline-flex; align-items: center; gap: 0.45rem; background: #e2e8f0; border-radius: 999px; padding: 0.35rem 0.85rem; font-size: 0.95rem; cursor: pointer; transition: background 0.2s ease; }
    .radio-chip input { accent-color: #2563eb; }
    .radio-chip:hover { background: #cbd5f5; }
    .radio-group.request-type { gap: 0.5rem; }
    .radio-chip.small { padding: 0.3rem 0.75rem; font-size: 0.9rem; }
    #roleDescription { margin-top: 0.65rem; }
    .log { background: #0f172a; color: #f8fafc; padding: 1rem; border-radius: 14px; min-height: 200px; max-height: 280px; overflow-y: auto; font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.85rem; }
    pre#rx { background: #f8fafc; border-radius: 14px; padding: 1rem; white-space: pre-wrap; word-break: break-word; min-height: 120px; border: 1px solid rgba(148,163,184,0.35); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; }
    
    /* Response Display Styles */
    #responseDisplay { background: #f8fafc; border-radius: 14px; padding: 1.5rem; border: 1px solid rgba(148,163,184,0.35); }
    .response-header { background: linear-gradient(135deg, #0f3d76, #1466b8); color: white; padding: 1rem 1.25rem; border-radius: 12px; margin-bottom: 1.5rem; }
    .response-header h3 { margin: 0; font-size: 1.25rem; font-weight: 600; color: white; }
    .response-meta { color: rgba(255,255,255,0.9); font-size: 0.9rem; margin-top: 0.35rem; }
    .document-card { background: white; border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; border: 1px solid rgba(148,163,184,0.25); box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
    .document-type { font-size: 0.85rem; color: #0f766e; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; }
    .namespace-section { margin-top: 1rem; }
    .namespace-title { background: #e0f2fe; color: #0c4a6e; padding: 0.5rem 0.75rem; border-radius: 8px; font-size: 0.9rem; font-weight: 600; margin-bottom: 0.75rem; display: inline-block; }
    .data-item { display: grid; grid-template-columns: 140px 1fr; gap: 0.75rem; padding: 0.65rem 0; border-bottom: 1px solid rgba(148,163,184,0.15); }
    .data-item:last-child { border-bottom: none; }
    .data-label { font-weight: 600; color: #475569; font-size: 0.9rem; }
    .data-value { color: #0f172a; font-size: 0.9rem; word-break: break-word; }
    .data-value.binary { color: #64748b; font-style: italic; }
    .data-value.portrait-preview { display: flex; align-items: center; gap: 0.75rem; }
    .portrait-thumbnail { max-width: 80px; max-height: 100px; border-radius: 6px; border: 2px solid rgba(148,163,184,0.3); }
    .no-data { color: #94a3b8; font-style: italic; text-align: center; padding: 2rem; }
    
    .chip-list { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-top: 0.5rem; }
    .chip { background: #e2e8f0; border-radius: 999px; padding: 0.25rem 0.75rem; font-size: 0.8rem; color: #0f172a; }
    
    /* Compatibility Warning Banner */
    .compat-warning { background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; padding: 1rem 1.5rem; margin: 0 auto 1.5rem; max-width: 1100px; border-radius: 12px; box-shadow: 0 8px 24px rgba(220, 38, 38, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); display: none; position: relative; z-index: 10; }
    .compat-warning.show { display: block; }
    .compat-warning strong { font-weight: 700; }
    .compat-warning p { margin: 0; line-height: 1.6; }
    .compat-warning ul { margin: 0.5rem 0 0 1.25rem; padding: 0; }
    .compat-warning a { color: #fef3c7; text-decoration: underline; }
    
    /* PWA Status Badge Animation */
    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }
    
    footer { text-align: center; padding: 2rem 1rem 3rem; color: #64748b; font-size: 0.9rem; }
    @media (max-width: 640px) {
      .card { padding: 1.25rem; border-radius: 14px; }
      button { width: 100%; justify-content: center; }
      .button-grid { flex-direction: column; }
      .status-panel { font-size: 0.9rem; }
      .data-item { grid-template-columns: 1fr; gap: 0.25rem; }
      
      /* Make PWA badge smaller and positioned better on mobile */
      #pwaStatus {
        top: 10px !important;
        right: 10px !important;
        padding: 0.4rem 0.75rem !important;
        font-size: 0.8rem !important;
        border-radius: 20px !important;
      }
      #pwaStatusText span {
        font-size: 0.95rem !important;
      }
    }
  </style>
  
  <!-- Structured Data (JSON-LD) for SEO -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "ISO 18013-5 Mobile Driver's License Reader",
    "alternateName": "mDL Reader",
    "url": "https://mdoc-web-verifier.stelau.com/",
    "description": "Free web-based ISO 18013-5 mobile Driver's License (mDL) reader and verifier with Web Bluetooth support, QR code scanning, and IACA certificate validation.",
    "applicationCategory": "UtilityApplication",
    "operatingSystem": "Web Browser (Chrome, Edge)",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "ISO 18013-5 Compliance",
      "Web Bluetooth GATT Communication",
      "QR Code Scanning",
      "CBOR Encoding/Decoding",
      "AES-256-GCM Encryption",
      "X.509 Certificate Validation",
      "IACA Trust Anchor Support",
      "Offline PWA Functionality",
      "Mobile Driver's License Verification",
      "Device Engagement Processing"
    ],
    "browserRequirements": "Requires HTTPS, Web Bluetooth API, Camera permission",
    "screenshot": "/assets/icon-512.png",
    "softwareVersion": "2.0",
    "datePublished": "2025-01-01",
    "dateModified": "2025-10-18",
    "creator": {
      "@type": "Organization",
      "name": "ISO 18013-5 Web Reader"
    },
    "potentialAction": {
      "@type": "UseAction",
      "target": {
        "@type": "EntryPoint",
        "urlTemplate": "https://mdoc-web-verifier.stelau.com/",
        "actionPlatform": [
          "http://schema.org/DesktopWebPlatform",
          "http://schema.org/MobileWebPlatform"
        ]
      }
    }
  }
  </script>
</head>
<body>
  <header class="page-header" role="banner">
    <h1>ISO 18013-5 Web Proximity Reader</h1>
    <p>Scan an <strong>mDL/mDoc device engagement QR code</strong>, connect over <strong>Web Bluetooth</strong>, and request <strong>digital credentials</strong>. Verify mobile Driver's Licenses compliant with <strong>ISO 18013-5 standard</strong>. Data is processed locally in the browser. No data is sent to external servers.</p>
  </header>
  
  <!-- PWA Status Badge - Fixed position top-right -->
  <div id="pwaStatus" style="
    display: none;
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(5, 150, 105, 0.95);
    backdrop-filter: blur(10px);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 24px;
    font-size: 0.85rem;
    font-weight: 500;
    box-shadow: 0 4px 16px rgba(5, 150, 105, 0.25), 0 2px 4px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    animation: slideInRight 0.3s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.2);
  ">
    <span id="pwaStatusText" style="display: flex; align-items: center; gap: 0.5rem;">
      <span style="font-size: 1.1rem;">✨</span>
      <span>Installed App</span>
    </span>
  </div>
  
  <div style="max-width: 1100px; margin: 0 auto; padding: 0 1.5rem;">
    <!-- Compatibility Warning Banner -->
    <div id="compatWarning" class="compat-warning">
      <p><strong>⚠️ Browser Compatibility Issue</strong></p>
      <p id="compatMessage"></p>
    </div>
  </div>
  
  <main>
    <section class="card" id="requestSection">
      <h2>1. Request Digital Credentials</h2>
      <p class="muted">Select one or more digital credential. You can request multiple digital credentials (e.g., PID + mDL) in a single session.</p>
      
      <div style="margin-bottom: 15px;">
        <strong>EU PID (Personal Identity Document)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_basic"> EU PID Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_age"> EU PID Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_full" checked> EU PID Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>mDL (Mobile Driver's License)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="basic"> mDL Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age"> mDL Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="driving"> mDL Driving
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="full"> mDL Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>EU Age Verification (Proof of Age)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_18"> Age 18+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_21"> Age 21+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_full"> Age Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>ISO 23220 Photo ID</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="photoid_full"> Photo ID Full
        </label>
      </div>

      <div style="margin: 15px 0 15px 0;">
        <strong>mICOV (Mobile International Certificate of Vaccination)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="micov_full"> mICOV Full
        </label>
      </div>

      <div style="margin: 15px 0 15px 0;">
        <strong>mVC (Mobile Vehicle Registration Certificate)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mvc_full"> mVC Full
        </label>
      </div>
    </section>

    <section class="card" id="qrSection">
      <h2>2. Device Engagement</h2>
      <p class="muted">Use your computer camera to capture the wallet's QR code or paste details manually.</p>
      <div class="row">
        <button id="btnScan">Scan QR Code</button>
      </div>
      <div class="scanner">
        <div class="video-frame">
          <video id="video" playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="status-panel">
          <p><strong>Status:</strong> <span id="qrStatus">Idle</span></p>
          <p><strong>Device Engagement URI:</strong> <span id="mdocUri">—</span></p>
          <p><strong>Service UUID:</strong> <span id="svcUuid">—</span></p>
          <p><strong>BLE Address:</strong> <span id="bleAddr">—</span></p>
        </div>
      </div>
      <div class="row">
        <label class="inline muted">BLE MTU (bytes)
          <input id="chunk" type="number" min="20" max="512" value="185">
        </label>
        <span class="muted" style="font-size: 0.9em; margin-left: 8px;">
          Packet size for BLE transmission. Default 185 bytes works with most modern devices. 
          Reduce to 20 if connection issues occur.
        </span>
      </div>

      <div class="manual-entry">
        <label class="muted" for="qrInput">Manual QR payload (paste from clipboard or laser scanner)</label>
        <textarea id="qrInput" placeholder="Paste the full mdoc: URI or CBOR payload here"></textarea>
        <div class="row" style="margin-top:0">
          <button id="btnParseQr" class="secondary">Use manual QR payload</button>
          <button id="btnClearQr">Clear</button>
        </div>
      </div>
    </section>

    <section class="card" id="responseSection" style="display: none;">
      <h2>Wallet Response</h2>
      <div id="responseDisplay"></div>
    </section>

    <section class="card" id="logsSection">
      <h2>3. Activity Log</h2>
      <div class="row" style="margin-bottom: 0.5rem; align-items:center; gap: 12px;">
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none;">
          <input type="checkbox" id="toggleDebugCert" />
          <span class="muted">Verbose log in the console</span>
        </label>
      </div>
      <div class="log" id="log" role="log" aria-live="polite" aria-label="Session activity log"></div>
    </section>

        <section class="card" id="iacaSection">
      <h2>⚙️ Issuer Certificate Management (IACA)</h2>
      <p class="muted">Manage Issuing Authority Certification Authority (IACA) certificates for signature verification. These are used to validate the mDoc issuer signatures.</p>
      
      <div style="margin-top: 1rem;">
        <strong>Installed IACAs:</strong>
        <div id="iacaList" style="margin-top: 0.75rem; font-size: 0.9rem;">
          <div class="muted" style="font-style: italic;">Loading...</div>
        </div>
      </div>

      

      <div style="margin-top: 1.5rem;">
        <strong>Add New IACA Certificate:</strong>
        <div style="margin-top: 0.75rem;">
          <label class="muted" for="iacaInput">Paste PEM certificate (-----BEGIN CERTIFICATE-----)</label>
          <textarea id="iacaInput" placeholder="-----BEGIN CERTIFICATE-----&#10;MIIDUzCCAvmgAwIBAgISESHtNjf+2KAQ0ttWtR9EhAAPMAoGCCqGSM49BAMCMIHF&#10;...&#10;-----END CERTIFICATE-----" style="width: 97%; min-height: 80px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem; background: #f8fafc; resize: vertical; margin-top: 0.5rem;"></textarea>
          <div style="margin-top: 0.75rem;">
            <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
              <input type="checkbox" id="iacaIsTest" style="margin-right: 0.5rem;">
              <span class="muted">This is a test/development certificate (not for production use)</span>
            </label>
          </div>
          <div class="row" style="margin-top: 0.5rem;">
            <button id="btnAddIaca">Add IACA Certificate</button>
            <button id="btnClearIacaInput" class="secondary">Clear</button>
          </div>
        </div>
      </div>
    </section>

  </main>
  <footer>
    Built by <a href="https://stelau.com">Stelau</a> for ISO 18013-5 experimentation. Web Bluetooth requires HTTPS and a compatible browser.
    <span id="appVersionFooter" style="display:block;margin-top:0.5rem;color:#64748b;font-size:0.7rem;"></span>
    <br>
    <span style="font-size:0.9em;color:#888;">&copy; 2025 Stelau. All rights reserved.</span>
  </footer>

<!-- Load libs BEFORE the module -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.min.js"></script>
<script src="/noble-curves.min.js"></script>
<script>
  // Setup noble-curves global access for all elliptic curves
  // The minified bundle should expose: p256, p384, p521, brainpoolP256r1, brainpoolP384r1, brainpoolP512r1
  if (typeof nobleCurves !== 'undefined') {
    window.nobleCurves = nobleCurves;
    console.log('✅ @noble/curves loaded from local file');
    console.log('Available curves:', Object.keys(nobleCurves));
  } else {
    console.warn('⚠️ noble-curves.min.js not loaded - curve cryptography will not work');
  }
</script>

<script type="module">
// ==== App Version (must match CACHE_VERSION in sw.js) ====
const APP_VERSION = 18; // IMPORTANT: Keep in sync with CACHE_VERSION in sw.js

// ==== CBOR bootstrap (works even if global isn't set) ====
let CBORRef = self.CBOR || self.cbor;
if (!CBORRef) {
  try { CBORRef = await import('https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.mjs'); }
  catch (e) { console.error('CBOR library load failed', e); }
}
if (!CBORRef) throw new Error('CBOR library unavailable. Check network/CSP.');
const CBOR = CBORRef;

// ==== Browser Compatibility Check ====
function checkBrowserCompatibility() {
  const compatWarning = document.getElementById('compatWarning');
  const compatMessage = document.getElementById('compatMessage');
  const issues = [];
  
  // Check for HTTPS (required for Web Bluetooth)
  if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
    issues.push('This page must be served over HTTPS. Web Bluetooth is only available in secure contexts.');
  }
  
  // Check for Web Bluetooth API
  if (!navigator.bluetooth) {
    const userAgent = navigator.userAgent.toLowerCase();
    const isChrome = /chrome|chromium|edg/.test(userAgent) && !/firefox|safari/.test(userAgent);
    
    if (!isChrome) {
      issues.push('Web Bluetooth is not supported in this browser. Please use a Chromium-based browser (Chrome, Edge, or Brave).');
    } else {
      issues.push('Web Bluetooth API is not available. This may be due to browser flags or platform limitations.');
    }
  }
  
  // Check for required Web Bluetooth features
  if (navigator.bluetooth) {
    if (typeof navigator.bluetooth.requestDevice !== 'function') {
      issues.push('Web Bluetooth API is incomplete. The requestDevice() method is missing.');
    }
  }
  
  // Check for MediaDevices (camera for QR scanning)
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    issues.push('Camera access (MediaDevices API) is not available. QR code scanning will not work.');
  }
  
  // Check for Web Crypto API
  if (!window.crypto || !window.crypto.subtle) {
    issues.push('Web Crypto API is not available. Encryption and key derivation will fail.');
  }
  
  // Display warning if there are any issues
  if (issues.length > 0) {
    let message = '<ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem;">';
    issues.forEach(issue => {
      message += `<li>${issue}</li>`;
    });
    message += '</ul>';
    message += '<p style="margin-top: 0.75rem; font-size: 0.9rem;">For best results, use <strong>Chrome or Edge</strong> on desktop with HTTPS enabled.</p>';
    
    compatMessage.innerHTML = message;
    compatWarning.classList.add('show');
    
    console.warn('Browser compatibility issues detected:', issues);
    return false;
  }
  
  console.log('✓ Browser compatibility check passed');
  return true;
}

// ==== PWA Status Indicator ====
function updatePWAStatus() {
  const pwaStatus = document.getElementById('pwaStatus');
  const pwaStatusText = document.getElementById('pwaStatusText');
  
  if (!pwaStatus || !pwaStatusText) return;
  
  // Check if running as installed PWA
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches 
                    || window.navigator.standalone === true
                    || document.referrer.includes('android-app://');
  
  // Check if service worker is active
  const hasServiceWorker = 'serviceWorker' in navigator && navigator.serviceWorker.controller;
  
  if (isStandalone) {
    pwaStatusText.innerHTML = '<span style="font-size: 1.1rem;">✨</span><span>Installed App</span>';
    pwaStatus.style.display = 'block';
    pwaStatus.style.background = 'rgba(5, 150, 105, 0.95)';
    console.log('✓ Running as PWA (standalone mode)');
  } else if (hasServiceWorker) {
    pwaStatusText.innerHTML = '<span style="font-size: 1.1rem;">🔄</span><span>Offline Ready</span>';
    pwaStatus.style.display = 'block';
    pwaStatus.style.background = 'rgba(99, 102, 241, 0.95)';
    console.log('✓ Service Worker active (offline support enabled)');
  } else {
    pwaStatus.style.display = 'none';
  }
}

// Update PWA status on load and when display mode changes
window.addEventListener('load', updatePWAStatus);
window.matchMedia('(display-mode: standalone)').addEventListener('change', updatePWAStatus);

// Run compatibility check on page load
checkBrowserCompatibility();

// ==== DOM refs ====
const logEl = document.getElementById('log');
const responseDisplayEl = document.getElementById('responseDisplay');
const responseSectionEl = document.getElementById('responseSection');
const statusEl = document.getElementById('qrStatus');
const mdocUriEl = document.getElementById('mdocUri');
const svcUuidEl = document.getElementById('svcUuid');
const bleAddrEl = document.getElementById('bleAddr');
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const qrInput = document.getElementById('qrInput');
const btnParseQr = document.getElementById('btnParseQr');
const btnClearQr = document.getElementById('btnClearQr');

const btnScan = document.getElementById('btnScan');
const btnSend = document.getElementById('btnSend');
const chunkInput = document.getElementById('chunk');

// IACA management UI elements
const iacaListEl = document.getElementById('iacaList');
const iacaInput = document.getElementById('iacaInput');
const btnAddIaca = document.getElementById('btnAddIaca');
const btnClearIacaInput = document.getElementById('btnClearIacaInput');
const toggleDebugCert = document.getElementById('toggleDebugCert');

// Request type elements (now checkboxes for multi-document selection)
const requestTypeCheckboxes = document.querySelectorAll('input[name="requestType"]');

// ==== State ====
let scanRunning = false;
let device, server, service, chState, chC2S, chS2C;
let rxBuffer = [];
let svcUUID = null;
let bleAddr = null;
let currentBleRole = 'central'; // Always central mode now

let deBytes = null;              // Raw DeviceEngagement CBOR bytes
let mdocPubKey = null;           // { x:Uint8Array, y:Uint8Array } P-256
let readerKeyPair = null;        // CryptoKeyPair (ECDH)
let skReader = null;             // Uint8Array(32) - Reader encrypts requests with this
let skDevice = null;             // Uint8Array(32) - Reader decrypts responses with this
let sessionKey = null;           // DEPRECATED - kept for compatibility
let transcriptAAD = null;        // Uint8Array (SHA-256 of transcript CBOR)
let walletEphemeralKey = null;   // CryptoKey from wallet SessionEstablishment response
let sessionEstablished = false;  // Tracks if both sides derived matching session keys

// ==== Utils ====
const enc = new TextEncoder();
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.innerHTML += `[${t}] ${msg}<br>`;
  logEl.scrollTop = logEl.scrollHeight;
}
function hex(buf) { return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join(' '); }
function concatUint8(...arrs){ const n=arrs.reduce((s,a)=>s+a.length,0); const out=new Uint8Array(n); let o=0; for(const a of arrs){out.set(a,o);o+=a.length;} return out; }

// ==== BLE transport (GATT) ====

// Initialize debug toggle state
try {
  // Prefer general verbose key; fallback to legacy key
  let saved = localStorage.getItem('debug_verbose');
  if (saved === null) saved = localStorage.getItem('debug_cert');
  const initial = saved === null ? false : saved === 'true';
  window.DEBUG_CERT = initial;      // kept for existing gates
  window.DEBUG_VERBOSE = initial;   // general console verbose flag
  if (toggleDebugCert) {
    toggleDebugCert.checked = initial;
    toggleDebugCert.addEventListener('change', (e) => {
      const on = !!e.target.checked;
      window.DEBUG_CERT = on;
      window.DEBUG_VERBOSE = on;
      localStorage.setItem('debug_verbose', String(on));
      log(`Verbose console logging: ${on ? 'ON' : 'OFF'}`);
    });
  }
} catch {}
const UUIDS = { // characteristic UUIDs used by common 18013-5 demos/drafts
  state: '00000001-a123-48ce-896b-4c76973373e6',
  c2s:   '00000002-a123-48ce-896b-4c76973373e6',
  s2c:   '00000003-a123-48ce-896b-4c76973373e6'
};

async function handleServer2Client(event) {
  const data = new Uint8Array(event.target.value.buffer);
  if (data.length === 0) return;
  const flag = data[0];
  const chunk = data.slice(1);
  rxBuffer.push(chunk);
  log(`S→C notify: flag=0x${flag.toString(16)} len=${chunk.length}`);
  if (flag === 0x00) {
    const len = rxBuffer.reduce((n,a)=>n+a.length,0);
    const assembled = new Uint8Array(len);
    let o=0; for (const seg of rxBuffer) { assembled.set(seg,o); o+=seg.length; }
    rxBuffer = [];
    log(`S→C complete: ${len} bytes`);
    
    console.log('=== RECEIVED DATA FROM WALLET ===');
    console.log('Length:', len);
    console.log('Hex:', hex(assembled));
    
    // Try to decode the response
    try {
      const decoded = CBOR.decode(assembled);
      console.log('Decoded wallet response:', decoded);
      console.log('Response type:', typeof decoded);
      console.log('Is Map:', decoded instanceof Map);
      console.log('Is Object:', decoded && typeof decoded === 'object');
      
      // Check if this is a SessionEstablishment response (contains eDeviceKey)
      let isSessionResponse = false;
      
      // Log all fields to see what we actually received
      if (decoded instanceof Map) {
        console.log('Response is a Map with keys:', Array.from(decoded.keys()));
        if (decoded.has('eDeviceKey') || decoded.has('data') || decoded.has('status')) {
          isSessionResponse = true;
          console.log('✅ Detected SessionEstablishment response (Map)');
        }
      } else if (decoded && typeof decoded === 'object') {
        console.log('Response object keys:', Object.keys(decoded));
        if (decoded.eDeviceKey || decoded.eReaderKey || decoded.data || decoded.status) {
          isSessionResponse = true;
          console.log('✅ Detected SessionEstablishment response (Object)');
        }
      }
      
      // ANY response before session is established should be considered a session response
      // Check if session keys are established (skReader and skDevice are set)
      if (!skReader || !skDevice) {
        isSessionResponse = true;
        console.log('✅ Detected response before session established - treating as session response');
      }
      
      if (isSessionResponse) {
        log('📋 Received session establishment response from wallet');
        log(`🔗 Response size: ${len} bytes`);
        
        // Signal to session establishment handler
        window.sessionResponseReceived = true;
        window.sessionResponseData = assembled;
        
        try {
          await processSessionResponse(assembled);
        } catch (processError) {
          console.error('Failed to finalize session from response:', processError);
          log('❌ Session finalization failed: ' + processError.message);
        }
        
        console.log('Session response captured and signaled');
        
      } else if (skDevice && assembled.length > 20) {
        // This might be an encrypted DeviceResponse
        log('🔐 Received encrypted response - attempting to decrypt...');
        try {
          // Decrypt and display the response
          await decryptAndDisplayResponse(assembled);
        } catch (decryptError) {
          console.error('Decryption failed:', decryptError);
          log('❌ Decryption failed: ' + decryptError.message);
        }
      } else {
        log(`📄 Received ${len}-byte response from wallet`);
      }
    } catch (e) {
      console.log('Could not decode CBOR response:', e.message);
      log(`📄 Received ${len}-byte binary response from wallet`);
    }
  }
}

// Decrypt and display mDL response
async function decryptAndDisplayResponse(encryptedData) {
  console.log('=== DECRYPTING DEVICE RESPONSE ===');
  console.log('Encrypted data length:', encryptedData.length);
  console.log('Encrypted data hex:', hex(encryptedData));
  
  // Decode COSE_Encrypt0 structure
  const coseEnc0 = CBOR.decode(encryptedData);
  
  if (!Array.isArray(coseEnc0) || coseEnc0.length !== 3) {
    throw new Error('Invalid COSE_Encrypt0 structure - expected 3-element array');
  }
  
  const [protectedHeaderBytes, unprotectedHeader, ciphertext] = coseEnc0;
  
  console.log('Protected header:', protectedHeaderBytes);
  console.log('Unprotected header:', unprotectedHeader);
  console.log('Ciphertext length:', ciphertext.length);
  
  // Decode protected header
  let protectedHeader = {};
  if (protectedHeaderBytes && protectedHeaderBytes.length > 0) {
    protectedHeader = CBOR.decode(protectedHeaderBytes);
    console.log('Decoded protected header:', protectedHeader);
  }
  
  // Get IV from unprotected header (label 5)
  const iv = unprotectedHeader instanceof Map ? unprotectedHeader.get(5) : unprotectedHeader[5];
  
  if (!iv) {
    throw new Error('No IV found in unprotected header');
  }
  
  console.log('IV:', hex(new Uint8Array(iv)));
  console.log('Ciphertext (with auth tag):', hex(new Uint8Array(ciphertext)));
  
  // Decrypt with SKDevice (wallet encrypted with SKDevice, we decrypt with SKDevice)
  const plaintext = await aesGcmDecrypt(new Uint8Array(ciphertext), skDevice, new Uint8Array(iv), '');
  
  console.log('✅ Decryption successful!');
  console.log('Plaintext length:', plaintext.length);
  console.log('Plaintext hex:', hex(plaintext));
  
  // Decode the DeviceResponse
  const deviceResponse = CBOR.decode(plaintext);
  console.log('Decoded DeviceResponse:', deviceResponse);
  
  // Display the response
  displayDeviceResponse(deviceResponse);
  
  log('✅ Response decrypted and displayed successfully!');
}

// AES-GCM decryption
async function aesGcmDecrypt(ciphertextWithTag, keyBytes, iv, aad) {
  console.log('=== AES-GCM DECRYPTION ===');
  console.log('Key length:', keyBytes.length);
  console.log('IV length:', iv.length);
  console.log('AAD:', aad);
  console.log('Ciphertext+tag length:', ciphertextWithTag.length);
  
  const key = await crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
  
  const aadBytes = typeof aad === 'string' ? enc.encode(aad) : new Uint8Array(aad || 0);
  
  try {
    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv,
        additionalData: aadBytes,
        tagLength: 128  // 16 bytes
      },
      key,
      ciphertextWithTag
    );
    
    return new Uint8Array(decrypted);
  } catch (e) {
    console.error('AES-GCM decrypt error:', e);
    throw new Error('AES-GCM decryption failed: ' + e.message);
  }
}

// ===== SIGNATURE VERIFICATION FUNCTIONS =====

// Extract public key from X.509 certificate (DER format)
// Supports NIST curves (P-256, P-384) via Web Crypto API
// Supports Brainpool curves (P-256r1, P-320r1, P-384r1, P-512r1) via @noble/curves
async function extractPublicKeyFromCert(certDer, quiet = false) {
  try {
    console.log('Extracting public key from certificate, size:', certDer.length);
    
    const cert = new Uint8Array(certDer);
    
    // Detect curve type from OID
    // NIST P-256: 1.2.840.10045.3.1.7 -> 0x2A 0x86 0x48 0xCE 0x3D 0x03 0x01 0x07
    // NIST P-384: 1.3.132.0.34 -> 0x2B 0x81 0x04 0x00 0x22
    // NIST P-521: 1.3.132.0.35 -> 0x2B 0x81 0x04 0x00 0x23
    // Brainpool P256r1: 1.3.36.3.3.2.8.1.1.7  -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x07
  // Brainpool P320r1: 1.3.36.3.3.2.8.1.1.9  -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x09
  // Brainpool P384r1: 1.3.36.3.3.2.8.1.1.11 -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x0B
    // Brainpool P512r1: 1.3.36.3.3.2.8.1.1.13 -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x0D
    
    const curveOIDs = {
      'P-256': [0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07],
      'P-384': [0x2B, 0x81, 0x04, 0x00, 0x22],
      'P-521': [0x2B, 0x81, 0x04, 0x00, 0x23],
      'brainpoolP256r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07],
  'brainpoolP320r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09],
  'brainpoolP384r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B],
      'brainpoolP512r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D]
    };
    
    const findOID = (oid) => {
      for (let i = 0; i < cert.length - oid.length; i++) {
        if (cert.slice(i, i + oid.length).every((byte, idx) => byte === oid[idx])) {
          return i;
        }
      }
      return -1;
    };
    
    // Detect which curve is used
    let detectedCurve = null;
    for (const [curveName, oid] of Object.entries(curveOIDs)) {
      if (findOID(oid) !== -1) {
        detectedCurve = curveName;
        console.log(`✓ Detected curve: ${curveName}`);
        break;
      }
    }
    
    if (!detectedCurve) {
      throw new Error('Could not detect EC curve from certificate OID');
    }
    
    // Determine expected key size based on curve
    const keySizes = {
      'P-256': 65,
      'P-384': 97,
      'P-521': 133,
      'brainpoolP256r1': 65,
      'brainpoolP320r1': 81,
      'brainpoolP384r1': 97,
      'brainpoolP512r1': 129
    };
    
    const coordSizes = {
      'P-256': 32,
      'P-384': 48,
      'P-521': 66,
      'brainpoolP256r1': 32,
      'brainpoolP320r1': 40,
      'brainpoolP384r1': 48,
      'brainpoolP512r1': 64
    };
    
    const keySize = keySizes[detectedCurve];
    const coordSize = coordSizes[detectedCurve];
    
    // Find the uncompressed EC public key (starts with 0x04)
    let publicKeyBytes = null;
    for (let i = 0; i < cert.length - keySize; i++) {
      if (cert[i] === 0x04) {
        const candidate = cert.slice(i, i + keySize);
        
        // Verify it's preceded by reasonable DER structure
        // Typically: 0x03 (BIT STRING tag), length, 0x00 (no unused bits), 0x04...
        if (i >= 2 && cert[i - 1] === 0x00 && cert[i - 2] >= keySize + 1) {
          publicKeyBytes = candidate;
          console.log(`Found ${detectedCurve} public key at offset ${i}`);
          break;
        }
      }
    }
    
    if (!publicKeyBytes) {
      throw new Error(`Could not find ${detectedCurve} public key in certificate`);
    }
    
    // Extract X and Y coordinates (skip the 0x04 prefix)
    const x = publicKeyBytes.slice(1, 1 + coordSize);
    const y = publicKeyBytes.slice(1 + coordSize, 1 + 2 * coordSize);
    
    console.log(`Extracted ${detectedCurve} X:`, hex(x));
    console.log(`Extracted ${detectedCurve} Y:`, hex(y));
    
    // Use @noble/curves for all curves (both NIST and Brainpool)
    if (!window.nobleCurves) {
      if (!quiet) console.error('❌ @noble/curves library not loaded');
      return null;
    }
    
    // Map curve names to noble-curves property names
    const curveMap = {
      'P-256': 'p256',
      'P-384': 'p384',
      'P-521': 'p521',
      'brainpoolP256r1': 'brainpoolP256r1',
  'brainpoolP320r1': 'brainpoolP320r1',
  'brainpoolP384r1': 'brainpoolP384r1',
      'brainpoolP512r1': 'brainpoolP512r1'
    };
    
    const nobleCurveName = curveMap[detectedCurve];
    if (!nobleCurveName || !window.nobleCurves[nobleCurveName]) {
      if (!quiet) console.error(`❌ Curve ${detectedCurve} (${nobleCurveName}) not available in @noble/curves`);
      if (!quiet) console.log('Available curves:', Object.keys(window.nobleCurves));
      return null;
    }
    
    // Return raw key data for noble-curves verification
    console.log(`✅ ${detectedCurve} public key extracted (using @noble/curves for verification)`);
    return {
      key: publicKeyBytes, // Full uncompressed point (0x04 || X || Y)
      curve: detectedCurve,
      nobleCurveName: nobleCurveName,
      type: 'noble',
      x: x,
      y: y
    };
    
  } catch (err) {
    if (!quiet) console.error('Error extracting public key:', err.message);
    return null;
  }
}

// Lightweight helper for UI: detect EC curve from certificate OID without requiring a crypto implementation
// Returns one of: 'P-256','P-384','P-521','brainpoolP256r1','brainpoolP320r1','brainpoolP384r1','brainpoolP512r1', or null if not found
function detectCurveFromCertOID(certDer) {
  try {
    const cert = certDer instanceof Uint8Array ? certDer : new Uint8Array(certDer);
    const curveOIDs = {
      'P-256': [0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07],
      'P-384': [0x2B, 0x81, 0x04, 0x00, 0x22],
      'P-521': [0x2B, 0x81, 0x04, 0x00, 0x23],
      'brainpoolP256r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07],
      'brainpoolP320r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09],
      'brainpoolP384r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B],
      'brainpoolP512r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D]
    };
    const findOID = (oid) => {
      for (let i = 0; i <= cert.length - oid.length; i++) {
        let ok = true;
        for (let j = 0; j < oid.length; j++) {
          if (cert[i + j] !== oid[j]) { ok = false; break; }
        }
        if (ok) return i;
      }
      return -1;
    };
    for (const [curveName, oid] of Object.entries(curveOIDs)) {
      if (findOID(oid) !== -1) return curveName;
    }
    return null;
  } catch {
    return null;
  }
}

// Helper: Create download link for JPEG2000 image
function createJp2DownloadLink(jp2Bytes, portraitId) {
  const base64 = btoa(String.fromCharCode(...jp2Bytes));
  const dataUri = `data:image/jp2;base64,${base64}`;
  
  return `
    <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;">
      <div style="padding: 0.75rem 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 8px; font-size: 0.9rem;">
        ⚠️ JPEG2000 format - Browser cannot display natively
      </div>
      <a href="${dataUri}" download="portrait.jp2" style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.9rem; background: #1d4ed8; color: white; border-radius: 8px; text-decoration: none; font-size: 0.9rem; font-weight: 600;">
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
          <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
        </svg>
        Download JPEG2000
      </a>
      <div style="font-size: 0.85rem; color: #64748b;">
        Convert to JPEG using online tools or image viewer
      </div>
    </div>
  `;
}

// Extract certificate information (Subject CN, Issuer CN) from X.509 DER certificate
function extractCertInfo(certDer) {
  try {
    const cert = new Uint8Array(certDer);
    
    // Helper to parse DER length
    function parseDerLength(bytes, offset) {
      const firstByte = bytes[offset];
      if (firstByte < 0x80) {
        return { length: firstByte, bytesUsed: 1 };
      }
      const numBytes = firstByte & 0x7F;
      let length = 0;
      for (let i = 0; i < numBytes; i++) {
        length = (length << 8) | bytes[offset + 1 + i];
      }
      return { length, bytesUsed: 1 + numBytes };
    }
    
    // Helper to extract PrintableString or UTF8String
    function extractString(bytes, offset) {
      const tag = bytes[offset];
      const lenInfo = parseDerLength(bytes, offset + 1);
      const strStart = offset + 1 + lenInfo.bytesUsed;
      const strEnd = strStart + lenInfo.length;
      
      // Tags: 0x0C = UTF8String, 0x13 = PrintableString, 0x16 = IA5String
      if (tag === 0x0C || tag === 0x13 || tag === 0x16) {
        const strBytes = bytes.slice(strStart, strEnd);
        return new TextDecoder().decode(strBytes);
      }
      return null;
    }
    
    // Find Common Name (CN) in a Name structure
    // CN OID is 2.5.4.3 = 06 03 55 04 03
    function findCN(bytes, start, end) {
      const cnOid = new Uint8Array([0x06, 0x03, 0x55, 0x04, 0x03]);
      
      for (let i = start; i < end - 10; i++) {
        // Check if we found the CN OID
        if (bytes[i] === 0x06 && bytes[i + 1] === 0x03 &&
            bytes[i + 2] === 0x55 && bytes[i + 3] === 0x04 && bytes[i + 4] === 0x03) {
          // CN OID found, next should be the string value
          // Skip to the string (usually right after the OID)
          let offset = i + 5;
          // The string is typically wrapped in a SET, then the actual string
          if (bytes[offset] === 0x31) { // SET tag
            offset++; // skip tag
            const lenInfo = parseDerLength(bytes, offset);
            offset += lenInfo.bytesUsed;
          }
          // Now should be the string (PrintableString, UTF8String, etc.)
          const cn = extractString(bytes, offset);
          if (cn) return cn;
        }
      }
      return null;
    }
    
    // Parse complete Distinguished Name (DN) structure
    function parseDN(bytes, start, end) {
      // Common X.509 attribute OIDs
      const oidMap = {
        '06 03 55 04 03': 'CN',    // Common Name
        '06 03 55 04 05': 'SN',    // Serial Number
        '06 03 55 04 06': 'C',     // Country
        '06 03 55 04 07': 'L',     // Locality
        '06 03 55 04 08': 'ST',    // State/Province
        '06 03 55 04 0A': 'O',     // Organization
        '06 03 55 04 0B': 'OU',    // Organizational Unit
        '06 09 2A 86 48 86 F7 0D 01 09 01': 'E', // Email
      };
      
      const components = [];
      let offset = start;
      
      // DN is a SEQUENCE of SETs, each SET contains a SEQUENCE with OID and value
      while (offset < end) {
        // Expect SET tag (0x31)
        if (bytes[offset] !== 0x31) {
          offset++;
          continue;
        }
        offset++; // skip SET tag
        
        const setLenInfo = parseDerLength(bytes, offset);
        offset += setLenInfo.bytesUsed;
        const setEnd = offset + setLenInfo.length;
        
        // Inside SET, expect SEQUENCE (0x30)
        if (offset < setEnd && bytes[offset] === 0x30) {
          offset++; // skip SEQUENCE tag
          const seqLenInfo = parseDerLength(bytes, offset);
          offset += seqLenInfo.bytesUsed;
          
          // Now should have OID followed by value
          if (bytes[offset] === 0x06) { // OID tag
            const oidOffset = offset;
            offset++; // skip OID tag
            const oidLenInfo = parseDerLength(bytes, offset);
            offset += oidLenInfo.bytesUsed;
            const oidBytes = bytes.slice(offset, offset + oidLenInfo.length);
            offset += oidLenInfo.length;
            
            // Convert OID bytes to string key
            const oidKey = Array.from(oidBytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            const oidKey2 = `06 ${oidLenInfo.length.toString(16).padStart(2, '0').toUpperCase()} ${oidKey}`;
            
            // Get attribute name
            const attrName = oidMap[oidKey2] || `OID(${oidKey})`;
            
            // Extract value string
            const value = extractString(bytes, offset);
            if (value) {
              components.push(`${attrName}=${value}`);
            }
          }
        }
        
        offset = setEnd;
      }
      
      return components.join(', ');
    }
    
    // X.509 Certificate structure:
    // SEQUENCE {
    //   tbsCertificate SEQUENCE {
    //     version [0] EXPLICIT
    //     serialNumber
    //     signature (algorithm)
    //     issuer Name      <-- We want CN from here
    //     validity
    //     subject Name     <-- We want CN from here
    //     ...
    //   }
    // }
    
    // Start by finding the main SEQUENCE
    let offset = 0;
    if (cert[offset] !== 0x30) throw new Error('Not a valid DER certificate');
    offset++;
    
    const certLenInfo = parseDerLength(cert, offset);
    offset += certLenInfo.bytesUsed;
    
    // Now we're inside the certificate SEQUENCE
    // Next should be tbsCertificate SEQUENCE
    if (cert[offset] !== 0x30) throw new Error('Invalid tbsCertificate');
    offset++;
    
    const tbsLenInfo = parseDerLength(cert, offset);
    const tbsStart = offset + tbsLenInfo.bytesUsed;
    const tbsEnd = tbsStart + tbsLenInfo.length;
    offset = tbsStart;
    
    // Skip version (optional [0] EXPLICIT)
    if (cert[offset] === 0xA0) {
      offset++; // skip tag
      const verLenInfo = parseDerLength(cert, offset);
      offset += verLenInfo.bytesUsed + verLenInfo.length;
    }
    
    // Skip serialNumber (INTEGER)
    if (cert[offset] === 0x02) {
      offset++; // skip tag
      const snLenInfo = parseDerLength(cert, offset);
      offset += snLenInfo.bytesUsed + snLenInfo.length;
    }
    
    // Skip signature algorithm (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const algLenInfo = parseDerLength(cert, offset);
      offset += algLenInfo.bytesUsed + algLenInfo.length;
    }
    
    // Now we should be at issuer Name (SEQUENCE)
    let issuerCN = null;
    let issuerDN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const issuerLenInfo = parseDerLength(cert, offset);
      const issuerStart = offset + issuerLenInfo.bytesUsed;
      const issuerEnd = issuerStart + issuerLenInfo.length;
      
      issuerCN = findCN(cert, issuerStart, issuerEnd);
      issuerDN = parseDN(cert, issuerStart, issuerEnd);
      
      offset = issuerEnd;
    }
    
    // Skip validity (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const valLenInfo = parseDerLength(cert, offset);
      offset += valLenInfo.bytesUsed + valLenInfo.length;
    }
    
    // Now we should be at subject Name (SEQUENCE)
    let subjectCN = null;
    let subjectDN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const subjectLenInfo = parseDerLength(cert, offset);
      const subjectStart = offset + subjectLenInfo.bytesUsed;
      const subjectEnd = subjectStart + subjectLenInfo.length;
      
      subjectCN = findCN(cert, subjectStart, subjectEnd);
      subjectDN = parseDN(cert, subjectStart, subjectEnd);
    }
    
    return { subjectCN, issuerCN, subjectDN, issuerDN };
    
  } catch (err) {
    console.warn('Error parsing certificate info:', err);
    return { subjectCN: null, issuerCN: null, subjectDN: null, issuerDN: null };
  }
}

// Extract validity dates from X.509 DER certificate
function extractCertValidity(certDer) {
  try {
    const cert = new Uint8Array(certDer);
    
    // Helper to parse DER length
    function parseDerLength(bytes, offset) {
      const firstByte = bytes[offset];
      if (firstByte < 0x80) {
        return { length: firstByte, bytesUsed: 1 };
      }
      const numBytes = firstByte & 0x7F;
      let length = 0;
      for (let i = 0; i < numBytes; i++) {
        length = (length << 8) | bytes[offset + 1 + i];
      }
      return { length, bytesUsed: 1 + numBytes };
    }
    
    // Helper to parse ASN.1 time (UTCTime or GeneralizedTime)
    function parseTime(bytes, offset) {
      const tag = bytes[offset];
      const lenInfo = parseDerLength(bytes, offset + 1);
      const timeStart = offset + 1 + lenInfo.bytesUsed;
      const timeEnd = timeStart + lenInfo.length;
      const timeBytes = bytes.slice(timeStart, timeEnd);
      const timeStr = new TextDecoder().decode(timeBytes);
      
      // UTCTime: 0x17 (YYMMDDHHMMSSZ)
      // GeneralizedTime: 0x18 (YYYYMMDDHHMMSSZ)
      if (tag === 0x17) {
        // UTCTime format: YYMMDDHHMMSSZ
        const year = parseInt(timeStr.substr(0, 2));
        const fullYear = year >= 50 ? 1900 + year : 2000 + year;
        const month = parseInt(timeStr.substr(2, 2)) - 1;
        const day = parseInt(timeStr.substr(4, 2));
        const hour = parseInt(timeStr.substr(6, 2));
        const minute = parseInt(timeStr.substr(8, 2));
        const second = parseInt(timeStr.substr(10, 2));
        return new Date(Date.UTC(fullYear, month, day, hour, minute, second));
      } else if (tag === 0x18) {
        // GeneralizedTime format: YYYYMMDDHHMMSSZ
        const year = parseInt(timeStr.substr(0, 4));
        const month = parseInt(timeStr.substr(4, 2)) - 1;
        const day = parseInt(timeStr.substr(6, 2));
        const hour = parseInt(timeStr.substr(8, 2));
        const minute = parseInt(timeStr.substr(10, 2));
        const second = parseInt(timeStr.substr(12, 2));
        return new Date(Date.UTC(year, month, day, hour, minute, second));
      }
      return null;
    }
    
    // Navigate to validity field
    let offset = 0;
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const certLenInfo = parseDerLength(cert, offset);
    offset += certLenInfo.bytesUsed;
    
    // TBSCertificate SEQUENCE
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const tbsLenInfo = parseDerLength(cert, offset);
    offset += tbsLenInfo.bytesUsed;
    
    // Skip version (optional [0] EXPLICIT)
    if (cert[offset] === 0xA0) {
      offset++;
      const verLenInfo = parseDerLength(cert, offset);
      offset += verLenInfo.bytesUsed + verLenInfo.length;
    }
    
    // Skip serialNumber
    if (cert[offset] === 0x02) {
      offset++;
      const snLenInfo = parseDerLength(cert, offset);
      offset += snLenInfo.bytesUsed + snLenInfo.length;
    }
    
    // Skip signature algorithm
    if (cert[offset] === 0x30) {
      offset++;
      const algLenInfo = parseDerLength(cert, offset);
      offset += algLenInfo.bytesUsed + algLenInfo.length;
    }
    
    // Skip issuer
    if (cert[offset] === 0x30) {
      offset++;
      const issuerLenInfo = parseDerLength(cert, offset);
      offset += issuerLenInfo.bytesUsed + issuerLenInfo.length;
    }
    
    // Now at validity SEQUENCE
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const valLenInfo = parseDerLength(cert, offset);
    offset += valLenInfo.bytesUsed;
    
    // Parse notBefore
    const notBefore = parseTime(cert, offset);
    offset++;
    const notBeforeLenInfo = parseDerLength(cert, offset);
    offset += notBeforeLenInfo.bytesUsed + notBeforeLenInfo.length;
    
    // Parse notAfter
    const notAfter = parseTime(cert, offset);
    
    return { notBefore, notAfter };
    
  } catch (err) {
    console.warn('Error extracting certificate validity:', err);
    return { notBefore: null, notAfter: null };
  }
}

// Verify COSE_Sign1 signature
async function verifyCoseSign1(coseSign1, publicKey) {
  try {
    console.log('=== VERIFYING COSE_Sign1 SIGNATURE ===');
    
    // COSE_Sign1 = [protected, unprotected, payload, signature]
    if (!Array.isArray(coseSign1) || coseSign1.length < 4) {
      throw new Error('Invalid COSE_Sign1 structure');
    }
    
    const [protectedHeader, unprotectedHeader, payload, signature] = coseSign1;
    
    console.log('Protected header length:', protectedHeader?.length || 0);
    console.log('Payload length:', payload?.length || 0);
    console.log('Signature length:', signature?.length || 0);
    
    // Convert protected header to Uint8Array if it's not already
    const protectedHeaderBytes = protectedHeader instanceof Uint8Array 
      ? protectedHeader 
      : new Uint8Array(protectedHeader);
    
    const payloadBytes = payload instanceof Uint8Array 
      ? payload 
      : new Uint8Array(payload);
      
    console.log('Protected header bytes:', hex(protectedHeaderBytes));
    console.log('Payload bytes (first 32):', hex(payloadBytes.slice(0, 32)));
    
    // Decode protected header to extract algorithm (may be overridden by key curve mapping per ISO 18013-5)
    let alg = -7; // Default to ES256
    let algName = 'ES256';
    let hashAlg = 'SHA-256';
    let expectedSigLength = 64; // r||s length in bytes
    let curve = 'P-256';

    // ISO 18013-5 mapping helper: curve → (algName, hash, expectedSigLen)
    function specAlgFromCurve(nobleCurveName) {
      const name = (nobleCurveName || '').toLowerCase();
      // Defaults
      let out = { algName: 'ES256', hash: 'SHA-256', sigLen: 64, curveLabel: nobleCurveName };
      if (!name) return out;
      // ES256 curves
      if (name.includes('p256') || name.includes('brainpoolp256')) {
        return { algName: 'ES256', hash: 'SHA-256', sigLen: 64, curveLabel: name.includes('brainpool') ? 'brainpoolP256r1' : 'P-256' };
      }
      // ES384 curves
      if (name.includes('p384') || name.includes('brainpoolp384') || name.includes('brainpoolp320')) {
        // 384-bit → 96 bytes; 320-bit → 80 bytes
        const sigLen = name.includes('320') ? 80 : 96;
        const curveLabel = name.includes('brainpoolp320') ? 'brainpoolP320r1' : (name.includes('brainpool') ? 'brainpoolP384r1' : 'P-384');
        return { algName: 'ES384', hash: 'SHA-384', sigLen, curveLabel };
      }
      // ES512 curves
      if (name.includes('p521') || name.includes('brainpoolp512')) {
        // P-521 → 66+66=132; brainpoolP512r1 → 64+64=128
        const sigLen = name.includes('p521') ? 132 : 128;
        const curveLabel = name.includes('p521') ? 'P-521' : 'brainpoolP512r1';
        return { algName: 'ES512', hash: 'SHA-512', sigLen, curveLabel };
      }
      // EdDSA (if ever present)
      if (name.includes('ed25519') || name.includes('ed448')) {
        // Note: Current verifier path is ECDSA-only; EdDSA not supported here
        return { algName: 'EdDSA', hash: 'NONE', sigLen: 64, curveLabel: name.includes('ed448') ? 'Ed448' : 'Ed25519' };
      }
      return out;
    }
    
    try {
  const decodedHeader = CBOR.decode(protectedHeaderBytes);
      console.log('Decoded protected header:', decodedHeader);
      
      // Handle both Map and plain object
      if (decodedHeader instanceof Map) {
        alg = decodedHeader.get(1) || -7;
      } else if (typeof decodedHeader === 'object') {
        alg = decodedHeader[1] || -7;
      }
      
      // Set parameters based on protected header alg (initial)
      if (alg === -35) { // ES384
        algName = 'ES384';
        hashAlg = 'SHA-384';
        expectedSigLength = 96;
        curve = 'P-384';
      } else if (alg === -7) { // ES256
        algName = 'ES256';
        hashAlg = 'SHA-256';
        expectedSigLength = 64;
        curve = 'P-256';
      } else {
        console.warn('⚠️ Unknown algorithm label in protected header:', alg, '- defaulting to ES256');
      }

      // Override by spec mapping from actual key curve, if it differs
      const pkCurve = publicKey?.nobleCurveName || '';
      const mapped = specAlgFromCurve(pkCurve);
      if (mapped.algName !== algName || mapped.sigLen !== expectedSigLength) {
        console.warn(`⚠️ Protected alg suggests ${algName}, but key curve '${pkCurve}' maps to ${mapped.algName}. Adjusting.`);
        algName = mapped.algName;
        hashAlg = mapped.hash;
        expectedSigLength = mapped.sigLen;
        curve = mapped.curveLabel;
      }

      console.log(`Algorithm (effective): ${algName} (label ${alg}), Hash: ${hashAlg}, Curve: ${curve}, Expected Sig Len: ${expectedSigLength}`);
    } catch (e) {
      console.warn('Could not decode protected header, using default ES256:', e.message);
    }
    
    // Reconstruct Sig_structure per RFC 8152 Section 4.4
    // Sig_structure = [
    //   context : "Signature1",
    //   body_protected : bstr .cbor header_map,
    //   external_aad : bstr,
    //   payload : bstr
    // ]
    // 
    // CRITICAL: protectedHeaderBytes and payloadBytes are ALREADY CBOR-encoded,
    // so we need to manually build the array with them as bstr, not let CBOR.encode()
    // double-encode them.
    
    // Manually construct Sig_structure CBOR:
    // 84                    # array(4)
    //   6A 5369676E617475726531  # text(10) "Signature1"
    //   43 <protected bytes>      # bstr(3) - protected header (already CBOR)
    //   40                        # bstr(0) - empty AAD
    //   59 XXXX <payload bytes>   # bstr(length) - payload (already CBOR)
    
    function encodeBstr(bytes) {
      // CBOR byte string encoding
      const len = bytes.length;
      if (len <= 23) {
        return new Uint8Array([0x40 + len, ...bytes]);
      } else if (len <= 0xFF) {
        return new Uint8Array([0x58, len, ...bytes]);
      } else if (len <= 0xFFFF) {
        return new Uint8Array([0x59, len >> 8, len & 0xFF, ...bytes]);
      } else {
        throw new Error('Payload too large for this implementation');
      }
    }
    
    const sigStructureParts = [];
    
    // Array header: 84 (array of 4 elements)
    sigStructureParts.push(new Uint8Array([0x84]));
    
    // Element 1: "Signature1" as text string
    const contextStr = "Signature1";
    const contextBytes = new TextEncoder().encode(contextStr);
    sigStructureParts.push(new Uint8Array([0x6A, ...contextBytes])); // 0x6A = text(10)
    
    // Element 2: body_protected as bstr
    // protectedHeaderBytes is the serialized CBOR map (e.g., a1 01 26 for {1: -7})
    // For Sig_structure, we wrap it as a bstr
    console.log('DEBUG: protectedHeaderBytes for Sig_structure:', hex(protectedHeaderBytes));
    console.log('DEBUG: protectedHeaderBytes length:', protectedHeaderBytes.length);
    const encodedProtected = encodeBstr(protectedHeaderBytes);
    console.log('DEBUG: encoded protected (with bstr wrapper):', hex(encodedProtected));
    sigStructureParts.push(encodedProtected);
    
    // Element 3: external_aad as bstr (empty for COSE_Sign1)
    sigStructureParts.push(new Uint8Array([0x40])); // empty byte string
    
    // Element 4: payload as bstr
    sigStructureParts.push(encodeBstr(payloadBytes));
    
    // Concatenate all parts
    const totalLength = sigStructureParts.reduce((sum, part) => sum + part.length, 0);
    const sigStructureBytes = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of sigStructureParts) {
      sigStructureBytes.set(part, offset);
      offset += part.length;
    }
    
    console.log('Sig_structure CBOR (manual):', hex(sigStructureBytes));
    console.log('Sig_structure length:', sigStructureBytes.length);
    
    // Convert signature to the format expected by Web Crypto
    // COSE signature is raw r||s format
    // - ES256: 64 bytes (32-byte r + 32-byte s) for P-256
    // - ES384: 96 bytes (48-byte r + 48-byte s) for P-384
    // Web Crypto expects the same raw format for ECDSA
    const signatureBytes = new Uint8Array(signature);
    console.log('Signature bytes:', hex(signatureBytes));
    console.log(`Signature length: ${signatureBytes.length} bytes (expected ${expectedSigLength} for ${algName})`);
    
    if (signatureBytes.length !== expectedSigLength) {
      console.warn(`⚠️ Expected ${expectedSigLength}-byte signature for ${algName}, got`, signatureBytes.length);
    }
    
    // Use @noble/curves for all signature verification
    if (!publicKey || typeof publicKey !== 'object' || publicKey.type !== 'noble') {
      throw new Error('Invalid public key format - expected noble-curves key object');
    }
    
    if (!window.nobleCurves) {
      throw new Error('@noble/curves library not loaded');
    }
    
    const curveLib = window.nobleCurves[publicKey.nobleCurveName];
    if (!curveLib) {
      throw new Error(`Curve ${publicKey.nobleCurveName} not available in @noble/curves`);
    }
    
    console.log(`Using @noble/curves (${publicKey.nobleCurveName}) for signature verification`);
    
    console.log('🔍 Verification inputs:');
    console.log('  Signature bytes:', hex(signatureBytes).substring(0, 64) + '...');
    console.log('  Message (Sig_structure):', hex(sigStructureBytes).substring(0, 64) + '...');
    console.log('  Public key (with 0x04 prefix):', hex(publicKey.key).substring(0, 66) + '...');
    console.log('  Curve library:', publicKey.nobleCurveName);
    
  // Verify using noble-curves
  let isValid = false;
    try {
      // @noble/curves verify signature:
      // verify(signature: Hex | Signature, message: Hex, publicKey: Hex)
      // IMPORTANT: Noble-curves hashes the message internally!
      // We pass the raw Sig_structure, NOT the hash
      // signature: Uint8Array (raw r||s)
      // message: the message to verify (noble will hash it)
      // publicKey: public key WITH 0x04 prefix (uncompressed point format)
      
      isValid = curveLib.verify(
        signatureBytes,
        sigStructureBytes, // Pass the MESSAGE, not the hash!
        publicKey.key // Keep 0x04 prefix - noble-curves expects full uncompressed point
      );
      
      console.log('✓ Noble-curves verify() completed without error');
    } catch (verifyErr) {
      console.error('✗ Noble-curves verification threw error:', verifyErr);
      console.error('  Error details:', {
        name: verifyErr.name,
        message: verifyErr.message,
        stack: verifyErr.stack?.substring(0, 200)
      });
      isValid = false;
    }
    
    // Low-S normalization fallback for ECDSA (some libs enforce canonical low-S)
    if (!isValid && (publicKey.nobleCurveName === 'p256' || publicKey.nobleCurveName === 'p384') &&
        (signatureBytes.length === 64 || signatureBytes.length === 96)) {
      try {
        const halfLen = signatureBytes.length / 2;
        const rBytes = signatureBytes.slice(0, halfLen);
        const sBytes = signatureBytes.slice(halfLen);
        const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
        const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
        let curveOrder = null;
        if (publicKey.nobleCurveName === 'p256') {
          curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
        } else if (publicKey.nobleCurveName === 'p384') {
          curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
        }
        if (curveOrder) {
          const half = curveOrder >> 1n;
          const sVal = bytesToBigIntBE(sBytes);
          if (sVal > half) {
            const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
            const sigNorm = new Uint8Array(signatureBytes.length);
            sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
            if (window.DEBUG_VERBOSE) console.log('Attempting low-S normalized verification for COSE_Sign1');
            try {
              isValid = curveLib.verify(sigNorm, sigStructureBytes, publicKey.key);
            } catch {}
          }
        }
      } catch {}
    }
    
  console.log('Signature verification result:', isValid);
    return isValid;
    
  } catch (err) {
    console.error('❌ Signature verification error:', err);
    throw err;
  }
}

// ===== CERTIFICATE CHAIN VALIDATION =====

/**
 * Parse X.509 certificate and extract signature and TBS (To Be Signed) portion
 * This is a simplified ASN.1 parser for basic certificate validation
 */
function parseX509Certificate(certBytes) {
  try {
    // X.509 Certificate structure (simplified):
    // Certificate ::= SEQUENCE {
    //   tbsCertificate       TBSCertificate,
    //   signatureAlgorithm   AlgorithmIdentifier,
    //   signatureValue       BIT STRING
    // }
    
    let pos = 0;
    
    // Read SEQUENCE tag
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected SEQUENCE');
    }
    
    // Read length (can be short or long form)
    let certLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      certLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        certLength = (certLength << 8) | certBytes[pos++];
      }
    } else {
      certLength = certBytes[pos++];
    }
    
    const certStart = pos;
    
    // TBSCertificate is the first SEQUENCE
    const tbsStart = pos;  // Save position BEFORE reading TBS SEQUENCE tag
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected TBSCertificate SEQUENCE');
    }
    
    // Read TBS length
    let tbsLength;
    const tbsLengthStart = pos;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      tbsLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        tbsLength = (tbsLength << 8) | certBytes[pos++];
      }
    } else {
      tbsLength = certBytes[pos++];
    }
    
    // TBSCertificate includes the SEQUENCE tag and length
    const tbsEnd = pos + tbsLength;
    const tbsCertificate = certBytes.slice(tbsStart, tbsEnd);
    
    // Skip to signature
    pos = tbsEnd;
    
    // Skip signatureAlgorithm SEQUENCE
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected signatureAlgorithm SEQUENCE');
    }
    let sigAlgLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      sigAlgLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        sigAlgLength = (sigAlgLength << 8) | certBytes[pos++];
      }
    } else {
      sigAlgLength = certBytes[pos++];
    }
    pos += sigAlgLength;
    
    // Read signature BIT STRING
    if (certBytes[pos++] !== 0x03) {
      throw new Error('Invalid certificate: Expected signature BIT STRING');
    }
    let sigLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      sigLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        sigLength = (sigLength << 8) | certBytes[pos++];
      }
    } else {
      sigLength = certBytes[pos++];
    }
    
    // Skip the number of unused bits (first byte of BIT STRING)
    const unusedBits = certBytes[pos++];
    sigLength -= 1; // Subtract the unused bits byte
    
    const signature = certBytes.slice(pos, pos + sigLength);
    
    console.log('🔍 [X.509 Signature Extraction DEBUG]:');
    console.log('  Signature from BIT STRING (first 16 bytes):', Array.from(signature.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
    console.log('  Signature length:', signature.length);
    console.log('  First byte:', '0x' + signature[0].toString(16).padStart(2, '0'), signature[0] === 0x30 ? '(DER SEQUENCE ✓)' : '(NOT DER SEQUENCE!)');
    
    // For ECDSA, signature is DER-encoded, need to convert to raw r||s format
    const rawSignature = convertDERSignatureToRaw(signature);
    
    console.log('  After convertDERSignatureToRaw():');
    console.log('  Raw signature (first 16 bytes):', Array.from(rawSignature.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
    console.log('  Raw signature length:', rawSignature.length);
    
    return {
      tbsCertificate,
      signature: rawSignature,
      signatureDER: signature
    };
  } catch (e) {
    console.error('Failed to parse X.509 certificate:', e);
    return null;
  }
}

/**
 * Convert DER-encoded ECDSA signature to raw r||s format
 * Supports both P-256 (32-byte r/s) and P-384 (48-byte r/s)
 */
function convertDERSignatureToRaw(derSig) {
  try {
    // DER signature: SEQUENCE { r INTEGER, s INTEGER }
    let pos = 0;
    
    console.log(`🔍 [DER to Raw Conversion]`);
    console.log(`   Input DER (first 32 bytes): ${hex(derSig.slice(0, Math.min(32, derSig.length)))}`);
    
    if (derSig[pos++] !== 0x30) {
      throw new Error('Invalid DER signature: Expected SEQUENCE');
    }
    
    let seqLength;
    if (derSig[pos] & 0x80) {
      const numBytes = derSig[pos++] & 0x7f;
      seqLength = 0;
      for (let i = 0; i < numBytes; i++) {
        seqLength = (seqLength << 8) | derSig[pos++];
      }
    } else {
      seqLength = derSig[pos++];
    }
    
    console.log(`   SEQUENCE length: ${seqLength}`);
    
    // Read r
    if (derSig[pos++] !== 0x02) {
      throw new Error('Invalid DER signature: Expected INTEGER for r');
    }
    let rLength = derSig[pos++];
    console.log(`   r length: ${rLength}`);
    let r = derSig.slice(pos, pos + rLength);
    console.log(`   r raw (with potential padding): ${hex(r)}`);
    pos += rLength;
    
    // Remove leading zero if present (DER encoding adds it for positive numbers with high bit set)
    if (r[0] === 0x00 && r.length > 1) {
      r = r.slice(1);
      console.log(`   r after removing 0x00 padding: ${hex(r)}`);
    }
    
    // Read s
    if (derSig[pos++] !== 0x02) {
      throw new Error('Invalid DER signature: Expected INTEGER for s');
    }
    let sLength = derSig[pos++];
    console.log(`   s length: ${sLength}`);
    let s = derSig.slice(pos, pos + sLength);
    console.log(`   s raw (with potential padding): ${hex(s)}`);
    
    // Remove leading zero if present
    if (s[0] === 0x00 && s.length > 1) {
      s = s.slice(1);
      console.log(`   s after removing 0x00 padding: ${hex(s)}`);
    }
    
    // Determine curve based on component size
    // P-256: 32 bytes, P-384: 48 bytes
    const componentSize = Math.max(r.length, s.length) <= 32 ? 32 : 48;
    
    // Pad to correct size (32 bytes for P-256, 48 bytes for P-384)
    const rPadded = new Uint8Array(componentSize);
    const sPadded = new Uint8Array(componentSize);
    
    if (r.length <= componentSize) {
      rPadded.set(r, componentSize - r.length);
    } else {
      rPadded.set(r.slice(r.length - componentSize), 0);
    }
    
    if (s.length <= componentSize) {
      sPadded.set(s, componentSize - s.length);
    } else {
      sPadded.set(s.slice(s.length - componentSize), 0);
    }
    
    // Concatenate r || s (64 bytes for P-256, 96 bytes for P-384)
    const rawSig = new Uint8Array(componentSize * 2);
    rawSig.set(rPadded, 0);
    rawSig.set(sPadded, componentSize);
    
    return rawSig;
  } catch (e) {
    console.error('Failed to convert DER signature:', e);
    return derSig; // Return as-is if conversion fails
  }
}

/**
 * Extract Authority Key Identifier (AKI) from X.509 certificate
 * AKI is in extensions and identifies the public key of the CA that signed this cert
 * OID: 2.5.29.15 (0x55 0x1d 0x23)
 * 
 * @param {Uint8Array} certBytes - The certificate bytes
 * @returns {string|null} Hex string of the key identifier, or null if not found
 */
function extractAuthorityKeyIdentifier(certBytes) {
  try {
    // Extensions are in TBSCertificate at the end
    // Structure: TBSCertificate SEQUENCE {
    //   version, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo,
    //   [3] EXPLICIT Extensions OPTIONAL
    // }
    
    const hex = Array.from(certBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Look for Authority Key Identifier OID: 55 1d 23
    // Typically in format: SEQUENCE { OID, OCTET STRING { [0] keyIdentifier } }
    const akiOidPattern = '551d23';
    const akiIndex = hex.indexOf(akiOidPattern);
    
    if (akiIndex === -1) {
      return null;
    }
    
    // After OID, there's usually an OCTET STRING (04), then inside that another [0] tag (80)
    // Extract the key identifier which is typically 20 bytes (40 hex chars)
    const afterOid = hex.substring(akiIndex + akiOidPattern.length);
    
    // Look for context tag [0] (0x80) followed by length 14 (0x14 = 20 bytes)
    const keyIdMatch = afterOid.match(/8014([0-9a-f]{40})/);
    
    if (keyIdMatch) {
      return keyIdMatch[1];
    }
    
    return null;
  } catch (e) {
    console.error('Failed to extract AKI:', e);
    return null;
  }
}

/**
 * Extract Subject Key Identifier (SKI) from X.509 certificate
 * SKI identifies the public key in this certificate
 * OID: 2.5.29.14 (0x55 0x1d 0x0e)
 * 
 * @param {Uint8Array} certBytes - The certificate bytes
 * @returns {string|null} Hex string of the key identifier, or null if not found
 */
function extractSubjectKeyIdentifier(certBytes) {
  try {
    const hex = Array.from(certBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Look for Subject Key Identifier OID: 55 1d 0e
    const skiOidPattern = '551d0e';
    const skiIndex = hex.indexOf(skiOidPattern);
    
    if (skiIndex === -1) {
      return null;
    }
    
    // After OID, there's an OCTET STRING (04) containing another OCTET STRING (04) with the key ID
    // Format: 04 <length> 04 14 <20 bytes>
    const afterOid = hex.substring(skiIndex + skiOidPattern.length);
    
    // Look for OCTET STRING tag (04) followed by length 14 (20 bytes)
    const keyIdMatch = afterOid.match(/0414([0-9a-f]{40})/);
    
    if (keyIdMatch) {
      return keyIdMatch[1];
    }
    
    return null;
  } catch (e) {
    console.error('Failed to extract SKI:', e);
    return null;
  }
}

/**
 * Validate that the mDoc issuer certificate is signed by one of our IACA root certificates
 * This establishes the trust chain: mDoc data → Issuer Certificate → IACA Root
 * Uses Authority Key Identifier (AKI) to match the correct IACA certificate
 * 
 * @param {Uint8Array} issuerCertBytes - The issuer certificate from the mDoc's COSE signature header
 * @returns {Object} Validation result with { valid, matchedIACA, chain, errors }
 */
async function validateCertificateChain(issuerCertBytes) {
  const result = {
    valid: false,
    matchedIACA: null,
    chain: [],
    errors: []
  };
  const DEBUG_VERBOSE = (typeof window !== 'undefined' && window.DEBUG_VERBOSE === true);
  
  try {
    console.log('=== VALIDATING ISSUER CERTIFICATE AGAINST IACA ROOTS ===');
    
    // Get active IACAs
    const activeIACAs = getActiveIACAs();
    
    if (activeIACAs.length === 0) {
      result.errors.push('No active IACA certificates available for validation');
      return result;
    }
    
    console.log(`Testing issuer certificate against ${activeIACAs.length} active IACA(s)`);
    
    // Parse the issuer certificate to extract signature and TBS
  if (DEBUG_VERBOSE) console.log('Parsing issuer certificate...');
    const parsedCert = parseX509Certificate(issuerCertBytes);
    
    if (!parsedCert) {
      result.errors.push('Failed to parse issuer certificate (invalid X.509 format)');
      return result;
    }
    
    console.log('✓ Parsed issuer certificate');
  if (DEBUG_VERBOSE) {
      console.log('  TBS length:', parsedCert.tbsCertificate.length, 'bytes');
      console.log('  Signature length:', parsedCert.signature.length, 'bytes');
    }
    
    // Parse Certificate.signatureAlgorithm OID to select the correct hash (e.g., SHA-384)
    function parseCertSignatureAlgorithmOID(certBytes) {
      try {
        let pos = 0;
        if (certBytes[pos++] !== 0x30) return null; // Certificate SEQUENCE
        // Certificate length
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          for (let i = 0; i < n; i++) pos++;
        } else {
          pos++; // short form length
        }
        // TBSCertificate SEQUENCE
        if (certBytes[pos++] !== 0x30) return null;
        // TBS length
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          let tbsLen = 0; for (let i = 0; i < n; i++) tbsLen = (tbsLen << 8) | certBytes[pos++];
          pos += tbsLen;
        } else {
          const tbsLen = certBytes[pos++];
          pos += tbsLen;
        }
        // signatureAlgorithm SEQUENCE
        if (certBytes[pos++] !== 0x30) return null;
        // sigAlg length
        let sigAlgLen = 0;
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          for (let i = 0; i < n; i++) sigAlgLen = (sigAlgLen << 8) | certBytes[pos++];
        } else {
          sigAlgLen = certBytes[pos++];
        }
        const sigAlgEnd = pos + sigAlgLen;
        // Inside AlgorithmIdentifier: OID (06 len value) [parameters may be absent]
        if (certBytes[pos++] !== 0x06) return null;
        let oidLen = certBytes[pos++];
        const oidBytes = certBytes.slice(pos, pos + oidLen);
        // Convert OID bytes to dot string for logging
        function decodeOID(bytes) {
          if (!bytes || bytes.length === 0) return '';
          const out = [];
          const first = bytes[0];
          out.push(Math.floor(first / 40));
          out.push(first % 40);
          let value = 0;
          for (let i = 1; i < bytes.length; i++) {
            const b = bytes[i];
            value = (value << 7) | (b & 0x7f);
            if ((b & 0x80) === 0) { out.push(value); value = 0; }
          }
          return out.join('.');
        }
        const oidStr = decodeOID(oidBytes);
        return { oidStr, oidBytes: new Uint8Array(oidBytes) };
      } catch (e) {
        console.warn('Failed to parse signatureAlgorithm OID:', e.message);
        return null;
      }
    }
    const sigAlg = parseCertSignatureAlgorithmOID(issuerCertBytes);
    if (sigAlg) {
      console.log(`  Signature Algorithm: ${sigAlg.oidStr}`);
  if (DEBUG_VERBOSE) console.log(`  OID hex: ${hex(sigAlg.oidBytes)}`);
    } else {
      console.log('  Signature Algorithm OID: unavailable');
    }
    
    // Extract Authority Key Identifier (AKI) from DS certificate
    const aki = extractAuthorityKeyIdentifier(issuerCertBytes);
    console.log('  Authority Key Identifier (AKI):', aki || 'not found');
    
    // Choose hash from OID (don’t guess from signature size)
    // 1.2.840.10045.4.3.1 = ecdsa-with-SHA224
    // 1.2.840.10045.4.3.2 = ecdsa-with-SHA256
    // 1.2.840.10045.4.3.3 = ecdsa-with-SHA384
    // 1.2.840.10045.4.3.4 = ecdsa-with-SHA512
    const certSigLength = parsedCert.signature.length;
    const hashFromOID = sigAlg?.oidStr === '1.2.840.10045.4.3.1' ? 'SHA-224'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.2' ? 'SHA-256'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.3' ? 'SHA-384'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.4' ? 'SHA-512'
      : 'SHA-256';
    const algName = hashFromOID.replace('SHA-', 'ES');
  console.log(`  Using hash: ${hashFromOID}`);
  if (DEBUG_VERBOSE) console.log(`  Certificate signature length: ${certSigLength} bytes`);
    
    // Map signature length to expected curves
    const expectedCurves = certSigLength === 96 
      ? ['p384', 'brainpoolP384r1']  // 96-byte signature = P-384 or Brainpool P-384
      : ['p256', 'brainpoolP256r1'];  // 64-byte signature = P-256 or Brainpool P-256
    
    console.log(`  Expected IACA curves: ${expectedCurves.join(', ')}`);

    // (UI cert debug removed) – keep console logs only
    
    // If AKI is available, use it to find the matching IACA by SKI
    let matchingIACAs = activeIACAs;
    
    if (aki) {
      console.log(`🔍 Searching for IACA with matching SKI...`);
      const iacasWithSKI = [];
      
      for (const iaca of activeIACAs) {
        try {
          // Decode PEM to bytes
          const b64 = iaca.pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                             .replace(/-----END CERTIFICATE-----/, '')
                             .replace(/\s+/g, '');
          const binaryString = atob(b64);
          const iacaBytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            iacaBytes[i] = binaryString.charCodeAt(i);
          }
          
          const ski = extractSubjectKeyIdentifier(iacaBytes);
          
          if (ski) {
            console.log(`  ${iaca.name}: SKI = ${ski}`);
            if (ski.toLowerCase() === aki.toLowerCase()) {
              console.log(`  ✅ MATCH! This IACA signed the DS certificate`);
              iacasWithSKI.push(iaca);
            }
          } else {
            console.log(`  ${iaca.name}: No SKI found`);
          }
        } catch (e) {
          console.warn(`  ${iaca.name}: Error extracting SKI:`, e.message);
        }
      }
      
      if (iacasWithSKI.length > 0) {
        matchingIACAs = iacasWithSKI;
        console.log(`✓ Found ${matchingIACAs.length} IACA(s) with matching SKI`);
      } else {
        console.warn('⚠️ No IACA found with matching SKI, will try all IACAs');
      }
    }
    
    // Test the matching IACA(s)
    for (const iaca of matchingIACAs) {
      console.log(`Testing IACA: ${iaca.name}${matchingIACAs.length === 1 ? ' (matched by AKI/SKI)' : ''}`);
      
      try {
        // Decode IACA PEM to bytes for self-verification test
        const iacaB64 = iaca.pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                                 .replace(/-----END CERTIFICATE-----/, '')
                                 .replace(/\s+/g, '');
        const iacaBinaryString = atob(iacaB64);
        const iacaCertBytes = new Uint8Array(iacaBinaryString.length);
        for (let i = 0; i < iacaBinaryString.length; i++) {
          iacaCertBytes[i] = iacaBinaryString.charCodeAt(i);
        }
        
        // Extract IACA public key from PEM
        const iacaPublicKey = await pemToCryptoKey(iaca.pem);
        
        if (!iacaPublicKey) {
          console.log(`  ✗ Failed to import IACA public key (missing or invalid certificate)`);
          result.errors.push(`${iaca.name}: IACA certificate missing or invalid`);
          continue;
        }
        
        console.log(`  ✓ Imported IACA public key (curve: ${iacaPublicKey.nobleCurveName})`);
        // (UI cert debug removed)
        
        // Use @noble/curves for all verification
        if (!iacaPublicKey || iacaPublicKey.type !== 'noble') {
          console.log('  ✗ Invalid IACA public key format');
          result.errors.push(`${iaca.name}: Invalid key format`);
          continue;
        }
        
        // Check if IACA curve matches certificate signature length
        if (!expectedCurves.includes(iacaPublicKey.nobleCurveName)) {
          console.log(`  ⊘ Skipping: IACA curve ${iacaPublicKey.nobleCurveName} incompatible with ${algName} signature (${certSigLength} bytes)`);
          continue; // Skip incompatible curves without logging as error
        }
        
        if (!window.nobleCurves) {
          console.log('  ✗ @noble/curves library not loaded');
          result.errors.push(`${iaca.name}: Crypto library not available`);
          continue;
        }
        
        const curveLib = window.nobleCurves[iacaPublicKey.nobleCurveName];
        if (!curveLib) {
          console.log(`  ✗ Curve ${iacaPublicKey.nobleCurveName} not available`);
          result.errors.push(`${iaca.name}: Curve ${iacaPublicKey.nobleCurveName} not supported`);
          continue;
        }
        
  if (DEBUG_VERBOSE) console.log(`  Using @noble/curves (${iacaPublicKey.nobleCurveName}) for certificate verification`);
        
        // CRITICAL: X.509 certificates contain ECDSA signatures over the HASH of the TBS certificate
        // Noble-curves verify() expects a MESSAGE (which it will hash internally)
        // But X.509 already has the hash, so we need to convert it to look like the "message"
        // that would produce that hash when hashed by noble-curves
        
        // Actually, the proper way is to NOT hash the TBS certificate ourselves
        // Instead, pass the RAW TBS bytes to verify() and let noble-curves hash it
        // This is different from COSE_Sign1 because:
        // - COSE_Sign1: Signs the raw Sig_structure → pass raw bytes → noble hashes → works ✓
        // - X.509: Signs the raw TBS → pass raw bytes → noble hashes → should work ✓
        
  if (DEBUG_VERBOSE) {
          console.log(`  TBS certificate length: ${parsedCert.tbsCertificate.length} bytes`);
          console.log(`  TBS hex (first 64 bytes):`, hex(parsedCert.tbsCertificate.slice(0, 64)));
          console.log(`  TBS hex (last 32 bytes):`, hex(parsedCert.tbsCertificate.slice(-32)));
        }
        
        // DIAGNOSTIC: Verify TBS extraction is correct
  if (DEBUG_VERBOSE) console.log(`  🔍 Diagnostic: Verifying TBS structure...`);
  if (DEBUG_VERBOSE) console.log(`     First byte: 0x${parsedCert.tbsCertificate[0].toString(16)} (should be 0x30 = SEQUENCE)`);
  if (DEBUG_VERBOSE) console.log(`     Second byte: 0x${parsedCert.tbsCertificate[1].toString(16)} (length indicator)`);
        if (parsedCert.tbsCertificate[1] === 0x82) {
          const tbsLengthFromTag = (parsedCert.tbsCertificate[2] << 8) | parsedCert.tbsCertificate[3];
          if (DEBUG_VERBOSE) console.log(`     TBS length from tag: ${tbsLengthFromTag} (should be ${parsedCert.tbsCertificate.length - 4})`);
          if (tbsLengthFromTag + 4 === parsedCert.tbsCertificate.length) {
            if (DEBUG_VERBOSE) console.log(`     ✓ TBS length is correct`);
          } else {
            console.log(`     ✗ TBS length mismatch! Expected ${tbsLengthFromTag + 4}, got ${parsedCert.tbsCertificate.length}`);
          }
        }
        
  if (DEBUG_VERBOSE) {
          console.log(`  Certificate signature (raw r||s):`, hex(parsedCert.signature));
          console.log(`  Certificate signature length: ${parsedCert.signature.length} bytes`);
          console.log(`  IACA public key (with 0x04 prefix):`, hex(iacaPublicKey.key));
          console.log(`  IACA public key length: ${iacaPublicKey.key.length} bytes`);
          console.log(`  IACA X coordinate:`, hex(iacaPublicKey.key.slice(1, 33)));
          console.log(`  IACA Y coordinate:`, hex(iacaPublicKey.key.slice(33, 65)));
        }
        console.log(`  Attempting verification`);
        
        // Debug: Compute chosen hash manually
        let preHash = null;
        try {
          const h = await crypto.subtle.digest(hashFromOID, parsedCert.tbsCertificate);
          preHash = new Uint8Array(h);
          if (DEBUG_VERBOSE) console.log(`  📊 ${hashFromOID}(TBS) computed`);
        } catch (e) {
          console.log(`  ⚠️ Unable to compute ${hashFromOID} digest: ${e.message}`);
        }
        
        // Verify signature using noble-curves
        // Pass the RAW TBS certificate bytes (not pre-hashed)
  let isValid = false;
  let lowSUsed = false;
        try {
          if (DEBUG_VERBOSE) {
            console.log(`  🔬 Calling ${iacaPublicKey.nobleCurveName}.verify()...`);
            console.log(`     - signature length: ${parsedCert.signature.length}`);
            console.log(`     - message length: ${parsedCert.tbsCertificate.length}`);
            console.log(`     - publicKey length: ${iacaPublicKey.key.length}`);
          }
          
          // DIAGNOSTIC: Verify the public key looks structurally correct
          if (DEBUG_VERBOSE) console.log(`  🔍 Diagnostic: Verifying IACA public key is valid...`);
          try {
            if (curveLib.ProjectivePoint && typeof curveLib.ProjectivePoint.fromHex === 'function') {
              const _ = curveLib.ProjectivePoint.fromHex(iacaPublicKey.key);
              if (DEBUG_VERBOSE) console.log(`     ✓ Public key is a valid point on ${iacaPublicKey.nobleCurveName}`);
            } else {
              if (DEBUG_VERBOSE) console.log(`     (Skipping ProjectivePoint check: API not available)`);
            }
          } catch (pointErr) {
            console.log(`     ✗ Public key is NOT a valid point: ${pointErr.message}`);
          }
          
          // DIAGNOSTIC: Let's check the signature format
          if (DEBUG_VERBOSE) {
            console.log(`  🔍 Diagnostic: Checking signature format...`);
            const halfLen = parsedCert.signature.length/2;
            const r = parsedCert.signature.slice(0, halfLen);
            const s = parsedCert.signature.slice(halfLen);
            console.log(`     r first byte: 0x${r[0].toString(16)}`);
            console.log(`     s first byte: 0x${s[0].toString(16)}`);
            if (r[0] === 0x00) {
              console.log(`     ⚠️ WARNING: r has leading zero - might be padding issue`);
            }
            if (s[0] === 0x00) {
              console.log(`     ⚠️ WARNING: s has leading zero - might be padding issue`);
            }
          }
          
          
          // Streamlined verification order
          // 1) OID pre-hash
          if (preHash) {
            if (DEBUG_VERBOSE) console.log(`  🧪 Verify: signature vs ${hashFromOID}(TBS)`);
            isValid = curveLib.verify(parsedCert.signature, preHash, iacaPublicKey.key);
          }
          
          // 2) low-S normalization with pre-hash
          if (!isValid && preHash) {
            try {
              let curveOrder = curveLib?.CURVE?.n;
              if (!curveOrder) {
                if (iacaPublicKey.nobleCurveName === 'p256') {
                  curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                } else if (iacaPublicKey.nobleCurveName === 'p384') {
                  curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
                }
              }
              if (curveOrder) {
                const half = curveOrder >> 1n;
                const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
                const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
                const halfLen = parsedCert.signature.length / 2;
                const rBytes = parsedCert.signature.slice(0, halfLen);
                const sBytes = parsedCert.signature.slice(halfLen);
                const sVal = bytesToBigIntBE(sBytes);
                if (sVal > half) {
                  lowSUsed = true;
                  const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
                  const sigNorm = new Uint8Array(parsedCert.signature.length);
                  sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
                  if (DEBUG_VERBOSE) console.log(`  🧪 Verify: low-S signature vs ${hashFromOID}(TBS)`);
                  isValid = curveLib.verify(sigNorm, preHash, iacaPublicKey.key);
                }
              }
            } catch {}
          }

          // 3) RAW TBS (library hashes internally)
          if (!isValid) {
            try {
              if (DEBUG_VERBOSE) console.log(`  🧪 Verify: signature vs RAW_TBS`);
              isValid = curveLib.verify(parsedCert.signature, parsedCert.tbsCertificate, iacaPublicKey.key);
            } catch (e) {
              if (DEBUG_VERBOSE) console.log(`     verify threw: ${e.message}`);
            }
          }

          // 4) RAW TBS with low-S
          if (!isValid) {
            try {
              let curveOrder = curveLib?.CURVE?.n;
              if (!curveOrder) {
                if (iacaPublicKey.nobleCurveName === 'p256') {
                  curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                } else if (iacaPublicKey.nobleCurveName === 'p384') {
                  curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
                }
              }
              if (curveOrder) {
                const half = curveOrder >> 1n;
                const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
                const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
                const halfLen = parsedCert.signature.length / 2;
                const rBytes = parsedCert.signature.slice(0, halfLen);
                const sBytes = parsedCert.signature.slice(halfLen);
                const sVal = bytesToBigIntBE(sBytes);
                if (sVal > half) {
                  lowSUsed = true;
                  const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
                  const sigNorm = new Uint8Array(parsedCert.signature.length);
                  sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
                  if (DEBUG_VERBOSE) console.log(`  🧪 Verify: low-S signature vs RAW_TBS`);
                  isValid = curveLib.verify(sigNorm, parsedCert.tbsCertificate, iacaPublicKey.key);
                }
              }
            } catch {}
          }

          // Deep diagnostics behind verbose flag
          if (!isValid && DEBUG_VERBOSE) {
            try {
              console.log(`  🧪 Attempt E: verify(signature_DER, RAW_TBS, publicKey)`);
              const res = curveLib.verify(
                parsedCert.signatureDER,
                parsedCert.tbsCertificate,
                iacaPublicKey.key
              );
              console.log(`     Result: ${res}`);
              isValid = res;
            } catch (e) {
              console.log(`     Attempt E threw: ${e.message}`);
            }
          }

          if (!isValid && DEBUG_VERBOSE) {
            try {
              console.log(`  🧪 Attempt F: verify(signature_DER, ${hashFromOID}(TBS), publicKey)`);
              const preHashBuf = await crypto.subtle.digest(hashFromOID, parsedCert.tbsCertificate);
              const preHash = new Uint8Array(preHashBuf);
              const res = curveLib.verify(
                parsedCert.signatureDER,
                preHash,
                iacaPublicKey.key
              );
              console.log(`     Result: ${res}`);
              isValid = res;
            } catch (e) {
              console.log(`     Attempt F threw: ${e.message}`);
            }
          }

          if (!isValid && DEBUG_VERBOSE && window.crypto?.subtle) {
            try {
              console.log(`  🧪 Attempt G: WebCrypto.verify(ECDSA, ${hashFromOID})`);
              const namedCurve = iacaPublicKey.nobleCurveName === 'p256' ? 'P-256'
                : iacaPublicKey.nobleCurveName === 'p384' ? 'P-384'
                : null;
              if (namedCurve) {
                const wcKey = await crypto.subtle.importKey(
                  'raw',
                  iacaPublicKey.key,
                  { name: 'ECDSA', namedCurve },
                  false,
                  ['verify']
                );
                const ok = await crypto.subtle.verify(
                  { name: 'ECDSA', hash: { name: hashFromOID } },
                  wcKey,
                  parsedCert.signatureDER,
                  parsedCert.tbsCertificate
                );
                console.log(`     WebCrypto verify result: ${ok}`);
                isValid = ok;
              } else {
                console.log(`     (Skipping Attempt G: unsupported curve ${iacaPublicKey.nobleCurveName})`);
              }
            } catch (e) {
              console.log(`     Attempt G threw: ${e.message}`);
            }
          }
          
          // If still failing, optionally do DS/IACA sanity checks (verbose only)
          if (!isValid && DEBUG_VERBOSE) {
            console.log(`  🧪 Attempt 3: Sanity check - re-verify DS certificate COSE_Sign1`);
            console.log(`     (This should succeed since it worked earlier)`);
            
            // We know the DS certificate public key verified successfully
            // Let's extract it properly (skip the 04 prefix at offset 382)
            console.log(`     DS cert byte at 382: 0x${issuerCertBytes[382].toString(16)} (should be 0x04)`);
            console.log(`     DS cert public key X: ${hex(issuerCertBytes.slice(383, 383+32))}`);
            console.log(`     DS cert public key Y: ${hex(issuerCertBytes.slice(383+32, 383+64))}`);
            
            // Compare with what we extracted earlier during COSE_Sign1 verification
            console.log(`     Previously verified: COSE_Sign1 with DS cert public key = WORKS ✓`);
            console.log(`     Now failing: X.509 cert with IACA public key = FAILS ✗`);
            console.log(`     But wait - let's check if the issue is with IACA cert or DS cert...`);
            
            // Ultimate test: Verify the IACA certificate itself (should be self-signed)
            console.log(`  🧪 Attempt 4: Verify IACA is self-signed (sanity check)`);
            try {
              // Parse the IACA certificate
              const iacaParsed = parseX509Certificate(iacaCertBytes);
              if (iacaParsed) {
                console.log(`     IACA TBS length: ${iacaParsed.tbsCertificate.length}`);
                console.log(`     IACA signature length: ${iacaParsed.signature.length}`);
                
                // Verify IACA cert with its own public key (self-signed)
                const iacaSelfVerify = curveLib.verify(
                  iacaParsed.signature,
                  iacaParsed.tbsCertificate,
                  iacaPublicKey.key
                );
                console.log(`     IACA self-signed verification: ${iacaSelfVerify}`);
                
                if (iacaSelfVerify) {
                  console.log(`     ✓ IACA is properly self-signed!`);
                  console.log(`     This means the IACA public key is correct.`);
                  console.log(`     Therefore, the DS certificate signature or TBS must be wrong.`);
                } else {
                  console.log(`     ✗ IACA self-signed verification failed!`);
                  console.log(`     This could mean:`);
                  console.log(`       1. IACA public key extraction is wrong`);
                  console.log(`       2. Our signature/TBS extraction is fundamentally broken`);
                  console.log(`       3. noble-curves verification has an issue`);
                }
              }
            } catch (iacaErr) {
              console.log(`     Error verifying IACA: ${iacaErr.message}`);
            }
          }
          
          console.log(`  ✅ Certificate verify result: ${isValid}`);
          // (UI cert debug removed)
        } catch (verifyErr) {
          console.log(`  ✗ verify() threw error: ${verifyErr.message}`);
          console.error(verifyErr);
          isValid = false;
        }
        
        if (isValid) {
          console.log(`  ✅ Issuer certificate is signed by this IACA!`);
          
          result.valid = true;
          result.matchedIACA = {
            name: iaca.name,
            issuer: iaca.issuer,
            test: iaca.test || false  // Include test flag
          };
          result.chain = [
            'mDoc Issuer Certificate',
            `↓ signed by`,
            `IACA Root: ${iaca.name}${iaca.test ? ' (TEST)' : ''}`
          ];
          // (UI cert debug removed)
          
          console.log(`✅ Issuer certificate validated with IACA: ${iaca.name}${iaca.test ? ' (TEST)' : ''}`);
          return result;
        } else {
          console.log(`  ✗ Signature does not match this IACA`);
        }
        
      } catch (e) {
        console.log(`  ✗ Verification failed with this IACA:`, e.message);
        result.errors.push(`${iaca.name}: ${e.message}`);
      }
    }
    
    // No IACA matched
    if (!result.valid) {
      result.errors.push('Issuer certificate is not signed by any active IACA root certificate');
    }
    
  } catch (err) {
    console.error('Issuer certificate validation error:', err);
    result.errors.push(`Validation error: ${err.message}`);
  }
  
  return result;
}

/**
 * Enhanced signature verification with issuer certificate validation
 * Verifies the COSE signature and validates that the issuer certificate is signed by an IACA
 */
async function verifyCOSESign1SignatureWithChain(coseSign1) {
  const result = {
    signatureValid: false,
    chainValid: false,
    chainInfo: null,
    errors: []
  };
  
  try {
    // Step 1: Extract issuer certificate from unprotected header (COSE header parameter 33)
    console.log('Step 1: Extracting issuer certificate from x5chain...');
    
    const unprotectedHeader = coseSign1[1] || {};
    console.log('Unprotected header:', unprotectedHeader);
    console.log('Unprotected header type:', Object.prototype.toString.call(unprotectedHeader));
    
    // Handle both Map and plain object
    // COSE header parameter 33 (x5chain) contains the issuer certificate
    let issuerCert;
    if (unprotectedHeader instanceof Map) {
      console.log('Unprotected header is a Map');
      issuerCert = unprotectedHeader.get(33);
      console.log('Issuer cert from Map.get(33):', issuerCert);
    } else {
      console.log('Unprotected header is a plain object');
      issuerCert = unprotectedHeader[33];
      console.log('Issuer cert from object[33]:', issuerCert);
    }
    
    if (!issuerCert) {
      result.errors.push('No issuer certificate (x5chain) found in signature header');
      console.warn('⚠️ No x5chain (issuer certificate) found in unprotected header');
      console.log('Available header keys:', unprotectedHeader instanceof Map ? 
        Array.from(unprotectedHeader.keys()) : Object.keys(unprotectedHeader));
      return result;
    }
    
    // Convert to Uint8Array if needed
    let issuerCertBytes;
    if (issuerCert instanceof Uint8Array) {
      issuerCertBytes = issuerCert;
    } else if (ArrayBuffer.isView(issuerCert)) {
      issuerCertBytes = new Uint8Array(issuerCert.buffer, issuerCert.byteOffset, issuerCert.byteLength);
    } else if (issuerCert instanceof ArrayBuffer) {
      issuerCertBytes = new Uint8Array(issuerCert);
    } else {
      result.errors.push('Issuer certificate format not recognized');
      console.error('Issuer certificate is not a Uint8Array or ArrayBuffer:', typeof issuerCert);
      return result;
    }
    
    console.log('Issuer certificate size:', issuerCertBytes.length, 'bytes');
    
    // Step 2: Extract public key from issuer certificate and verify signature
    console.log('Step 2: Extracting public key and verifying signature...');
    try {
      const publicKey = await extractPublicKeyFromCert(issuerCertBytes);
      result.signatureValid = await verifyCoseSign1(coseSign1, publicKey);
      
      if (!result.signatureValid) {
        result.errors.push('COSE signature verification failed');
      }
    } catch (sigErr) {
      console.error('Signature verification error:', sigErr);
      result.errors.push(`Signature verification error: ${sigErr.message}`);
      result.signatureValid = false;
    }
    
    // Step 3: Validate that issuer certificate is signed by an IACA root
    console.log('Step 3: Validating issuer certificate against IACA roots...');
    result.chainInfo = await validateCertificateChain(issuerCertBytes);
    result.chainValid = result.chainInfo.valid;
    
    if (!result.chainValid) {
      result.errors.push(...result.chainInfo.errors);
    }
    
  } catch (err) {
    console.error('Signature verification with chain error:', err);
    result.errors.push(`Verification error: ${err.message}`);
  }
  
  return result;
}

// ===== IACA CERTIFICATE MANAGEMENT =====

const DEFAULT_IACA_CERTIFICATES = [
  {
    name: 'Autorité de Certification France Identité IACA',
    pem:`-----BEGIN CERTIFICATE-----
MIIDHTCCAsSgAwIBAgISESEhmoph1P1OOjDCLJAgGdBbMAoGCCqGSM49BAMCMIGf
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjE5MDcGA1UE
AwwwQXV0b3JpdMOpIGRlIENlcnRpZmljYXRpb24gRnJhbmNlIElkZW50aXTDqSBJ
QUNBMQowCAYDVQQFEwExMB4XDTI1MTAxNzAwMDAwMFoXDTM0MTAxNzAwMDAwMFow
gZ8xCzAJBgNVBAYTAkZSMTAwLgYDVQQKDCdBZ2VuY2UgTmF0aW9uYWxlIGRlcyBU
aXRyZXMgU8OpY3VyaXPDqXMxFzAVBgNVBAsMDjAwMDIgMTMwMDAzMjYyMTkwNwYD
VQQDDDBBdXRvcml0w6kgZGUgQ2VydGlmaWNhdGlvbiBGcmFuY2UgSWRlbnRpdMOp
IElBQ0ExCjAIBgNVBAUTATEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQqfRW/
7OTJS4K0IPMa/c8UicIUq62jTccQtGnHAYk6UnvXyRO3PC4/2pdq5QjhwIKwJVqC
FOr4fbGboMKLX+L/o4HdMIHaMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAG
AQH/AgEAMCwGA1UdEgQlMCOBIWZyYW5jZS1pZGVudGl0ZUBpbnRlcmlldXIuZ291
di5mcjBGBgNVHR8EPzA9MDugOaA3hjVodHRwOi8vY3JsLmFudHMuZ291di5mci9h
Y19mcmFuY2VfaWRlbnRpdGVfaWFjYV8xLmNybDAdBgNVHQ4EFgQUAQ1+Rjq9mU0k
AyKKyTwFdgjmwA4wHwYDVR0jBBgwFoAUAQ1+Rjq9mU0kAyKKyTwFdgjmwA4wCgYI
KoZIzj0EAwIDRwAwRAIgSNKCT8z4zaZLfdOd/rHevKYDbvjqylK723wjd4g4s0EC
IDnoWVWyJHwlO31z3QmK7QapM00sOCJnsTIvEGi1Fz/I
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorité de Certification France Identité IACA, C=FR',
    test: false,
    active: true
  },
  {
    name: 'Autorité de Certification France Attestations IACA',
    pem:`-----BEGIN CERTIFICATE-----
MIIDLTCCAtKgAwIBAgISESEFJUbpBJovlg7lg3Eb5YTCMAoGCCqGSM49BAMCMIGi
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjE8MDoGA1UE
AwwzQXV0b3JpdMOpIGRlIENlcnRpZmljYXRpb24gRnJhbmNlIEF0dGVzdGF0aW9u
cyBJQUNBMQowCAYDVQQFEwExMB4XDTI1MTAxNzAwMDAwMFoXDTM0MTAxNzAwMDAw
MFowgaIxCzAJBgNVBAYTAkZSMTAwLgYDVQQKDCdBZ2VuY2UgTmF0aW9uYWxlIGRl
cyBUaXRyZXMgU8OpY3VyaXPDqXMxFzAVBgNVBAsMDjAwMDIgMTMwMDAzMjYyMTww
OgYDVQQDDDNBdXRvcml0w6kgZGUgQ2VydGlmaWNhdGlvbiBGcmFuY2UgQXR0ZXN0
YXRpb25zIElBQ0ExCjAIBgNVBAUTATEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNC
AASa4ZI0w4Mn4FW6kYdKPUlYYgVbwFf1A6lBDnurRsoPJxM3+dVupbkGl9O+QnJ3
6wc8ngoXE3oH1hP11flDmWsIo4HlMIHiMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB
Af8ECDAGAQH/AgEAMDAGA1UdEgQpMCeBJWZyYW5jZS1hdHRlc3RhdGlvbnNAaW50
ZXJpZXVyLmdvdXYuZnIwSgYDVR0fBEMwQTA/oD2gO4Y5aHR0cDovL2NybC5hbnRz
LmdvdXYuZnIvYWNfZnJhbmNlX2F0dGVzdGF0aW9uc19pYWNhXzEuY3JsMB0GA1Ud
DgQWBBT/dscZoX+tou0+F2dDsFrTPfsMpzAfBgNVHSMEGDAWgBT/dscZoX+tou0+
F2dDsFrTPfsMpzAKBggqhkjOPQQDAgNJADBGAiEAmMD8Kpgnctmx12gCBYrj98kn
oKDSPlO5SucThy1EEqwCIQDsYM80Ere4Yw0fHNJQQHl6D1rAITDV3qFKP62Uq7xt
sQ==
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorité de Certification France Attestations IACA, C=FR',
    test: false,
    active: true
  },
  {
    name: 'France Attestations - Test IACA',
    pem: `-----BEGIN CERTIFICATE-----
MIIDUzCCAvmgAwIBAgISESHtNjf+2KAQ0ttWtR9EhAAPMAoGCCqGSM49BAMCMIHF
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjEmMCQGA1UE
CwwdUE9VUiBRVUFMSUZJQ0FUSU9OIFVOSVFVRU1FTlQxNzA1BgNVBAMMLkF1dG9y
aXTDqSBkZSBDZXJ0aWZpY2F0aW9uIEZyYW5jZSBBdHRlc3RhdGlvbnMxCjAIBgNV
BAUTATEwHhcNMjUwMTI5MDAwMDAwWhcNMzAwMTI5MDAwMDAwWjCBxTELMAkGA1UE
BhMCRlIxMDAuBgNVBAoMJ0FnZW5jZSBOYXRpb25hbGUgZGVzIFRpdHJlcyBTw6lj
dXJpc8OpczEXMBUGA1UECwwOMDAwMiAxMzAwMDMyNjIxJjAkBgNVBAsMHVBPVVIg
UVVBTElGSUNBVElPTiBVTklRVUVNRU5UMTcwNQYDVQQDDC5BdXRvcml0w6kgZGUg
Q2VydGlmaWNhdGlvbiBGcmFuY2UgQXR0ZXN0YXRpb25zMQowCAYDVQQFEwExMFkw
EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoCYCM9LYS8zUk8I1xL2B2G9voa4yFsko
qohrsEQkpNEeKb59J3VDHausTqFWCOfwEGUzi6yocLIbE+gfz59pnaOBxjCBwzAO
BgNVHQ8BAf8EBAMCAQYwMAYDVR0SBCkwJ4ElZnJhbmNlLWF0dGVzdGF0aW9uc0Bp
bnRlcmlldXIuZ291di5mcjASBgNVHRMBAf8ECDAGAQH/AgEAMEwGA1UdHwRFMEMw
QaA/oD2GO2h0dHA6Ly9jcmwucXVhbGlmLmFudHMuZ291di5mci9hY19mcmFuY2Vf
YXR0ZXN0YXRpb25zXzEuY3JsMB0GA1UdDgQWBBR3bIy6PB3fPAlYHOvqk7nftps4
sDAKBggqhkjOPQQDAgNIADBFAiBrI2HGG1SZNRfEoaIwk3bjAjLBcE9tcKPi1gu0
oah58AIhAL+KWRF8FwT4JBblyZdmuoVVXJ36LMmAUcs5YwJpMiQW
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorité de Certification France Attestations, C=FR',
    test: true,
    active: true
  },
  {
    name: 'IACA NL mDL',
    pem: `-----BEGIN CERTIFICATE-----
MIIChzCCAg6gAwIBAgIUNKLqlwyPhbMOSD0kBpBVr/8nR3wwCgYIKoZIzj0EAwMw
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDExFDASBgNV
BAMMC0lBQ0EgTkwgbURMMB4XDTIxMTIxNDEzMTMxMFoXDTI5MTIxNDEzMTMwOVow
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDExFDASBgNV
BAMMC0lBQ0EgTkwgbURMMHowFAYHKoZIzj0CAQYJKyQDAwIIAQELA2IABD0oIkWG
2SCr1imaAe1b41erTis67NlSA60xehE8IsYPVEzcn6FW5+gWrQ1p8+4ZizqdHFd3
v84WWSe7W19tjqUurnTFMKG5NxZ2KFxpDc1YZCmB128PgeyJ2KzC2aFZ16OByDCB
xTASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFNLoPEtlzS8edYK61ZVE
b0WqBUlAMEAGA1UdHwQ5MDcwNaAzoDGGL2h0dHA6Ly93d3ctZGllbnN0ZW4ucmR3
Lm5sL2NybC9JQUNBTkxtREwtMDEuY3JsMB0GA1UdDgQWBBTS6DxLZc0vHnWCutWV
RG9FqgVJQDAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0SBBYwFIYSaHR0cHM6Ly93d3cu
cmR3Lm5sMAoGCCqGSM49BAMDA2cAMGQCMCG8ctJf3PUfSB2LoYqgoy2iWe1Nqzjo
0FJxc9ePVPVeFfI2t2Mqe2mo50hJ9EKMqwIwBtek1Tpw/SRjLjI+L0PMBtiE9Tse
C6oqwQPIIuSJLgUWByKywFFlK+i8EqosLCVT
-----END CERTIFICATE-----`,
    issuer: 'C=NL, O=RDW, serialNumber=01, CN=IACA NL mDL',
    test: false,
    active: true
  },
  {
    name: 'IACA NL mVR',
    pem: `-----BEGIN CERTIFICATE-----
MIIChzCCAg6gAwIBAgIUApUuBv6PnHuN+DFrHMXDPCD1eSswCgYIKoZIzj0EAwMw
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDIxFDASBgNV
BAMMC0lBQ0EgTkwgbVZSMB4XDTIzMTAxMDExMzA1MFoXDTMxMTAxMDExMzA0OVow
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDIxFDASBgNV
BAMMC0lBQ0EgTkwgbVZSMHowFAYHKoZIzj0CAQYJKyQDAwIIAQELA2IABB9T038B
YLJ8EEA3WU23Y8uYShK9zvEB7zO6CcyvtpzDZLhefHc7qfibWATbI2Pa7EAtHAmb
z8HkLqgBNfFg2aDtyfr9fs892dA6yJ9zbVv2Pna7+77rriOjND5doNnhxaOByDCB
xTASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFEOPFj/6DqRZUGdQH2Ir
/0wtL/+qMEAGA1UdHwQ5MDcwNaAzoDGGL2h0dHA6Ly93d3ctZGllbnN0ZW4ucmR3
Lm5sL2NybC9JQUNBTkxtVlItMDEuY3JsMB0GA1UdDgQWBBRDjxY/+g6kWVBnUB9i
K/9MLS//qjAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0SBBYwFIYSaHR0cHM6Ly93d3cu
cmR3Lm5sMAoGCCqGSM49BAMDA2cAMGQCMEQf7RWdfWBY3SlgyW75xdZNuUmJPaDZ
/mji/fMCSePodYkY/tg0uLUw/p6dFLytgQIwE4zKx4iQNBFW4jAgHdvfvS9qh0h6
ryXFc+YMxyMOmThPKdcIKg1FMQZ6ZSaTOxEM
-----END CERTIFICATE-----`,
    issuer: 'C=NL, O=RDW, serialNumber=02, CN=IACA NL mVR',
    test: false,
    active: true
  }
];

// Storage key for localStorage
const IACA_STORAGE_KEY = 'mdoc_iaca_certificates';
const IACA_VERSION_KEY = 'mdoc_iaca_version';
// IACA version now uses APP_VERSION from above (synced with CACHE_VERSION in sw.js)

// Initialize IACA storage with defaults
function initializeIACAs() {
  const storedVersion = parseInt(localStorage.getItem(IACA_VERSION_KEY)) || 0;
  let stored = localStorage.getItem(IACA_STORAGE_KEY);
  
  // Check if we need to update default certificates
  // Uses APP_VERSION which is synced with service worker CACHE_VERSION
  if (storedVersion < APP_VERSION) {
    console.log(`Updating IACA certificates from version ${storedVersion} to ${APP_VERSION}`);
    
    let userAddedCerts = [];
    
    // If there's existing storage, preserve user-added certificates
    if (stored) {
      try {
        const existingIacas = JSON.parse(stored);
        // User-added certificates are those beyond the default count
        // We identify them by checking if they're not in DEFAULT_IACA_CERTIFICATES
        userAddedCerts = existingIacas.filter(iaca => {
          return !DEFAULT_IACA_CERTIFICATES.some(defaultCert => 
            defaultCert.pem === iaca.pem
          );
        });
        console.log(`Preserving ${userAddedCerts.length} user-added certificate(s)`);
      } catch (e) {
        console.error('Failed to parse stored IACAs during update:', e);
      }
    }
    
    // Merge: defaults first, then user-added certificates
    const updatedIacas = [...DEFAULT_IACA_CERTIFICATES, ...userAddedCerts];
    
    localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(updatedIacas));
    localStorage.setItem(IACA_VERSION_KEY, APP_VERSION.toString());
    
    console.log(`IACA certificates updated: ${DEFAULT_IACA_CERTIFICATES.length} default(s), ${userAddedCerts.length} user-added`);
    return updatedIacas;
  }
  
  // No update needed
  if (!stored) {
    // First time - store defaults
    localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(DEFAULT_IACA_CERTIFICATES));
    localStorage.setItem(IACA_VERSION_KEY, APP_VERSION.toString());
    return DEFAULT_IACA_CERTIFICATES;
  }
  
  try {
    const iacas = JSON.parse(stored);
    // Ensure all certificates have an 'active' property (migration support)
    iacas.forEach(iaca => {
      if (iaca.active === undefined) {
        iaca.active = true;
      }
    });
    return iacas;
  } catch (e) {
    console.error('Failed to parse stored IACAs, using defaults:', e);
    localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(DEFAULT_IACA_CERTIFICATES));
    localStorage.setItem(IACA_VERSION_KEY, APP_VERSION.toString());
    return DEFAULT_IACA_CERTIFICATES;
  }
}

// Get all IACAs
function getIACAs() {
  return initializeIACAs();
}

// Get only active IACAs
function getActiveIACAs() {
  return getIACAs().filter(iaca => iaca.active !== false);
}

// Add a new IACA certificate
function addIACA(pem, name = null, isTest = false) {
  // Parse certificate to extract info
  const certInfo = parsePEMCertificate(pem);
  if (!certInfo) {
    throw new Error('Invalid PEM certificate format');
  }
  
  const iacas = getIACAs();
  
  // Check for duplicates
  if (iacas.some(iaca => iaca.pem === pem)) {
    throw new Error('This certificate is already installed');
  }
  
  const newIACA = {
    name: name || certInfo.subject || 'Unknown Certificate',
    pem: pem.trim(),
    issuer: certInfo.subject || 'Unknown',
    addedAt: new Date().toISOString(),
    active: true,
    test: isTest  // Flag to indicate test/development certificate
  };
  
  iacas.push(newIACA);
  localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(iacas));
  
  return newIACA;
}

// Remove an IACA certificate by index
function removeIACA(index) {
  const iacas = getIACAs();
  if (index >= 0 && index < iacas.length) {
    const removed = iacas.splice(index, 1);
    localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(iacas));
    return removed[0];
  }
  return null;
}

// Toggle IACA active status
function toggleIACAStatus(index) {
  const iacas = getIACAs();
  if (index >= 0 && index < iacas.length) {
    iacas[index].active = !iacas[index].active;
    localStorage.setItem(IACA_STORAGE_KEY, JSON.stringify(iacas));
    return iacas[index];
  }
  return null;
}

// Parse PEM certificate to extract basic info
function parsePEMCertificate(pem) {
  try {
    // Extract base64 content
    const b64 = pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                   .replace(/-----END CERTIFICATE-----/, '')
                   .replace(/\s+/g, '');
    
    // Decode base64 to bytes
    const binaryString = atob(b64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Use proper X.509 parser to extract subject
    let subject = 'Unknown';
    let subjectDN = null;
    try {
      const certInfo = extractCertInfo(bytes);
      if (certInfo && certInfo.subjectCN) {
        subject = certInfo.subjectCN;
      }
      if (certInfo && certInfo.subjectDN) {
        subjectDN = certInfo.subjectDN;
      }
    } catch (e) {
      console.warn('Could not extract subject CN, trying fallback method');
      // Fallback to simple text search
      const certStr = new TextDecoder('utf-8', { fatal: false }).decode(bytes);
      const cnMatch = certStr.match(/CN=([^,\n\r]+)/);
      if (cnMatch) {
        subject = cnMatch[1].trim();
      }
    }
    
    return {
      subject,
      subjectDN,
      bytes,
      pem
    };
  } catch (e) {
    console.error('Failed to parse PEM certificate:', e);
    return null;
  }
}

// Convert PEM to CryptoKey for verification
// Uses extractPublicKeyFromCert to parse the X.509 structure and extract the EC public key
async function pemToCryptoKey(pem) {
  try {
    const b64 = pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                   .replace(/-----END CERTIFICATE-----/, '')
                   .replace(/\s+/g, '');
    
    const binaryString = atob(b64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Use our existing X.509 parser to extract the public key
    // (Web Crypto API cannot import full X.509 certificates, only public keys)
    const key = await extractPublicKeyFromCert(bytes);
    
    if (!key) {
      console.error('Failed to extract public key from IACA certificate');
      return null;
    }
    
    return key;
  } catch (e) {
    if (e.name === 'DataError') {
      console.error('IACA certificate is missing, invalid, or has an unsupported key format:', e.message);
    } else {
      console.error('Failed to import certificate as CryptoKey:', e.message);
    }
    return null;
  }
}

// Update the IACA list display
async function updateIACAList() {
  const iacas = getIACAs();
  
  if (iacas.length === 0) {
    iacaListEl.innerHTML = '<div class="muted" style="font-style: italic;">No certificates installed</div>';
    return;
  }
  
  let html = '<div style="display: grid; gap: 0.75rem;">';
  
  // Process each IACA certificate with async operations
  for (let index = 0; index < iacas.length; index++) {
    const iaca = iacas[index];
    const isDefault = index < DEFAULT_IACA_CERTIFICATES.length;
    const isActive = iaca.active !== false;
    const isTest = iaca.test === true;
    const statusColor = isActive ? '#059669' : '#94a3b8';
    const statusText = isActive ? '● Active' : '○ Inactive';
    const bgOpacity = isActive ? '1' : '0.6';
    const testBadge = isTest ? '<div style="font-size: 0.8rem; color: #f59e0b; margin-top: 0.25rem; font-weight: 500;">⚠️ Test/Development Certificate</div>' : '';
    
    // Parse certificate for detailed info
    let certDetails = '';
    try {
      const certInfo = parsePEMCertificate(iaca.pem);
      if (certInfo) {
        // Decode the certificate bytes for more details
        const parsed = parseX509Certificate(certInfo.bytes);
        
        // Extract validity dates
        const validity = extractCertValidity(certInfo.bytes);
        
        // Compute SHA-256 fingerprint of the entire certificate
        const sha256Hash = await crypto.subtle.digest('SHA-256', certInfo.bytes);
        const hexThumbprint = Array.from(new Uint8Array(sha256Hash))
          .map(b => b.toString(16).padStart(2, '0'))
          .join(':')
          .toUpperCase();
        
        // Use full DN if available, otherwise fall back to CN
        const subjectDisplay = certInfo.subjectDN || iaca.issuer;

        // Determine crypto used (curve) by the IACA public key
        let cryptoLabel = null;
        try {
          const pubKey = await extractPublicKeyFromCert(certInfo.bytes, true);
          if (pubKey && pubKey.nobleCurveName) {
            const map = {
              p256: 'ECDSA P-256 (secp256r1)',
              p384: 'ECDSA P-384 (secp384r1)',
              p521: 'ECDSA P-521 (secp521r1)',
              brainpoolP256r1: 'ECDSA brainpoolP256r1',
              brainpoolP320r1: 'ECDSA brainpoolP320r1',
              brainpoolP384r1: 'ECDSA brainpoolP384r1',
              brainpoolP512r1: 'ECDSA brainpoolP512r1'
            };
            cryptoLabel = map[pubKey.nobleCurveName] || `ECDSA (${pubKey.nobleCurveName})`;
          } else {
            // Fallback: detect via OID only (works even when noble doesn't support the curve)
            const detected = detectCurveFromCertOID(certInfo.bytes);
            if (detected) {
              const map = {
                'P-256': 'ECDSA P-256 (secp256r1)',
                'P-384': 'ECDSA P-384 (secp384r1)',
                'P-521': 'ECDSA P-521 (secp521r1)',
                'brainpoolP256r1': 'ECDSA brainpoolP256r1',
                'brainpoolP320r1': 'ECDSA brainpoolP320r1',
                'brainpoolP384r1': 'ECDSA brainpoolP384r1',
                'brainpoolP512r1': 'ECDSA brainpoolP512r1'
              };
              cryptoLabel = map[detected] || `ECDSA (${detected})`;
            }
          }
        } catch {}
        const defaultBadge = isDefault ? '<div style="font-size: 0.8rem; color: #059669; margin: 0.25rem 0 0.5rem;">✓ Default certificate</div>' : '';
        
        certDetails = `
          <div id="iaca-details-${index}" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(148,163,184,0.25);">
            <div style="font-size: 0.85rem; color: #475569;">
              ${defaultBadge}
              <div style="margin-bottom: 0.5rem;">
                <strong>Subject:</strong>
                <div style="color: #1e293b; font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.8rem; margin-top: 0.25rem; word-break: break-all; line-height: 1.4;">${escapeHtml(subjectDisplay)}</div>
              </div>
              ${cryptoLabel ? `<div style="margin-bottom: 0.5rem;"><strong>Crypto:</strong> <span style="color: #1e293b;">${cryptoLabel}</span></div>` : ''}
              ${validity.notBefore ? `<div style="margin-bottom: 0.5rem;">
                <strong>Valid From:</strong> <span style="color: #1e293b;">${validity.notBefore.toLocaleString()}</span>
              </div>` : ''}
              ${validity.notAfter ? `<div style="margin-bottom: 0.5rem;">
                <strong>Valid Until:</strong> <span style="color: #1e293b;">${validity.notAfter.toLocaleString()}</span>
              </div>` : ''}
              <div style="margin-bottom: 0.5rem;">
                <strong>SHA-256 Fingerprint:</strong> 
                <div style="font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.75rem; color: #1e293b; margin-top: 0.25rem; word-break: break-all;">${hexThumbprint}</div>
              </div>
              <div style="margin-top: 0.75rem;">
                <button onclick="viewIACAPEM(${index})" style="padding: 0.35rem 0.65rem; font-size: 0.85rem; background: #0ea5e9;">
                  📄 View PEM
                </button>
                <button onclick="copyIACAPEM(${index})" style="padding: 0.35rem 0.65rem; font-size: 0.85rem; background: #059669;">
                  📋 Copy PEM
                </button>
              </div>
            </div>
          </div>
        `;
      }
    } catch (e) {
      console.error('Error parsing certificate details:', e);
    }
    
    html += `
      <div style="background: #f8fafc; border: 1px solid rgba(148,163,184,0.25); border-radius: 8px; padding: 0.75rem; opacity: ${bgOpacity};">
        <div style="display: flex; justify-content: space-between; align-items: start;">
          <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <div style="font-weight: 600; color: #0f172a;">${escapeHtml(iaca.name)}</div>
              <div style="font-size: 0.8rem; color: ${statusColor}; font-weight: 500;">${statusText}</div>
            </div>
            <div style="font-size: 0.85rem; color: #64748b; margin-top: 0.25rem;">${escapeHtml(iaca.issuer)}</div>
            ${testBadge}
          </div>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            ${certDetails ? `<button onclick="toggleIACADetails(${index})" style="padding: 0.35rem 0.65rem; font-size: 0.85rem; background: #64748b; display: inline-flex; align-items: center; gap: 0.35rem;">
              <span id="iaca-details-icon-${index}">▶</span> Details
            </button>` : ''}
            <button onclick="toggleIACACert(${index})" style="padding: 0.35rem 0.65rem; font-size: 0.85rem; background: ${isActive ? '#64748b' : '#059669'};">
              ${isActive ? 'Deactivate' : 'Activate'}
            </button>
            ${!isDefault ? `<button onclick="removeIACACert(${index})" style="padding: 0.35rem 0.65rem; font-size: 0.85rem; background: #dc2626;">Remove</button>` : ''}
          </div>
        </div>
        ${certDetails}
      </div>
    `;
  }
  html += '</div>';
  
  iacaListEl.innerHTML = html;
}

// Global function for toggle button (called from HTML)
window.toggleIACACert = function(index) {
  const toggled = toggleIACAStatus(index);
  if (toggled) {
    const status = toggled.active ? 'activated' : 'deactivated';
    log(`${toggled.active ? '✅' : '⏸️'} ${status.charAt(0).toUpperCase() + status.slice(1)} IACA: ${toggled.name}`);
    updateIACAList();
  }
};

// Global function for remove button (called from HTML)
window.removeIACACert = function(index) {
  if (confirm('Are you sure you want to remove this certificate?')) {
    const removed = removeIACA(index);
    if (removed) {
      log(`🗑️ Removed IACA: ${removed.name}`);
      updateIACAList();
    }
  }
};

// Global function for toggling IACA certificate details (called from HTML)
window.toggleIACADetails = function(index) {
  const detailsDiv = document.getElementById(`iaca-details-${index}`);
  const icon = document.getElementById(`iaca-details-icon-${index}`);
  
  if (!detailsDiv || !icon) return;
  
  if (detailsDiv.style.display === 'none') {
    detailsDiv.style.display = 'block';
    icon.textContent = '▼';
  } else {
    detailsDiv.style.display = 'none';
    icon.textContent = '▶';
  }
};

// Global function for viewing IACA PEM in a modal/alert (called from HTML)
window.viewIACAPEM = function(index) {
  const iacas = getIACAs();
  if (index >= 0 && index < iacas.length) {
    const iaca = iacas[index];
    // Create a modal-like display
    const modal = document.createElement('div');
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 2rem;';
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    
    const content = document.createElement('div');
    content.style.cssText = 'background: white; border-radius: 12px; padding: 1.5rem; max-width: 800px; max-height: 80vh; overflow: auto; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3);';
    content.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3 style="margin: 0; color: #0f172a;">${escapeHtml(iaca.name)}</h3>
        <button onclick="this.closest('div').parentElement.parentElement.remove()" style="background: #dc2626; padding: 0.5rem 1rem; border-radius: 6px; border: none; color: white; cursor: pointer;">Close</button>
      </div>
      <pre style="background: #f8fafc; padding: 1rem; border-radius: 8px; overflow-x: auto; font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem; color: #1e293b; white-space: pre-wrap; word-break: break-all;">${escapeHtml(iaca.pem)}</pre>
      <div style="margin-top: 1rem;">
        <button onclick="copyIACAPEM(${index}); this.textContent='✅ Copied!'; setTimeout(() => this.textContent='📋 Copy to Clipboard', 2000);" style="background: #059669; padding: 0.5rem 1rem; border-radius: 6px; border: none; color: white; cursor: pointer;">📋 Copy to Clipboard</button>
      </div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
  }
};

// Global function for copying IACA PEM to clipboard (called from HTML)
window.copyIACAPEM = async function(index) {
  const iacas = getIACAs();
  if (index >= 0 && index < iacas.length) {
    try {
      await navigator.clipboard.writeText(iacas[index].pem);
      log(`📋 Copied IACA PEM to clipboard: ${iacas[index].name}`);
    } catch (err) {
      console.error('Copy failed:', err);
      log('❌ Failed to copy PEM: ' + err.message);
    }
  }
};

// Global function for toggling MSO display (called from HTML)
window.toggleMSO = function(msoId) {
  const msoDiv = document.getElementById(msoId);
  const icon = document.getElementById(`${msoId}-icon`);
  
  if (!msoDiv || !icon) return;
  
  if (msoDiv.style.display === 'none') {
    msoDiv.style.display = 'block';
    icon.textContent = '▼';
  } else {
    msoDiv.style.display = 'none';
    icon.textContent = '▶';
  }
};

// Global function for copying MSO to clipboard (called from HTML)
window.copyMSO = async function(contentId) {
  const content = document.getElementById(contentId);
  if (!content) return;
  
  try {
    await navigator.clipboard.writeText(content.textContent);
    
    // Visual feedback
    const event = window.event;
    const button = event?.target;
    if (button) {
      const originalText = button.textContent;
      button.textContent = '✅ Copied!';
      button.style.background = '#10b981';
      
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = '#059669';
      }, 2000);
    }
    
    log('📋 MSO copied to clipboard');
  } catch (err) {
    console.error('Copy failed:', err);
    log('❌ Failed to copy MSO: ' + err.message);
  }
};

// Helper: Convert CBOR structures to plain JSON
function convertToJSON(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  // Handle CBOR.Tagged values
  if (obj instanceof CBOR.Tagged) {
    if (obj.tag === 1004) {
      // full-date
      return { _type: 'full-date', value: obj.value };
    } else if (obj.tag === 0) {
      // date-time string
      return { _type: 'date-time', value: obj.value };
    } else if (obj.tag === 1) {
      // epoch timestamp
      return { _type: 'epoch', value: obj.value };
    } else if (obj.tag === 24) {
      // Encoded CBOR data item
      try {
        const decoded = CBOR.decode(new Uint8Array(obj.value));
        return convertToJSON(decoded);
      } catch (e) {
        return { _type: 'encoded-cbor', _tag: obj.tag, value: Array.from(new Uint8Array(obj.value)) };
      }
    } else {
      return { _tag: obj.tag, value: convertToJSON(obj.value) };
    }
  }
  
  // Handle Map
  if (obj instanceof Map) {
    const result = {};
    for (const [key, value] of obj.entries()) {
      result[String(key)] = convertToJSON(value);
    }
    return result;
  }
  
  // Handle Uint8Array and other ArrayBuffer views
  if (obj instanceof Uint8Array || ArrayBuffer.isView(obj)) {
    return {
      _type: 'bytes',
      _length: obj.length,
      _base64: btoa(String.fromCharCode(...new Uint8Array(obj)))
    };
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => convertToJSON(item));
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return obj.toISOString();
  }
  
  // Handle plain objects
  if (typeof obj === 'object') {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertToJSON(value);
    }
    return result;
  }
  
  // Primitives
  return obj;
}

// Display DeviceResponse in a nice format
function displayDeviceResponse(deviceResponse) {
  console.log('=== DISPLAYING DEVICE RESPONSE ===');
  
  // Show the response section
  responseSectionEl.style.display = 'block';
  
  // Scroll to response
  setTimeout(() => {
    responseSectionEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
  
  // Handle both Map and Object formats
  const getField = (obj, key) => {
    if (obj instanceof Map) return obj.get(key);
    return obj[key];
  };
  
  // Extract version
  const version = getField(deviceResponse, 'version') || '1.0';
  
  // Extract documents
  const documents = getField(deviceResponse, 'documents');
  
  if (!documents || !Array.isArray(documents) || documents.length === 0) {
    responseDisplayEl.innerHTML = `
      <div class="response-header">
        <h3>🎉 Response Received</h3>
        <div class="response-meta">Version: ${version}</div>
      </div>
      <div class="no-data">No documents found in response</div>
    `;
    return;
  }
  
  // Build HTML
  let html = `
    <div class="response-header">
      <h3>🎉 Response Received</h3>
      <div class="response-meta">Version: ${version} • ${documents.length} document(s)</div>
      <button id="btnCopyResponse" class="copy-btn" style="margin-top: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
        📋 Copy as JSON
      </button>
    </div>
  `;
  
  // Process each document
  documents.forEach((doc, docIndex) => {
    const docType = getField(doc, 'docType') || 'Unknown';
    
    html += `
      <div class="document-card">
        <div class="document-type">📄 ${escapeHtml(docType)}</div>
    `;
    
    // Extract issuerSigned
    const issuerSigned = getField(doc, 'issuerSigned');
    if (!issuerSigned) {
      html += '<div class="no-data">No issuerSigned data</div>';
      html += '</div>';
      return;
    }
    
    // Extract namespaces
    const nameSpaces = getField(issuerSigned, 'nameSpaces');
    if (!nameSpaces) {
      html += '<div class="no-data">No nameSpaces data</div>';
      html += '</div>';
      return;
    }
    
    // Handle both Map and Object for nameSpaces
    const nsEntries = nameSpaces instanceof Map 
      ? Array.from(nameSpaces.entries())
      : Object.entries(nameSpaces);
    
    // Process each namespace
    nsEntries.forEach(([nsName, nsItems]) => {
      html += `
        <div class="namespace-section">
          <div class="namespace-title">📦 ${escapeHtml(nsName)}</div>
      `;
      
      if (!Array.isArray(nsItems) || nsItems.length === 0) {
        html += '<div class="no-data">No items in namespace</div>';
        html += '</div>';
        return;
      }
      
      // Process each item in the namespace
      nsItems.forEach((item, itemIndex) => {
        try {
          // Items are IssuerSignedItem objects, possibly tag(24) wrapped
          let issuerSignedItem = item;
          
          // Unwrap tag(24) if present
          if (item instanceof CBOR.Tagged && item.tag === 24) {
            const itemBytes = new Uint8Array(item.value);
            issuerSignedItem = CBOR.decode(itemBytes);
          }
          
          // Extract fields from IssuerSignedItem
          const elementIdentifier = getField(issuerSignedItem, 'elementIdentifier');
          const elementValue = getField(issuerSignedItem, 'elementValue');
          
          if (elementIdentifier && elementValue !== undefined) {
            // Format the value based on type
            let valueHtml;
            let rawValue = elementValue;
            
            // Handle CBOR tagged values
            if (elementValue instanceof CBOR.Tagged) {
              if (elementValue.tag === 1004) {
                // Tag 1004 = full-date (tdate) - ISO 8601 date string
                const dateStr = elementValue.value;
                try {
                  const date = new Date(dateStr);
                  const formatted = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                  });
                  valueHtml = `<div class="data-value">📅 ${formatted} <span class="binary" style="font-size:0.85em">(${dateStr})</span></div>`;
                  rawValue = dateStr;
                } catch (e) {
                  valueHtml = `<div class="data-value">${escapeHtml(String(elementValue.value))}</div>`;
                  rawValue = elementValue.value;
                }
              } else if (elementValue.tag === 0) {
                // Tag 0 = date-time string
                valueHtml = `<div class="data-value">🕐 ${escapeHtml(elementValue.value)}</div>`;
                rawValue = elementValue.value;
              } else if (elementValue.tag === 1) {
                // Tag 1 = epoch timestamp
                const date = new Date(elementValue.value * 1000);
                valueHtml = `<div class="data-value">🕐 ${date.toLocaleString()}</div>`;
                rawValue = elementValue.value;
              } else {
                // Other tagged values
                valueHtml = `<div class="data-value">Tag(${elementValue.tag}): ${escapeHtml(String(elementValue.value))}</div>`;
                rawValue = elementValue.value;
              }
            } else if (elementValue instanceof Uint8Array || ArrayBuffer.isView(elementValue)) {
              // Binary data (like portrait)
              const byteLength = elementValue.length;
              
              // Skip portrait fields with 0 bytes (empty/not provided)
              if (byteLength === 0 && 
                  (elementIdentifier.toLowerCase().includes('portrait') || 
                   elementIdentifier.toLowerCase().includes('image') ||
                   elementIdentifier.toLowerCase().includes('photo'))) {
                // Don't display empty portrait fields - skip to next item
                return; // Return from forEach callback to skip this item
              }
              
              // Try to detect if it's an image
              if (elementIdentifier.toLowerCase().includes('portrait') || 
                  elementIdentifier.toLowerCase().includes('image') ||
                  elementIdentifier.toLowerCase().includes('photo')) {
                // Detect image format by magic bytes
                let mimeType = 'application/octet-stream';
                let formatLabel = 'Unknown';
                
                if (elementValue.length >= 2) {
                  // JPEG: FF D8 FF
                  if (elementValue[0] === 0xFF && elementValue[1] === 0xD8 && elementValue[2] === 0xFF) {
                    mimeType = 'image/jpeg';
                    formatLabel = 'JPEG';
                  }
                  // JPEG2000: 00 00 00 0C 6A 50 20 20 0D 0A 87 0A (JP2 signature box)
                  else if (elementValue.length >= 12 &&
                           elementValue[0] === 0x00 && elementValue[1] === 0x00 &&
                           elementValue[2] === 0x00 && elementValue[3] === 0x0C &&
                           elementValue[4] === 0x6A && elementValue[5] === 0x50 &&
                           elementValue[6] === 0x20 && elementValue[7] === 0x20 &&
                           elementValue[8] === 0x0D && elementValue[9] === 0x0A &&
                           elementValue[10] === 0x87 && elementValue[11] === 0x0A) {
                    mimeType = 'image/jp2';
                    formatLabel = 'JPEG2000';
                  }
                  // Alternative JPEG2000 codestream: FF 4F FF 51
                  else if (elementValue[0] === 0xFF && elementValue[1] === 0x4F &&
                           elementValue.length >= 4 &&
                           elementValue[2] === 0xFF && elementValue[3] === 0x51) {
                    mimeType = 'image/jp2';
                    formatLabel = 'JPEG2000';
                  }
                }
                
                // Try to display as image using base64 data URI
                try {
                  let base64;
                  let displayMimeType = mimeType;
                  let displayFormat = formatLabel;
                  
                  if (mimeType === 'image/jp2') {
                    // JPEG2000 - provide download link since browsers don't support it natively
                    const portraitId = `portrait-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    valueHtml = `
                      <div class="data-value portrait-preview">
                        ${createJp2DownloadLink(elementValue, portraitId)}
                        <span class="binary" style="margin-top: 0.5rem;">${byteLength.toLocaleString()} bytes (${formatLabel})</span>
                      </div>
                    `;
                  } else {
                    // JPEG or other formats - display directly
                    base64 = btoa(String.fromCharCode(...elementValue));
                    const dataUri = `data:${displayMimeType};base64,${base64}`;
                    valueHtml = `
                      <div class="data-value portrait-preview">
                        <img src="${dataUri}" alt="Portrait" class="portrait-thumbnail" />
                        <span class="binary">${byteLength.toLocaleString()} bytes (${displayFormat})</span>
                      </div>
                    `;
                  }
                } catch (e) {
                  valueHtml = `<div class="data-value binary">&lt;binary data, ${byteLength.toLocaleString()} bytes&gt;</div>`;
                }
              } else {
                valueHtml = `<div class="data-value binary">&lt;binary data, ${byteLength.toLocaleString()} bytes&gt;</div>`;
              }
            } else if (elementValue instanceof Date) {
              valueHtml = `<div class="data-value">${elementValue.toISOString().split('T')[0]}</div>`;
            } else if (Array.isArray(elementValue)) {
              // Array value (like driving_privileges)
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${escapeHtml(JSON.stringify(elementValue, null, 2))}</pre></div>`;
            } else if (typeof elementValue === 'object' && elementValue !== null) {
              // Object value
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${escapeHtml(JSON.stringify(elementValue, null, 2))}</pre></div>`;
            } else if (typeof elementValue === 'boolean') {
              valueHtml = `<div class="data-value">${elementValue ? '✓ Yes' : '✗ No'}</div>`;
            } else {
              valueHtml = `<div class="data-value">${escapeHtml(String(elementValue))}</div>`;
            }
            
            html += `
              <div class="data-item">
                <div class="data-label">${escapeHtml(formatFieldName(elementIdentifier))}</div>
                ${valueHtml}
              </div>
            `;
          }
        } catch (itemError) {
          console.error('Error processing item:', itemError);
          html += `
            <div class="data-item">
              <div class="data-label">Item ${itemIndex + 1}</div>
              <div class="data-value binary">(parse error: ${escapeHtml(itemError.message)})</div>
            </div>
          `;
        }
      });
      
      html += '</div>'; // End namespace-section
    });
    
    // Add signer information and signature verification section
    const issuerAuth = getField(issuerSigned, 'issuerAuth');
    if (issuerAuth) {
      html += `
        <div class="signer-section" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
          <div style="font-weight: bold; margin-bottom: 10px; color: #007bff;">🔐 Issuer Signature Information</div>
      `;
      
      try {
        // issuerAuth is a COSE_Sign1 structure
        // Decode if it's wrapped in tag(24)
        let coseSign1 = issuerAuth;
        
        console.log('=== PARSING ISSUER AUTH ===');
        console.log('issuerAuth type:', issuerAuth?.constructor?.name);
        console.log('issuerAuth:', issuerAuth);
        
        if (issuerAuth instanceof CBOR.Tagged && issuerAuth.tag === 24) {
          console.log('Unwrapping tag(24)...');
          const coseBytes = new Uint8Array(issuerAuth.value);
          console.log('COSE bytes length:', coseBytes.length);
          coseSign1 = CBOR.decode(coseBytes);
          console.log('Decoded COSE_Sign1:', coseSign1);
        }
        
        // COSE_Sign1 = [protected, unprotected, payload, signature]
        if (Array.isArray(coseSign1) && coseSign1.length >= 4) {
          const [protectedHeader, unprotectedHeader, payload, signature] = coseSign1;
          
          console.log('Protected header:', protectedHeader);
          console.log('Unprotected header:', unprotectedHeader);
          console.log('Payload length:', payload?.length);
          console.log('Signature length:', signature?.length);
          
          // Decode protected header
          let protectedData = {};
          if (protectedHeader && protectedHeader.length > 0) {
            try {
              // CRITICAL FIX: Create a new independent buffer from the view
              // protectedHeader is a Uint8Array view, we need to copy it to decode correctly
              const protectedHeaderCopy = new Uint8Array(protectedHeader);
              console.log('Protected header bytes to decode:', hex(protectedHeaderCopy));
              const decoded = CBOR.decode(protectedHeaderCopy);
              console.log('Decoded protected header:', decoded);
              if (decoded instanceof Map) {
                protectedData = Object.fromEntries(decoded);
              } else {
                protectedData = decoded;
              }
              console.log('Protected data:', protectedData);
            } catch (e) {
              console.warn('Could not decode protected header:', e);
            }
          }
          
          // Display algorithm: show header immediately, then update asynchronously based on cert curve
          const alg = protectedData[1] || (unprotectedHeader instanceof Map ? unprotectedHeader.get(1) : unprotectedHeader?.[1]);
          console.log('Algorithm value:', alg);
          console.log('Algorithm from protected:', protectedData[1]);
          console.log('Algorithm from unprotected:', unprotectedHeader instanceof Map ? unprotectedHeader.get(1) : unprotectedHeader?.[1]);

          // Header-based label
          let headerAlgLabel = 'Unknown';
          if (alg === -7) headerAlgLabel = 'ES256 (ECDSA with SHA-256)';
          else if (alg === -35) headerAlgLabel = 'ES384 (ECDSA with SHA-384)';
          else if (alg === -36) headerAlgLabel = 'ES512 (ECDSA with SHA-512)';
          else if (alg === -8) headerAlgLabel = 'EdDSA';
          else if (alg != null) headerAlgLabel = `Algorithm ${alg}`;

          const sigAlgId = `sig-alg-${docIndex}`;
          html += `
            <div class=\"data-item\">
              <div class=\"data-label\">Signature Algorithm</div>
              <div class=\"data-value\" id=\"${sigAlgId}\">${escapeHtml(headerAlgLabel)}</div>
            </div>
          `;

          // Read issuer certificate (x5chain, header 33) early for mapping
          const _issuerCertRaw = (unprotectedHeader instanceof Map ? unprotectedHeader.get(33) : unprotectedHeader?.[33]);
          let issuerCertFirst = null;
          if (_issuerCertRaw) {
            if (Array.isArray(_issuerCertRaw) && _issuerCertRaw.length > 0) {
              issuerCertFirst = _issuerCertRaw[0];
            } else {
              issuerCertFirst = _issuerCertRaw;
            }
          }

          // Update algorithm display asynchronously based on actual curve
          if (issuerCertFirst) {
            setTimeout(async () => {
              try {
                const el = document.getElementById(sigAlgId);
                if (!el) return;
                const pub = await extractPublicKeyFromCert(issuerCertFirst, true);
                let curveName = (pub?.nobleCurveName || '').toLowerCase();
                let effectiveAlgLabel = headerAlgLabel;
                let curveLabel = '';
                // Fallback: derive curve from certificate OID if noble-based extraction is unavailable
                if (!curveName) {
                  const label = detectCurveFromCertOID(issuerCertFirst);
                  curveLabel = label || '';
                  curveName = (label || '').toLowerCase();
                }
                if (curveName.includes('p256') || curveName.includes('brainpoolp256')) {
                  effectiveAlgLabel = 'ES256 (ECDSA with SHA-256)';
                  curveLabel = curveName.includes('brainpool') ? 'brainpoolP256r1' : 'P-256';
                } else if (curveName.includes('p384') || curveName.includes('brainpoolp384') || curveName.includes('brainpoolp320')) {
                  effectiveAlgLabel = 'ES384 (ECDSA with SHA-384)';
                  if (curveName.includes('brainpoolp320')) curveLabel = 'brainpoolP320r1';
                  else if (curveName.includes('brainpool')) curveLabel = 'brainpoolP384r1';
                  else curveLabel = 'P-384';
                } else if (curveName.includes('p521') || curveName.includes('brainpoolp512')) {
                  effectiveAlgLabel = 'ES512 (ECDSA with SHA-512)';
                  curveLabel = curveName.includes('brainpool') ? 'brainpoolP512r1' : 'P-521';
                } else if (curveName.includes('ed25519') || curveName.includes('ed448')) {
                  effectiveAlgLabel = 'EdDSA';
                  curveLabel = curveName.includes('ed448') ? 'Ed448' : 'Ed25519';
                }
                const curveSuffix = curveLabel ? ` <span style=\"color:#475569;\">— Curve: ${curveLabel}</span>` : '';
                if (effectiveAlgLabel !== headerAlgLabel) {
                  el.innerHTML = `${effectiveAlgLabel}${curveSuffix} <span style=\"color:#64748b;\">(header: ${escapeHtml(headerAlgLabel)})</span>`;
                } else {
                  el.innerHTML = `${effectiveAlgLabel}${curveSuffix}`;
                }
                console.log('Updated UI Signature Algorithm to effective label:', effectiveAlgLabel, 'based on curve', curveName);
              } catch (e) {
                console.warn('Failed to update Signature Algorithm from certificate curve:', e?.message || e);
              }
            }, 0);
          }
          
          // Display certificate if present in x5chain (header parameter 33)
          const issuerCert = unprotectedHeader instanceof Map ? unprotectedHeader.get(33) : unprotectedHeader?.[33];
          if (issuerCert) {
            html += `
              <div class="data-item">
                <div class="data-label">Issuer Certificate</div>
                <div class="data-value">✓ Certificate provided (${issuerCert.length || issuerCert.byteLength} bytes)</div>
              </div>
            `;
            
            // Extract and display certificate information
            try {
              const cert = issuerCert;
              if (cert instanceof Uint8Array || ArrayBuffer.isView(cert)) {      
                // Extract Subject and Issuer information
                const certInfo = extractCertInfo(cert);
                
                if (certInfo.subjectDN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Subject</div>
                      <div class="data-value" style="font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem;">${escapeHtml(certInfo.subjectDN)}</div>
                    </div>
                  `;
                } else if (certInfo.subjectCN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Subject CN</div>
                      <div class="data-value">${escapeHtml(certInfo.subjectCN)}</div>
                    </div>
                  `;
                }
                
                if (certInfo.issuerDN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Issuer</div>
                      <div class="data-value" style="font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem;">${escapeHtml(certInfo.issuerDN)}</div>
                    </div>
                  `;
                } else if (certInfo.issuerCN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Issuer CN</div>
                      <div class="data-value">${escapeHtml(certInfo.issuerCN)}</div>
                    </div>
                  `;
                }
              }
            } catch (certError) {
              console.warn('Certificate parsing error:', certError);
            }
          }
          
          // Display signature
          if (signature instanceof Uint8Array || ArrayBuffer.isView(signature)) {
            html += `
              <div class="data-item">
                <div class="data-label">Signature</div>
                <div class="data-value binary">${signature.length} bytes</div>
              </div>
            `;
            
            // Signature verification status (will be updated asynchronously)
            const verifyId = `verify-${docIndex}`;
            html += `
              <div class="data-item">
                <div class="data-label">Verification Status</div>
                <div class="data-value" id="${verifyId}" style="color: #6c757d;">🔄 Verifying signature...</div>
              </div>
            `;
            
            // Perform verification asynchronously
            // Capture variables in closure for async callback
            const capturedCoseSign1 = coseSign1;
            const capturedIssuerCert = issuerCert;
            
            setTimeout(async () => {
              const statusEl = document.getElementById(verifyId);
              if (!statusEl) return;
              
              try {
                // Extract public key from certificate
                const cert = capturedIssuerCert;
                if (!cert) {
                  statusEl.innerHTML = '<span style="color: #ffc107;">⚠️ No certificate found for verification</span>';
                  return;
                }
                
                statusEl.innerHTML = '<span style="color: #6c757d;">🔄 Extracting public key from certificate...</span>';
                const publicKey = await extractPublicKeyFromCert(cert);
                
                // Check if public key extraction failed
                if (!publicKey) {
                  statusEl.innerHTML = '<span style="color: #dc3545;">❌ Chain: IACA certificate missing or invalid</span>';
                  log(`❌ Document ${docIndex + 1} issuer validation: IACA certificate missing or invalid`);
                  return;
                }
                
                statusEl.innerHTML = '<span style="color: #6c757d;">🔄 Verifying ECDSA signature...</span>';
                const isValid = await verifyCoseSign1(capturedCoseSign1, publicKey);
                console.log('Direct signature verification result:', isValid);
                
                // Verify issuer certificate against IACA roots
                statusEl.innerHTML = '<span style="color: #6c757d;">🔄 Validating issuer certificate...</span>';
                const chainResult = await verifyCOSESign1SignatureWithChain(capturedCoseSign1);
                console.log('Chain verification result:', chainResult);
                
                // Build detailed status message
                // Per requirements: signature is valid if EITHER:
                // 1. Signature verifies with certificate in signed object, OR
                // 2. Certificate chain is verified against IACA
                let statusHTML = '';
                const signatureValid = isValid || chainResult.signatureValid;
                console.log('Final signature valid status:', signatureValid, '(isValid:', isValid, 'chainResult.signatureValid:', chainResult.signatureValid, ')');
                
                if (signatureValid) {
                  statusHTML += '<span style="color: #28a745;">✅ Signature: Valid</span><br>';
                  log(`✅ Document ${docIndex + 1} signature verified`);
                } else {
                  statusHTML += '<span style="color: #dc3545;">❌ Signature: Invalid</span><br>';
                  log(`❌ Document ${docIndex + 1} signature verification failed`);
                  console.error('Both verification methods failed. isValid:', isValid, 'chainResult:', chainResult);
                }
                
                // Add chain validation status
                if (chainResult.chainValid && chainResult.chainInfo?.matchedIACA) {
                  const matchedIACA = chainResult.chainInfo.matchedIACA;
                  const testIndicator = matchedIACA.test ? ' <span style="color: #f59e0b; font-weight: 500;">⚠️ test/development IACA</span>' : '';
                  statusHTML += `<span style="color: #28a745;">✅ Chain: Valid (${escapeHtml(matchedIACA.name)}) ${testIndicator}</span>`;
                  log(`✅ Document ${docIndex + 1} issuer certificate validated with: ${matchedIACA.name}${matchedIACA.test ? ' (TEST)' : ''}`);
                } else if (chainResult.chainInfo?.errors.length > 0) {
                  // Check if error is IACA-related
                  const iacaError = chainResult.chainInfo.errors.find(err => 
                    err.includes('IACA certificate missing') || 
                    err.includes('No active IACA') ||
                    err.includes('Failed to import public key')
                  );
                  
                  if (iacaError) {
                    statusHTML += `<span style="color: #dc3545;">❌ Chain: IACA certificate missing or invalid</span>`;
                    log(`❌ Document ${docIndex + 1} issuer validation: IACA certificate missing or invalid`);
                  } else {
                    statusHTML += `<span style="color: #ffc107;">⚠️ Chain: ${escapeHtml(chainResult.chainInfo.errors[0])}</span>`;
                    log(`⚠️ Document ${docIndex + 1} issuer validation: ${chainResult.chainInfo.errors[0]}`);
                  }
                } else {
                  statusHTML += '<span style="color: #94a3b8;">○ Chain: Not validated</span>';
                }
                
                statusEl.innerHTML = statusHTML;
                
              } catch (verifyError) {
                console.error('Verification error:', verifyError);
                
                // Check if this is an IACA-related error
                let errorMessage = verifyError.message;
                if (verifyError.name === 'DataError' || errorMessage.includes('Failed to import')) {
                  errorMessage = 'IACA certificate missing or invalid';
                  statusEl.innerHTML = `<span style="color: #dc3545;">❌ Chain: ${escapeHtml(errorMessage)}</span>`;
                } else {
                  statusEl.innerHTML = `<span style="color: #dc3545;">❌ Verification error: ${escapeHtml(errorMessage)}</span>`;
                }
                
                log(`❌ Document ${docIndex + 1} verification error: ${errorMessage}`);
              }
            }, 100);
          }
          
          // Decode and show MSO (Mobile Security Object) contents
          if (payload) {
            // Decode MSO to extract metadata
            try {
              const payloadBytes = payload instanceof Uint8Array ? payload : new Uint8Array(payload);
              const mso = CBOR.decode(payloadBytes);
              console.log('Decoded MSO:', mso);
              
              // MSO structure: { version, digestAlgorithm, valueDigests, deviceKeyInfo, docType, validityInfo }
              const getField = (obj, key) => {
                if (obj instanceof Map) return obj.get(key);
                return obj[key];
              };
              
              // Extract docType
              const msoDocType = getField(mso, 'docType');
              if (msoDocType) {
                html += `
                  <div class="data-item">
                    <div class="data-label">MSO DocType</div>
                    <div class="data-value">${escapeHtml(String(msoDocType))}</div>
                  </div>
                `;
              }
              
              // Extract validityInfo (contains signed and validFrom/validUntil dates)
              const validityInfo = getField(mso, 'validityInfo');
              if (validityInfo) {
                // signed - date when MSO was signed
                const signed = getField(validityInfo, 'signed');
                if (signed) {
                  let signedDate = signed;
                  // Handle CBOR tagged dates (tag 0 = date-time string, tag 1 = epoch)
                  if (signed instanceof CBOR.Tagged) {
                    if (signed.tag === 0) {
                      signedDate = signed.value; // ISO 8601 string
                    } else if (signed.tag === 1) {
                      signedDate = new Date(signed.value * 1000).toISOString();
                    }
                  }
                  
                  try {
                    const date = new Date(signedDate);
                    const formatted = date.toLocaleString('en-US', { 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                      second: '2-digit',
                      timeZoneName: 'short'
                    });
                    html += `
                      <div class="data-item">
                        <div class="data-label">📅 Signed Date</div>
                        <div class="data-value" style="color: #059669; font-weight: 600;">${formatted}</div>
                      </div>
                    `;
                  } catch (e) {
                    html += `
                      <div class="data-item">
                        <div class="data-label">📅 Signed Date</div>
                        <div class="data-value">${escapeHtml(String(signedDate))}</div>
                      </div>
                    `;
                  }
                }
                
                // validFrom - date from which document is valid
                const validFrom = getField(validityInfo, 'validFrom');
                if (validFrom) {
                  let validFromDate = validFrom;
                  if (validFrom instanceof CBOR.Tagged) {
                    if (validFrom.tag === 0) {
                      validFromDate = validFrom.value;
                    } else if (validFrom.tag === 1) {
                      validFromDate = new Date(validFrom.value * 1000).toISOString();
                    }
                  }
                  
                  try {
                    const date = new Date(validFromDate);
                    const formatted = date.toLocaleDateString('en-US', { 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric'
                    });
                    html += `
                      <div class="data-item">
                        <div class="data-label">Valid From</div>
                        <div class="data-value">${formatted}</div>
                      </div>
                    `;
                  } catch (e) {
                    html += `
                      <div class="data-item">
                        <div class="data-label">Valid From</div>
                        <div class="data-value">${escapeHtml(String(validFromDate))}</div>
                      </div>
                    `;
                  }
                }
                
                // validUntil - date until which document is valid
                const validUntil = getField(validityInfo, 'validUntil');
                if (validUntil) {
                  let validUntilDate = validUntil;
                  if (validUntil instanceof CBOR.Tagged) {
                    if (validUntil.tag === 0) {
                      validUntilDate = validUntil.value;
                    } else if (validUntil.tag === 1) {
                      validUntilDate = new Date(validUntil.value * 1000).toISOString();
                    }
                  }
                  
                  try {
                    const date = new Date(validUntilDate);
                    const formatted = date.toLocaleDateString('en-US', { 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric'
                    });
                    
                    // Check if expired
                    const now = new Date();
                    const isExpired = date < now;
                    const style = isExpired ? 'color: #dc3545; font-weight: 600;' : '';
                    const icon = isExpired ? '⚠️ ' : '';
                    
                    html += `
                      <div class="data-item">
                        <div class="data-label">Valid Until</div>
                        <div class="data-value" style="${style}">${icon}${formatted}</div>
                      </div>
                    `;
                  } catch (e) {
                    html += `
                      <div class="data-item">
                        <div class="data-label">Valid Until</div>
                        <div class="data-value">${escapeHtml(String(validUntilDate))}</div>
                      </div>
                    `;
                  }
                }
              }
              
              // Extract digest algorithm
              const digestAlgorithm = getField(mso, 'digestAlgorithm');
              if (digestAlgorithm) {
                html += `
                  <div class="data-item">
                    <div class="data-label">Digest Algorithm</div>
                    <div class="data-value">${escapeHtml(String(digestAlgorithm))}</div>
                  </div>
                `;
              }
              
              // Add expandable section to show complete MSO
              const msoId = `mso-${docIndex}`;
              const msoJson = JSON.stringify(convertToJSON(mso), null, 2);
              
              html += `
                <div style="margin-top: 1rem; border-top: 1px solid #e2e8f0; padding-top: 1rem;">
                  <button 
                    onclick="toggleMSO('${msoId}')" 
                    style="
                      background: #f1f5f9;
                      color: #0f172a;
                      border: 1px solid #cbd5e1;
                      padding: 0.5rem 1rem;
                      border-radius: 8px;
                      cursor: pointer;
                      font-size: 0.9rem;
                      font-weight: 600;
                      display: flex;
                      align-items: center;
                      gap: 0.5rem;
                      width: 100%;
                      justify-content: center;
                      transition: background 0.2s ease;
                    "
                    onmouseover="this.style.background='#e2e8f0'"
                    onmouseout="this.style.background='#f1f5f9'"
                  >
                    <span id="${msoId}-icon">▶</span>
                    <span>View Complete MSO Structure</span>
                  </button>
                  <div 
                    id="${msoId}" 
                    style="
                      display: none;
                      margin-top: 0.75rem;
                      background: #f8fafc;
                      border: 1px solid #e2e8f0;
                      border-radius: 8px;
                      padding: 1rem;
                      max-height: 400px;
                      overflow-y: auto;
                    "
                  >
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <span style="font-size: 0.85rem; color: #64748b; font-weight: 600;">Complete MSO (JSON)</span>
                      <button 
                        onclick="copyMSO('${msoId}-content')"
                        style="
                          background: #059669;
                          color: white;
                          border: none;
                          padding: 0.35rem 0.75rem;
                          border-radius: 6px;
                          cursor: pointer;
                          font-size: 0.8rem;
                          font-weight: 600;
                        "
                      >
                        📋 Copy
                      </button>
                    </div>
                    <pre id="${msoId}-content" style="
                      margin: 0;
                      font-family: 'SFMono-Regular', 'JetBrains Mono', ui-monospace, monospace;
                      font-size: 0.85rem;
                      line-height: 1.5;
                      color: #0f172a;
                      white-space: pre-wrap;
                      word-break: break-word;
                    ">${escapeHtml(msoJson)}</pre>
                  </div>
                </div>
              `;
              
            } catch (msoError) {
              console.warn('Could not decode MSO:', msoError);
            }
          }
          
        } else {
          html += `<div class="data-value">⚠️ Unexpected COSE_Sign1 structure</div>`;
        }
        
      } catch (sigError) {
        console.error('Error parsing issuerAuth:', sigError);
        html += `
          <div class="data-item">
            <div class="data-value" style="color: #dc3545;">❌ Error parsing signature: ${escapeHtml(sigError.message)}</div>
          </div>
        `;
      }
      
      html += '</div>'; // End signer-section
    } else {
      html += `
        <div class="signer-section" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
          <div style="color: #856404;">⚠️ No issuer signature found (issuerAuth missing)</div>
        </div>
      `;
    }
    
    html += '</div>'; // End document-card
  });
  
  responseDisplayEl.innerHTML = html;
  
  // Add copy button event listener
  setTimeout(() => {
    const btnCopy = document.getElementById('btnCopyResponse');
    if (btnCopy) {
      btnCopy.addEventListener('click', async () => {
        try {
          // Convert deviceResponse to a clean JSON object
          const jsonData = convertToJSON(deviceResponse);
          const jsonString = JSON.stringify(jsonData, null, 2);
          
          await navigator.clipboard.writeText(jsonString);
          
          // Visual feedback
          const originalText = btnCopy.textContent;
          btnCopy.textContent = '✅ Copied!';
          btnCopy.style.background = '#218838';
          
          setTimeout(() => {
            btnCopy.textContent = originalText;
            btnCopy.style.background = '#28a745';
          }, 2000);
          
          log('📋 Response copied to clipboard as JSON');
        } catch (err) {
          console.error('Copy failed:', err);
          log('❌ Failed to copy: ' + err.message);
        }
      });
    }
  }, 100);
  
  log('✅ Response decrypted and displayed successfully!');
  
  // Automatic cleanup: Send END state and close connection
  setTimeout(async () => {
    try {
      // Check if still connected and characteristic is valid
      if (device?.gatt?.connected && chState) {
        try {
          log('🔚 Sending END state (0x02) to wallet...');
          await writeState(0x02);
          log('✅ END state sent');
          
          // Give wallet time to process, then disconnect
          setTimeout(() => {
            if (device?.gatt?.connected) {
              log('🔌 Closing BLE connection...');
              device.gatt.disconnect();
              log('✅ Connection closed - ready for next scan');
            }
          }, 500);
        } catch (stateError) {
          // Wallet already disconnected or GATT service gone
          console.log('State write skipped (wallet disconnected):', stateError.message);
          if (device?.gatt?.connected) {
            device.gatt.disconnect();
          }
          log('✅ Connection closed - ready for next scan');
        }
      } else {
        // Already disconnected by wallet
        log('✅ Wallet disconnected - ready for next scan');
      }
    } catch (cleanupError) {
      console.error('Cleanup error:', cleanupError);
      log('✅ Session ended - ready for next scan');
    }
  }, 1000); // Wait 1 second before cleanup
}

// Helper: Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Decrypt SessionEstablishment response data field (raw AES-GCM format)
async function decryptSessionEstablishmentData(encryptedData) {
  console.log('=== DECRYPTING SESSION ESTABLISHMENT DATA ===');
  console.log('Encrypted data length:', encryptedData.length);
  console.log('Encrypted data hex (first 64 bytes):', hex(encryptedData.slice(0, 64)));
  
  // Per ISO 18013-5: SessionEstablishment data field is RAW encrypted data
  // Format: ciphertext || 16-byte auth tag
  // Encrypted with SKDevice, counter starts at 1
  // IV = mdoc_identifier(8 bytes) || counter(4 bytes)
  
  // Mdoc identifier: 8 bytes, last byte is 0x01
  const mdocIdentifier = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);
  const counter = 1; // First message from mdoc
  
  // Build IV: identifier || counter (big-endian)
  const iv = new Uint8Array(12);
  iv.set(mdocIdentifier, 0);
  const dv = new DataView(iv.buffer, 8, 4);
  dv.setUint32(0, counter, false); // Big-endian
  
  console.log('IV for decryption:', hex(iv));
  console.log('  - Mdoc identifier (8 bytes):', hex(mdocIdentifier));
  console.log('  - Counter (4 bytes BE):', counter);
  console.log('Using SKDevice for decryption:', hex(skDevice));
  
  // Decrypt with AES-256-GCM
  const key = await crypto.subtle.importKey(
    'raw',
    skDevice,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
  
  try {
    const decrypted = await crypto.subtle.decrypt(
      { 
        name: 'AES-GCM', 
        iv, 
        additionalData: new Uint8Array(0), // Empty AAD per spec
        tagLength: 128 
      },
      key,
      encryptedData
    );
    
    const plaintext = new Uint8Array(decrypted);
    console.log('✅ Decryption successful!');
    console.log('Plaintext length:', plaintext.length);
    console.log('Plaintext hex (first 64 bytes):', hex(plaintext.slice(0, 64)));
    
    // Decode the DeviceResponse
    const deviceResponse = CBOR.decode(plaintext);
    console.log('Decoded DeviceResponse:', deviceResponse);
    
    // Display the response
    displayDeviceResponse(deviceResponse);
    
  } catch (decryptError) {
    console.error('❌ Decryption failed:', decryptError);
    log('❌ Decryption failed - may be wrong key or IV');
    throw decryptError;
  }
}

// Helper: Format field names to be more readable
function formatFieldName(fieldName) {
  return fieldName
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

async function processSessionResponse(assembled) {
  console.log('=== FINALIZING SESSION FROM WALLET RESPONSE ===');
  console.log('Raw response bytes:', hex(assembled));

  if (!readerKeyPair) {
    throw new Error('Reader ephemeral key pair not initialized');
  }

  let decoded;
  try {
  decoded = CBOR.decode(assembled);
    console.log('Decoded session response:', decoded);
  } catch (decodeError) {
    console.warn('Session response is not valid CBOR:', decodeError.message);
    decoded = null;
  }

  // Helper to coerce Map/Object into Map-like accessor
  const toMap = (value) => {
    if (!value) return null;
    if (value instanceof Map) return value;
    if (typeof value === 'object') {
      const map = new Map();
      for (const key of Object.keys(value)) {
        map.set(key, value[key]);
      }
      return map;
    }
    return null;
  };

  const decodedMap = toMap(decoded);
  let eDeviceKey = null;

  const possibleLabels = ['eDeviceKey', 'publicKey', 'deviceKey'];
  if (decodedMap) {
    for (const label of possibleLabels) {
      if (decodedMap.has(label)) {
        eDeviceKey = decodedMap.get(label);
        console.log(`Found potential wallet key under label "${label}"`);
        break;
      }
    }
  }

  // Some wallets nest the key inside the "deviceEngagement" or similar structures
  if (!eDeviceKey && decodedMap) {
    for (const value of decodedMap.values()) {
      const nested = toMap(value);
      if (nested) {
        for (const label of possibleLabels) {
          if (nested.has(label)) {
            eDeviceKey = nested.get(label);
            console.log(`Found nested wallet key under label "${label}"`);
            break;
          }
        }
      }
      if (eDeviceKey) break;
    }
  }

  let walletKeyMap = null;
  if (eDeviceKey) {
    if (eDeviceKey instanceof CBOR.Tagged) {
      console.log('Wallet key is CBOR.Tagged - decoding value');
      const value = eDeviceKey.value;
      const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);
  walletKeyMap = toMap(CBOR.decode(bytes));
    } else if (eDeviceKey instanceof Uint8Array) {
      console.log('Wallet key is raw Uint8Array - decoding');
  walletKeyMap = toMap(CBOR.decode(new Uint8Array(eDeviceKey.buffer, eDeviceKey.byteOffset, eDeviceKey.byteLength)));
    } else if (ArrayBuffer.isView(eDeviceKey)) {
      console.log('Wallet key is ArrayBuffer view - decoding');
      const bytes = new Uint8Array(eDeviceKey.buffer, eDeviceKey.byteOffset, eDeviceKey.byteLength);
  walletKeyMap = toMap(CBOR.decode(bytes));
    } else {
      walletKeyMap = toMap(eDeviceKey);
    }
  }

  let sharedSecretBuffer = null;

  // log('⚠️ Wallet response did not contain an ephemeral key. Falling back to static DeviceEngagement key.');
  const mdocPub = await importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
  sharedSecretBuffer = await deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);

  const sharedSecretBytes = new Uint8Array(sharedSecretBuffer);
  transcriptAAD = await buildTranscriptAAD();
  const keys = await deriveSessionKey(sharedSecretBytes, transcriptAAD);

  skReader = keys.readerKey;
  skDevice = keys.deviceKey;
  sessionKey = skReader;
  sessionEstablished = true;
  window.sessionEstablished = true;

  console.log('Session keys ready. SKReader:', hex(skReader));
  console.log('Session keys ready. SKDevice:', hex(skDevice));

  log('✅ Session ready using static DeviceEngagement key');

  // Now decrypt and display the documents from the 'data' field
  log('🔓 Decrypting wallet response to extract documents...');
  
  // Get the 'data' field from the response (decodedMap already declared above)
  const responseData = decodedMap ? (decodedMap.get('data') || decodedMap.get(4)) : null;
  
  if (responseData && responseData.length > 0) {
    try {
      // The 'data' field contains RAW encrypted DeviceResponse (not COSE_Encrypt0)
      // Per ISO 18013-5: SessionEstablishment response uses same format as request
      // Format: ciphertext || 16-byte auth tag (encrypted with SKDevice)
      await decryptSessionEstablishmentData(responseData);
    } catch (decryptError) {
      console.error('Failed to decrypt documents:', decryptError);
      log('❌ Failed to decrypt documents: ' + decryptError.message);
    }
  } else {
    log('⚠️ No document data found in wallet response');
  }
}
async function writeState(byte) {
  await chState.writeValueWithoutResponse(Uint8Array.of(byte));
  log(`State set to 0x${byte.toString(16)}`);
}
async function sendFragmented(payload) {
  if (!chC2S) throw new Error('Client-to-Server characteristic not available');
  if (!device?.gatt?.connected) throw new Error('Device not connected');
  
  // ISO 18013-5 recommends requesting high MTU, but Web Bluetooth API doesn't expose requestMTU()
  // User can manually configure chunk size. Modern devices typically support 185-512 bytes.
  const sz = parseInt(chunkInput.value,10) || 185;
  let off = 0;
  while (off < payload.length) {
    const rem = payload.length - off;
    const take = Math.min(rem, sz);
    const last = rem <= sz;
    const frag = new Uint8Array(1 + take);
    frag[0] = last ? 0x00 : 0x01;
    frag.set(payload.slice(off, off+take), 1);
    
    try {
      await chC2S.writeValueWithoutResponse(frag);
      log(`C→S write: flag=0x${frag[0].toString(16)} len=${take}`);
    } catch (e) {
      throw new Error(`Write failed: ${e.message}`);
    }
    
    off += take;
    
    // Small delay between fragments to avoid overwhelming the connection
    if (off < payload.length) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
  }
}

// ==== QR scanning ====
function stopCamera() {
  scanRunning = false;
  video.pause();
  
  // Stop all video tracks to release the camera
  if (video.srcObject) {
    const stream = video.srcObject;
    const tracks = stream.getTracks();
    tracks.forEach(track => {
      track.stop();
      console.log('Camera track stopped:', track.kind);
    });
    video.srcObject = null;
    log('📹 Camera stopped');
  }
}

// Disconnect existing BLE connection if any
function disconnectBLE() {
  if (device && device.gatt && device.gatt.connected) {
    try {
      log('🔌 Disconnecting previous BLE connection...');
      device.gatt.disconnect();
      console.log('Previous BLE device disconnected');
    } catch (e) {
      console.warn('Error disconnecting BLE device:', e);
    }
  }
  
  // Reset all connection state
  device = null;
  server = null;
  service = null;
  chState = null;
  chC2S = null;
  chS2C = null;
  rxBuffer = [];
  sessionEstablished = false;
  
  // Reset session keys
  readerKeyPair = null;
  skReader = null;
  skDevice = null;
  sessionKey = null;
  transcriptAAD = null;
  walletEphemeralKey = null;
  
  // Remove existing connect button if present
  const existingBtn = document.getElementById('btnAutoConnect');
  if (existingBtn) {
    existingBtn.remove();
    console.log('Removed existing connect button');
  }
  
  console.log('BLE connection state reset');
}

async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
  video.srcObject = stream;
  await video.play();
  canvas.width = video.videoWidth || 1280;
  canvas.height = video.videoHeight || 720;
  scanRunning = true;
  statusEl.textContent = 'Scanning…';
  requestAnimationFrame(tick);
}
function tick() {
  if (!scanRunning) return;
  const ctx2d = canvas.getContext('2d', { willReadFrequently:true });
  ctx2d.drawImage(video, 0, 0, canvas.width, canvas.height);
  const img = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
  const code = jsQR(img.data, img.width, img.height, { inversionAttempts: "dontInvert" });
  if (code?.data) {
    stopCamera(); // Properly stop the camera
    statusEl.textContent='QR detected';
    handleQrPayload(code.data, 'camera scan');
    return;
  }
  requestAnimationFrame(tick);
}
btnScan.addEventListener('click', () => startCamera().catch(e => log('Camera error: '+e.message)));

// Normalize QR payloads coming from camera, manual paste, or laser scanner.
async function handleQrPayload(raw, sourceLabel) {
  const payload = (raw || '').trim();
  if (!payload) {
    log('⚠️ No QR payload provided');
    statusEl.textContent = 'No payload';
    return;
  }

  // Disconnect any existing BLE connection before processing new QR code
  disconnectBLE();

  try {
    const { uuid, addr } = parseMdocUriAndDE(payload);
    svcUUID = uuid;
    bleAddr = addr;
    svcUuidEl.textContent = uuid || '—';
    bleAddrEl.textContent = addr || '—';
    statusEl.textContent = `Parsed from ${sourceLabel}`;
    qrInput.value = payload;
    updateBleRoleUI();
    log(`✅ Parsed QR payload from ${sourceLabel}. Service UUID: ${uuid || 'n/a'}`);
    
    // Show message to user about clicking to connect
    log('🚀 Ready to connect! Click "Connect & Request Digital Credentials" below to continue...');
    
    // Enable and show a connect button
    if (!document.getElementById('btnAutoConnect')) {
      const connectBtn = document.createElement('button');
      connectBtn.id = 'btnAutoConnect';
      connectBtn.textContent = '🚀 Connect & Request Digital Credentials';
      connectBtn.style.cssText = 'margin: 1rem 0; padding: 0.75rem 1.5rem; font-size: 1.1em; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;';
      connectBtn.onclick = async () => {
        connectBtn.disabled = true;
        connectBtn.textContent = 'Connecting...';
        try {
          await autoConnectFlow();
          connectBtn.remove(); // Remove button after successful connection
        } catch (error) {
          connectBtn.disabled = false;
          connectBtn.textContent = '🚀 Connect & Start Session';
          log(`❌ Connection failed: ${error.message}`);
        }
      };
      
      // Insert button after the QR section
      const qrSection = document.getElementById('qrSection');
      qrSection.appendChild(connectBtn);
    }
    
  } catch (e) {
    log(`❌ ${sourceLabel} QR parse error: ${e.message}`);
    statusEl.textContent = 'Parse failed';
  }
}

// BLE Connection function (extracted from button handler)
async function bleConnect() {
  if (!svcUUID) throw new Error('Service UUID missing (scan QR or use override)');
  
  console.log('Starting BLE connection with UUID:', svcUUID);
  
  // Check if Web Bluetooth is supported
  if (!navigator.bluetooth) {
    throw new Error('Web Bluetooth not supported in this browser');
  }
  
  // Request device
  device = await navigator.bluetooth.requestDevice({ 
    filters: [{ services: [svcUUID] }], 
    optionalServices: [svcUUID] 
  });
  console.log('Device selected:', device);
  log(`Device selected: ${device.name || '(unnamed)'} (${device.id})`);
  
  // Setup disconnect handler
  device.addEventListener('gattserverdisconnected', () => {
    log('📱 Wallet disconnected from reader.');
    console.log('GATT server disconnected');
    
    // Reset connection state
    server = service = chState = chC2S = chS2C = null;
    
    log('💡 To continue, scan QR code again.');
  });
  
  console.log('Attempting GATT connection...');
  log(`Connecting to ${device.name || '(unnamed)'}…`);
  
  server = await device.gatt.connect();
  console.log('GATT connected, server:', server);
  log('GATT connected successfully');
  
  console.log('Getting primary service:', svcUUID);
  service = await server.getPrimaryService(svcUUID);
  console.log('Service found:', service);
  log('Service found');
  
  console.log('Getting characteristics...');
  chState = await service.getCharacteristic(UUIDS.state);
  console.log('State characteristic found:', chState);
  
  chC2S = await service.getCharacteristic(UUIDS.c2s);
  console.log('C2S characteristic found:', chC2S);
  
  chS2C = await service.getCharacteristic(UUIDS.s2c);
  console.log('S2C characteristic found:', chS2C);
  
  log('All characteristics found');
  
  console.log('Starting notifications...');
  await chS2C.startNotifications();
  chS2C.addEventListener('characteristicvaluechanged', handleServer2Client);
  console.log('Notifications started successfully');
  log('GATT ready. Notifications enabled.');
  
  console.log('⏸️ Session key derivation postponed until after SessionEstablishment response');
}

// Automated connection and session establishment flow
async function autoConnectFlow() {
  try {
    // Step 1: Connect to wallet
    if (!device || !server || !service) {
      log('📱 Connecting to wallet...');
      await bleConnect();
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait for connection to stabilize
    }
    
    // Step 2: Start session (state 0x01)
    if (chState) {
      log('🎬 Starting session (state 0x01)...');
      await writeState(0x01);
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // Step 3: Send SessionEstablishment
    log('🔐 Sending SessionEstablishment...');
    
    // Reset session state
    _readerCoseKeyCached = null;
    skReader = null;
    skDevice = null;
    sessionKey = null;
    transcriptAAD = null;
    walletEphemeralKey = null;
    sessionEstablished = false;
    window.sessionEstablished = false;

    // Generate ephemeral key pair
    readerKeyPair = await makeReaderEphemeralKeyPair();
    await exportReaderPublicToCoseKey();
    log('✅ Generated ephemeral key pair');
    
    // Build SessionTranscript immediately (needed for reader authentication)
    // SessionTranscript = [DeviceEngagement, EReaderKey, Handover]
    // All components are now available:
    //  - DeviceEngagement (deBytes) from QR scan
    //  - EReaderKey (readerKeyPair) just generated
    //  - Handover (null for BLE)
    console.log('Building SessionTranscript for reader authentication...');
    transcriptAAD = await buildTranscriptAAD();
    console.log('✅ SessionTranscript built, length:', transcriptAAD.length, 'bytes');
    
    // Build and send SessionEstablishment message
    const legacyMessage = await buildLegacySessionEstablishmentWithData();
    console.log('SessionEstablishment message length:', legacyMessage.length);
    await sendFragmented(legacyMessage);
    
    log('📤 SessionEstablishment sent (includes encrypted document request).');
    
    // Note: The wallet will first respond with SessionEstablishment response (to finalize session keys)
    // Then it will send DeviceResponse with the actual documents
    log('⏳ Waiting for wallet to process request...');
    log('� You may need to approve data sharing in your wallet app');
    
  } catch (error) {
    console.error('Auto-connect flow error:', error);
    log(`❌ Auto-connect failed: ${error.message}`);
  }
}

btnParseQr.addEventListener('click', () => handleQrPayload(qrInput.value, 'manual input'));
btnClearQr.addEventListener('click', () => {
  qrInput.value = '';
  statusEl.textContent = 'Idle';
  qrInput.focus();
});

qrInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    handleQrPayload(qrInput.value, 'manual input');
  }
});

// ==== IACA Management Event Listeners ====
btnAddIaca.addEventListener('click', () => {
  const pem = iacaInput.value.trim();
  const isTest = document.getElementById('iacaIsTest').checked;
  
  if (!pem) {
    alert('Please paste a PEM certificate');
    return;
  }
  
  if (!pem.includes('-----BEGIN CERTIFICATE-----')) {
    alert('Invalid PEM format. Certificate must start with "-----BEGIN CERTIFICATE-----"');
    return;
  }
  
  try {
    const added = addIACA(pem, null, isTest);
    log(`✅ Added IACA: ${added.name}${isTest ? ' (test)' : ''}`);
    iacaInput.value = '';
    document.getElementById('iacaIsTest').checked = false;
    updateIACAList();
    alert(`Certificate added successfully:\n${added.name}${isTest ? '\n⚠️ Marked as test/development certificate' : ''}`);
  } catch (e) {
    console.error('Failed to add IACA:', e);
    alert(`Failed to add certificate:\n${e.message}`);
  }
});

btnClearIacaInput.addEventListener('click', () => {
  iacaInput.value = '';
  document.getElementById('iacaIsTest').checked = false;
  iacaInput.focus();
});

// Initialize IACA list on page load
updateIACAList();

// ==== Robust mdoc URI → CBOR extraction helpers ====
function b64ToBytesBrowserSafe(b64) {
  b64 = b64.replace(/\s+/g, '').replace(/[^A-Za-z0-9+/=]/g, '');
  const pad = b64.length % 4 === 0 ? 0 : (4 - (b64.length % 4));
  b64 += '='.repeat(pad);
  const raw = atob(b64);
  const out = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
  return out;
}
function b64urlToBytesSafe(maybeB64Url) {
  let s = maybeB64Url.trim();
  try { s = decodeURIComponent(s); } catch (_) {}
  s = s.replace(/-/g, '+').replace(/_/g, '/');
  return b64ToBytesBrowserSafe(s);
}
function looksLikeHex(s) {
  const cleaned = s.replace(/[\s:]/g, '');
  return cleaned.length >= 2 && /^[0-9A-Fa-f]+$/.test(cleaned);
}
function hexToBytes(s) {
  const cleaned = s.replace(/[\s:]/g, '');
  const out = new Uint8Array(cleaned.length / 2);
  for (let i = 0; i < cleaned.length; i += 2) out[i/2] = parseInt(cleaned.substr(i, 2), 16);
  return out;
}
function extractCborFromMdocUri(uri) {
  console.log('Extracting CBOR from URI:', uri);
  let s = uri.trim();
  const schemeMatch = s.match(/^[A-Za-z]+:/);
  if (schemeMatch) {
    console.log('Found scheme:', schemeMatch[0]);
    s = s.slice(schemeMatch[0].length);
  }
  console.log('After scheme removal:', s);

  if (/^data:application\/cbor;base64,/i.test(s)) {
    console.log('Detected data URI format');
    const b64 = s.split(',')[1] || '';
    console.log('Base64 part:', b64);
    const result = b64ToBytesBrowserSafe(b64);
    console.log('Decoded bytes from data URI:', hex(result));
    return result;
  }
  
  const qm = s.indexOf('?');
  if (qm >= 0) {
    console.log('Found query parameters at position:', qm);
    const params = new URLSearchParams(s.slice(qm + 1));
    console.log('Query parameters:', [...params.entries()]);
    const cand = params.get('de') || params.get('data') || params.get('ep');
    if (!cand) throw new Error('mdoc URI has query but no DE param');
    console.log('Found DE parameter:', cand);
    if (looksLikeHex(cand)) {
      console.log('DE parameter looks like hex');
      const result = hexToBytes(cand);
      console.log('Decoded bytes from hex:', hex(result));
      return result;
    }
    console.log('DE parameter looks like base64url');
    const result = b64urlToBytesSafe(cand);
    console.log('Decoded bytes from base64url:', hex(result));
    return result;
  }
  
  if (/[;,]/.test(s)) {
    console.log('Found semicolon/comma separators');
    const parts = s.split(/[;,]/).map(p => p.trim()).filter(Boolean).sort((a,b)=>b.length-a.length);
    console.log('Split parts:', parts);
    for (const part of parts) {
      try {
        console.log('Trying part:', part);
        const sub = part.replace(/^(de2?|ep|data):/i, '');
        console.log('After prefix removal:', sub);
        if (looksLikeHex(sub)) {
          console.log('Part looks like hex');
          const result = hexToBytes(sub);
          console.log('Decoded bytes from hex part:', hex(result));
          return result;
        }
        console.log('Part looks like base64url');
        const result = b64urlToBytesSafe(sub);
        console.log('Decoded bytes from base64url part:', hex(result));
        return result;
      } catch (e) {
        console.log('Failed to decode part:', part, e.message);
      }
    }
  }
  
  console.log('Trying final fallback methods...');
  try {
    if (looksLikeHex(s)) {
      console.log('URI looks like hex');
      const result = hexToBytes(s);
      console.log('Decoded bytes from hex URI:', hex(result));
      return result;
    }
    console.log('URI looks like base64url');
    const result = b64urlToBytesSafe(s); // your QR style: everything after "mdoc:"
    console.log('Decoded bytes from base64url URI:', hex(result));
    return result;
  } catch (e) {
    console.log('Fallback methods failed:', e.message);
    const m = uri.match(/[A-Za-z0-9\-_]{20,}={0,2}/);
    if (m) {
      console.log('Found potential base64 match:', m[0]);
      const result = b64urlToBytesSafe(m[0]);
      console.log('Decoded bytes from regex match:', hex(result));
      return result;
    }
    throw new Error('Unable to locate/normalize CBOR payload in mdoc URI');
  }
}

function tryExtractBleOptions(root) {
  // Helpers
  const isUUIDStr = (s) => typeof s === 'string' &&
    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(s);

  const asUuidString = (bytes) => {
    if (!(bytes instanceof Uint8Array) || bytes.length !== 16) return null;
    const h = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('');
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  };

  const takeFirst = (found) => {
    if (found.uuidStr) return { uuidStr: found.uuidStr.toLowerCase(), uuidBytes: null, addrBytes: found.addrBytes || null };
    if (found.uuidBytes) return { uuidBytes: found.uuidBytes, uuidStr: null, addrBytes: found.addrBytes || null };
    return null;
  };

  // Accumulator for what we find while walking
  const found = { uuidBytes: null, uuidStr: null, addrBytes: null };

  // Read "options" of a BLE method (accept Maps with int keys or plain objects)
  function readBleOptions(opts) {
    if (!opts) return;
    const scanKV = (k, v) => {
      // Numeric labels from drafts: 
      // 10 = service UUID (bstr 16); 11 = service UUID (alternative); 20 = BLE device address (bstr)
      if ((k === 10 || k === 11 || k === 'uuid' || k === 'serviceUuid' || k === 'service_uuid') && v) {
        if (!found.uuidBytes && v instanceof Uint8Array && v.length === 16) found.uuidBytes = v;
        if (!found.uuidStr  && isUUIDStr(v)) found.uuidStr = v;
      }
      if ((k === 20 || k === 'bleDeviceAddress' || k === 'address' || k === 'mac' || k === 'addr') && v instanceof Uint8Array) {
        if (!found.addrBytes) found.addrBytes = v;
      }
      // Some vendors nest { uuid: <bstr> } under another map
      if (v && typeof v === 'object') {
        if (v instanceof Map) {
          for (const [kk, vv] of v.entries()) scanKV(kk, vv);
        } else {
          for (const kk of Object.keys(v)) scanKV(kk, v[kk]);
        }
      }
    };

    if (opts instanceof Map) {
      for (const [k, v] of opts.entries()) scanKV(k, v);
    } else if (typeof opts === 'object') {
      for (const k of Object.keys(opts)) scanKV(k, opts[k]);
    }
  }

  // Decide whether a node is a BLE "method"
  function isBleMethod(node) {
    if (!node) return false;

    // Numeric code under key 0 or 'type': 2 = BLE in many drafts
    const typeNum = node instanceof Map ? (node.has(0) ? node.get(0) : (node.get('type') ?? node.get('t'))) :
                    (typeof node === 'object' ? (node.type ?? node.t ?? node[0]) : undefined);
    if (typeNum === 2) return true;

    // String fallback (transport/method fields)
    const getStr = (k) => {
      if (node instanceof Map) return (node.get(k) ?? '').toString().toLowerCase();
      if (typeof node === 'object') return (node[k] ?? '').toString().toLowerCase();
      return '';
    };
    const tstr = [getStr('transport'), getStr('method'), getStr('type')].join(' ');
    return ['ble','bluetooth','bluetoothle','gatt'].some(s => tstr.includes(s));
  }

  // For a method node, try to locate its "options" (common labels: 2, or "options", or nested "peripheral/server")
  function getMethodOptions(node) {
    if (!node) return null;
    if (node instanceof Map) {
      // numeric '2' is often used for options in draft encodings
      if (node.has(2)) return node.get(2);
      if (node.has('options')) return node.get('options');
      // try common nests
      return node.get('peripheral') || node.get('server') || node.get('central') || null;
    } else if (typeof node === 'object') {
      return node[2] || node.options || node.peripheral || node.server || node.central || null;
    }
    return null;
  }

  // DFS over any shape (Arrays, Maps, Objects)
  function dfs(node) {
    if (!node) return;
    
    // If this node itself looks like a BLE method, read its options immediately
    if (isBleMethod(node)) {
      readBleOptions(getMethodOptions(node));
      if (takeFirst(found)) return; // we've got enough
    }

    // Special handling for array patterns like [2, 1, {...options...}]
    if (Array.isArray(node) && node.length >= 3 && node[0] === 2) {
      // This looks like a BLE method: [type=2, param, options]
      readBleOptions(node[2]);
      if (takeFirst(found)) return;
    }

    if (Array.isArray(node)) {
      for (const it of node) dfs(it);
      return;
    }
    if (node instanceof Map) {
      for (const [k, v] of node.entries()) {
        // FIXED: Some DEs put "deviceRetrievalMethods" under key 1, 2, or string
        if (k === 1 || k === 2 || k === 'deviceRetrievalMethods' || k === 'methods' || k === 'transports') {
          dfs(v);
        } else {
          dfs(v);
        }
      }
      return;
    }
    if (typeof node === 'object') {
      for (const k of Object.keys(node)) {
        dfs(node[k]);
      }
    }
  }

  dfs(root);

  return takeFirst(found); // {uuidBytes|uuidStr, addrBytes} or null
}


const asUuidString = (bytes) => {
  if (!(bytes instanceof Uint8Array) || bytes.length !== 16) return null;
  const h = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
};

// ==== Parse mdoc URI + Device Engagement ====
function parseMdocUriAndDE(uri) {
  mdocUriEl.textContent = uri;
  console.log('Original URI:', uri);
  
  try {
    deBytes = extractCborFromMdocUri(uri);
    console.log('Extracted CBOR bytes:', hex(deBytes));
    console.log('CBOR bytes length:', deBytes.length);
  } catch (e) {
    console.error('Failed to extract CBOR from URI:', e);
    throw e;
  }

  // Decode CBOR; allow tag(24)-wrapped CBOR as fallback
  let de;
  try {
    console.log('Attempting first CBOR decode...');
    de = CBOR.decode(deBytes);
    console.log('First decode successful:', de);
  } catch (firstError) {
    console.log('First decode failed:', firstError.message);
    try {
      console.log('Attempting fallback decode...');
      const maybe = CBOR.decode(deBytes);
      console.log('Fallback intermediate result:', maybe);
      if (maybe instanceof CBOR.Tagged && maybe.tag === 24 && maybe.value instanceof Uint8Array) {
        console.log('Found tag(24), decoding inner value...');
        de = CBOR.decode(maybe.value);
        console.log('Tag(24) decode successful:', de);
      } else {
        console.error('Unexpected fallback structure:', maybe);
        throw new Error('CBOR decode failed for Device Engagement');
      }
    } catch (secondError) {
      console.error('Both decode attempts failed:', firstError, secondError);
      throw new Error('CBOR decode failed for Device Engagement: ' + firstError.message);
    }
  }

  // BLE options
  const bo = tryExtractBleOptions(de);
  if (!bo) throw new Error('BLE options not found in Device Engagement');

  let uuid = null;
  if (bo.uuidStr) uuid = bo.uuidStr;
  else if (bo.uuidBytes) uuid = asUuidString(bo.uuidBytes);

  let addr = null;
  if (bo.addrBytes) addr = Array.from(bo.addrBytes).map(b=>b.toString(16).padStart(2,'0')).join(':');

  // mdoc ephemeral COSE_Key (EC2 P-256 x/y)
  console.log('Device Engagement structure:', de);
  let coseKey = null;
  
  // ISO 18013-5: Security element can contain:
  // - Field 3: mdoc authentication public key (for signatures)
  // - Field 33: mdoc ephemeral public key eSenderKey (for ECDH) <-- WE NEED THIS ONE
  
  // Check if de.security is an array (as per spec)
  if (Array.isArray(de?.security)) {
    console.log('📋 DeviceEngagement.security is an array with', de.security.length, 'element(s)');
    
    // Look for the Security element containing field 33 (eSenderKey)
    for (let i = 0; i < de.security.length; i++) {
      const sec = de.security[i];
      console.log(`  Security[${i}]:`, sec);
      
      if (sec instanceof Map) {
        console.log(`    Field 3 (auth key):`, sec.has(3) ? 'present' : 'absent');
        console.log(`    Field 33 (eSenderKey):`, sec.has(33) ? 'present' : 'absent');
        
        // Prefer field 33 (eSenderKey for ECDH)
        if (sec.has(33)) {
          coseKey = sec.get(33);
          console.log('✅ Using field 33 (eSenderKey) for ECDH from Security[' + i + ']');
          break;
        }
      } else if (typeof sec === 'object') {
        console.log(`    Field 3 (auth key):`, (3 in sec) ? 'present' : 'absent');
        console.log(`    Field 33 (eSenderKey):`, (33 in sec) ? 'present' : 'absent');
        
        // Prefer field 33 (eSenderKey for ECDH)
        if (33 in sec) {
          coseKey = sec[33];
          console.log('✅ Using field 33 (eSenderKey) for ECDH from Security[' + i + ']');
          break;
        }
      }
    }
    
    // Fallback: if no field 33, try field 3 (but log a warning)
    if (!coseKey) {
      for (let i = 0; i < de.security.length; i++) {
        const sec = de.security[i];
        if (sec instanceof Map && sec.has(3)) {
          coseKey = sec.get(3);
          console.warn('⚠️ Using field 3 (auth key) as fallback - this might be wrong!');
          break;
        } else if (typeof sec === 'object' && (3 in sec)) {
          coseKey = sec[3];
          console.warn('⚠️ Using field 3 (auth key) as fallback - this might be wrong!');
          break;
        }
      }
    }
  } else if (de?.security) {
    console.log('📋 DeviceEngagement.security is NOT an array, it is:', typeof de.security);
    const sec = de.security;
    
    if (sec instanceof Map) {
      console.log('  Field 3 (auth key):', sec.has(3) ? 'present' : 'absent');
      console.log('  Field 33 (eSenderKey):', sec.has(33) ? 'present' : 'absent');
      
      if (sec.has(33)) {
        coseKey = sec.get(33);
        console.log('✅ Using field 33 (eSenderKey) for ECDH');
      } else if (sec.has(3)) {
        coseKey = sec.get(3);
        console.warn('⚠️ Using field 3 (auth key) as fallback - this might be wrong!');
      }
    } else if (typeof sec === 'object') {
      console.log('  Field 3 (auth key):', (3 in sec) ? 'present' : 'absent');
      console.log('  Field 33 (eSenderKey):', (33 in sec) ? 'present' : 'absent');
      
      if (33 in sec) {
        coseKey = sec[33];
        console.log('✅ Using field 33 (eSenderKey) for ECDH');
      } else if (3 in sec) {
        coseKey = sec[3];
        console.warn('⚠️ Using field 3 (auth key) as fallback - this might be wrong!');
      }
    }
  }
  
  // Old fallback code (if security not found at all)
  if (!coseKey && de?.security?.deviceKey) coseKey = de.security.deviceKey;
  if (!coseKey && de?.eDeviceKey) coseKey = de.eDeviceKey;
  if (!coseKey && de?.deviceKey)  coseKey = de.deviceKey;
  
  // Check for COSE_Key wrapped in CBOR tag(24)
  if (!coseKey) {
    console.log('Searching for COSE_Key in DE structure...');
    const scan = (o, path = '') => {
      if (!o) return null;
      
      // Check if this is a CBOR Tagged value that might contain a COSE_Key
      if (o instanceof CBOR.Tagged && o.tag === 24 && o.value instanceof Uint8Array) {
        console.log(`Found CBOR tag(24) at path: ${path}, attempting to decode...`);
        try {
          const decoded = CBOR.decode(o.value);
          console.log(`Decoded tag(24) content:`, decoded);
          
          // Check if the decoded content is a COSE_Key
          if (decoded instanceof Map) {
            if (decoded.get(1)===2 && decoded.get(-1)===1 && decoded.get(-2) && decoded.get(-3)) {
              console.log('Found COSE_Key inside tag(24) at path:', path);
              return decoded;
            }
          } else if (typeof decoded === 'object' && decoded[1]===2 && decoded[-1]===1 && decoded[-2] && decoded[-3]) {
            console.log('Found COSE_Key inside tag(24) at path:', path);
            return decoded;
          }
        } catch (e) {
          console.log(`Failed to decode tag(24) at ${path}:`, e.message);
        }
      }
      
      if (o instanceof Map) {
        // Check if this map is a COSE_Key (kty=2, crv=1, x=-2, y=-3)
        if (o.get(1)===2 && o.get(-1)===1 && o.get(-2) && o.get(-3)) {
          console.log('Found COSE_Key at path:', path);
          return o;
        }
        
        for (const [k, v] of o.entries()) { 
          const r = scan(v, `${path}.Map[${k}]`); 
          if (r) return r; 
        }
      } else if (typeof o === 'object' && !Array.isArray(o)) {
        // Check if this object is a COSE_Key
        if (o[1]===2 && o[-1]===1 && o[-2] && o[-3]) {
          console.log('Found COSE_Key at path:', path);
          return o;
        }
        
        for (const [k, v] of Object.entries(o)) { 
          const r = scan(v, `${path}.${k}`); 
          if (r) return r; 
        }
      } else if (Array.isArray(o)) {
        for (let i = 0; i < o.length; i++) { 
          const r = scan(o[i], `${path}[${i}]`); 
          if (r) return r; 
        }
      }
      return null;
    };
    coseKey = scan(de);
  }
  
  if (!coseKey) {
    console.error('COSE_Key not found. Full DE structure:', JSON.stringify(de, null, 2));
    throw new Error('mdoc ephemeral COSE_Key not found in DE');
  }
  
  console.log('Found COSE_Key:', coseKey);

  const getField = (k) => (coseKey instanceof Map ? coseKey.get(k) : coseKey[k]);
  
  // Log ALL fields in the COSE_Key
  console.log('📋 COSE_Key field analysis:');
  console.log('   kty (1):', getField(1), '(should be 2 for EC2)');
  console.log('   crv (-1):', getField(-1), '(should be 1 for P-256)');
  console.log('   alg (3):', getField(3), '(algorithm, if present)');
  
  const xField = getField(-2) || getField('x');
  const yField = getField(-3) || getField('y');
  
  console.log('🔍 Raw COSE_Key fields before extraction:');
  console.log('  Field -2 (x):', xField);
  console.log('  Field -3 (y):', yField);
  console.log('  Field -2 type:', Object.prototype.toString.call(xField));
  console.log('  Field -3 type:', Object.prototype.toString.call(yField));
  
  const x = new Uint8Array(xField);
  const y = new Uint8Array(yField);
  
  console.log('Extracted mdoc public key coordinates (eSenderKey from wallet):');
  console.log('  x (should be 32 bytes):', hex(x), `(length: ${x.length})`);
  console.log('  y (should be 32 bytes):', hex(y), `(length: ${y.length})`);
  
  if (x.length !== 32 || y.length !== 32) {
    console.error('❌ Invalid key coordinate lengths:', x.length, y.length);
    throw new Error(`Invalid COSE_Key coordinates: x=${x.length}, y=${y.length} (expected 32 each)`);
  }
  
  mdocPubKey = { x, y };
  console.log('✅ mdoc public key stored successfully');

  return { uuid, addr };
}

// ==== Session Establishment (ECDH + HKDF, Transcript AAD) ====
async function importMdocPubKeyXY(x, y) {
  const u = new Uint8Array(1 + x.length + y.length);
  u[0] = 0x04; u.set(x,1); u.set(y,1+x.length);
  return crypto.subtle.importKey('raw', u, { name:'ECDH', namedCurve:'P-256' }, true, []);
}
async function makeReaderEphemeralKeyPair() {
  return crypto.subtle.generateKey({ name:'ECDH', namedCurve:'P-256' }, true, ['deriveBits']);
}
async function deriveSharedSecretBits(privKey, pubKey) {
  console.log('🔐 ECDH Key Agreement:');
  console.log('  Private key type:', privKey.type);
  console.log('  Public key type:', pubKey.type);
  
  // Export public key to verify it matches what we expect (only public keys can be exported as raw)
  try {
    const pubKeyRaw = new Uint8Array(await crypto.subtle.exportKey('raw', pubKey));
    console.log('  Public key (raw, 65 bytes):', hex(pubKeyRaw));
    console.log('  Public key X:', hex(pubKeyRaw.slice(1, 33)));
    console.log('  Public key Y:', hex(pubKeyRaw.slice(33, 65)));
  } catch (e) {
    console.log('  Public key export not available (might be non-extractable)');
  }
  
  const sharedSecret = await crypto.subtle.deriveBits({ name:'ECDH', public: pubKey }, privKey, 256);
  console.log('  Shared secret (32 bytes):', hex(new Uint8Array(sharedSecret)));
  console.log('  Shared secret (base64):', btoa(String.fromCharCode(...new Uint8Array(sharedSecret))));
  
  return sharedSecret;
}
async function hkdfExtract(saltBytes, ikmBytes) {
  // HKDF-Extract: PRK = HMAC-Hash(salt, IKM)
  // Use HMAC directly, not WebCrypto's HKDF (which does extract+expand together)
  const key = await crypto.subtle.importKey('raw', saltBytes, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const prk = await crypto.subtle.sign('HMAC', key, ikmBytes);
  return new Uint8Array(prk);
}
async function hkdfExpand(prkBytes, infoBytes, length) {
  const prk = await crypto.subtle.importKey('raw', prkBytes, { name:'HMAC', hash:'SHA-256' }, false, ['sign']);
  let t = new Uint8Array(0), okm = new Uint8Array(0), counter = 1;
  while (okm.length < length) {
    const input = concatUint8(t, infoBytes, Uint8Array.of(counter));
    const mac = new Uint8Array(await crypto.subtle.sign('HMAC', prk, input));
    okm = concatUint8(okm, mac);
    t = mac; counter++;
  }
  return okm.slice(0, length);
}
async function sha256(bytes) {
  return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes));
}

let _readerCoseKeyCached = null;
function buildReaderCoseKey() {
  if (!_readerCoseKeyCached) throw new Error('reader COSE_Key not ready');
  return _readerCoseKeyCached; // Map with integer labels
}
async function exportReaderPublicToCoseKey() {
  const raw = new Uint8Array(await crypto.subtle.exportKey('raw', readerKeyPair.publicKey)); // 0x04||X||Y
  const x = raw.slice(1, 33);
  const y = raw.slice(33, 65);
  
  // Create a unique fingerprint for this key
  const fingerprint = hex(x.slice(0, 4));
  
  console.log('📤 [CACHE] Caching EReaderKey - fingerprint:', fingerprint);
  console.log('  [CACHE] X coordinate:', hex(x));
  console.log('  [CACHE] Y coordinate:', hex(y));
  
  // Store as Map - we'll handle encoding specially to avoid tag 64
  _readerCoseKeyCached = new Map([
    [  1, 2],  // kty: EC2
    [ -1, 1],  // crv: P-256  
    [ -2, x],  // x coordinate (Uint8Array)
    [ -3, y]   // y coordinate (Uint8Array)
  ]);
  
  console.log('[CACHE] Successfully cached EReaderKey with fingerprint:', fingerprint);
  return fingerprint; // Return for tracking
}


// Build transcript AAD: hash( [ DeviceEngagementBytes, EReaderKeyBytes, Handover ] )
async function buildTranscriptAAD() {
  console.log('=== BUILDING TRANSCRIPT AAD ===');
  
  if (!deBytes) {
    console.error('❌ DeviceEngagement bytes not available');
    throw new Error('DeviceEngagement bytes required for transcript AAD');
  }
  
  // Build EReaderKeyBytes = tag(24, bstr .cbor COSE_Key)
  const readerCoseKey = buildReaderCoseKey();
  
  // LOG: Verify which key we're using in transcript
  const keyX = readerCoseKey.get(-2);
  const keyY = readerCoseKey.get(-3);
  const fingerprint = hex(keyX.slice(0, 4));
  console.log('🔑 [Transcript] Using EReaderKey - fingerprint:', fingerprint);
  console.log('   [Transcript] X:', hex(keyX));
  console.log('   [Transcript] Y:', hex(keyY));
  
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  const eReaderKeyBytes = encodeTag24ByteString(coseKeyEncoded);
  
  console.log('EReaderKeyBytes:', hex(eReaderKeyBytes));
  
  // Manually build the transcript array to avoid any CBOR library issues
  // SessionTranscript (HKDF salt) = [DeviceEngagementBytes, EReaderKeyBytes, Handover]
  // Per ISO 18013-5: Handover is third; both sides must agree for key derivation
  
  // 🔍 MULTIPAZ CONFIRMED: Uses tag(24) wrapped COSE_Keys inside SessionTranscript
  // Then wraps the whole thing in tag(24, bstr(...)) before hashing
  const useUnwrappedKeys = false;  // Keep tag(24) wrappers on COSE_Keys
  
  const result = [];
  
  // Array with 3 items
  result.push(0x83);
  
  if (useUnwrappedKeys) {
    // Item 1: DeviceEngagement COSE_Key (unwrapped - no tag 24)
    result.push(...deBytes);
    // Item 2: EReaderKey COSE_Key (unwrapped - no tag 24)
    result.push(...coseKeyEncoded);
    // Item 3: Handover (QR) = null
    result.push(0xF6);
  } else {
    // tag(24, DeviceEngagementBytes)
    result.push(0xD8, 0x18);
    if (deBytes.length < 24) {
      result.push(0x40 + deBytes.length);
    } else if (deBytes.length < 256) {
      result.push(0x58, deBytes.length);
    } else {
      result.push(0x59, deBytes.length >> 8, deBytes.length & 0xFF);
    }
    result.push(...deBytes);
    // EReaderKeyBytes (already contains tag 24)
    result.push(...eReaderKeyBytes);
    // Handover (QR) = null
    result.push(0xF6);
  }
  
  console.log('🔐 Using QRHandover (null) - engagement was via QR code');
  console.log(useUnwrappedKeys ? '🧪 SessionTranscript (HKDF): [DeviceEngagement (unwrapped), EReaderKey (unwrapped), null]' : 'SessionTranscript (HKDF): [DeviceEngagement, EReaderKey, null]');
  
  const trCbor = new Uint8Array(result);
  console.log('Transcript CBOR length (unwrapped):', trCbor.length);
  console.log('Transcript CBOR (full):', hex(trCbor));
  console.log('🔍 Using unwrapped COSE_Keys (no tag 24):', useUnwrappedKeys);
  
  // Verify by decoding
  try {
  const decoded = CBOR.decode(trCbor);
    console.log('Transcript decoded (verification):', decoded);
  } catch (e) {
    console.error('Failed to decode transcript:', e);
  }
  
  // Per ISO 18013-5 Section 9.1.5.2:
  // SessionTranscriptBytes is the CBOR encoding of SessionTranscript
  // Salt = SHA-256(SessionTranscriptBytes)
  
  // 🔍 MULTIPAZ EXPECTS: tag(24, bstr(SessionTranscript)) before hashing!
  // This is what Multipaz does: Cbor.encode(Tagged(24, Bstr(encodedSessionTranscript)))
  const wrappedTranscript = encodeTag24ByteString(trCbor);
  
  console.log('🔍 SessionTranscript for hashing (WRAPPED in tag 24 bstr):');
  console.log('Unwrapped length:', trCbor.length);
  console.log('Unwrapped hex:', hex(trCbor));
  console.log('Unwrapped base64:', btoa(String.fromCharCode(...trCbor)));
  console.log('Wrapped length:', wrappedTranscript.length);
  console.log('Wrapped hex:', hex(wrappedTranscript));
  console.log('Wrapped base64:', btoa(String.fromCharCode(...wrappedTranscript)));
  
  // Store for debugging
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.sessionTranscript = trCbor;
  window.sessionDebug.sessionTranscriptWrapped = wrappedTranscript;
  window.sessionDebug.deviceEngagement = deBytes;
  window.sessionDebug.eReaderKey = useUnwrappedKeys ? coseKeyEncoded : eReaderKeyBytes;
  window.sessionDebug.useUnwrappedKeys = useUnwrappedKeys;
  
  const aad = await sha256(wrappedTranscript);
  console.log('Transcript AAD (SHA-256 of tag(24, bstr(SessionTranscript))):', hex(aad));
  console.log('✅ Transcript AAD built successfully');
  console.log('  SessionTranscript unwrapped (base64):', btoa(String.fromCharCode(...trCbor)));
  console.log('  SessionTranscript wrapped tag(24,bstr) (base64):', btoa(String.fromCharCode(...wrappedTranscript)));
  console.log('  Transcript Hash (hex):', hex(aad));
  
  return aad;
}

// Derive session keys per ISO 18013-5 standard
// Per spec Section 9.1.5.2:
// - Salt = SHA-256(SessionTranscriptBytes)
// - IKM = ZAB (shared secret from ECDH)
// - Info = "SKReader" or "SKDevice" (UTF-8 encoded)
// - L = 32 octets (for AES-256)
async function deriveSessionKey(sharedSecret, transcriptHash) {
  console.log('🔐 Starting session key derivation (ISO 18013-5):');
  console.log('- Shared secret (ZAB) length:', sharedSecret.length);
  console.log('- Shared secret (hex):', hex(sharedSecret));
  console.log('- Shared secret (base64):', btoa(String.fromCharCode(...sharedSecret)));
  console.log('- Salt (SessionTranscript hash) length:', transcriptHash.length);
  console.log('- Salt (hex):', hex(transcriptHash));
  
  // HKDF-Extract: PRK = HKDF-Extract(salt, IKM)
  // salt = SHA-256(SessionTranscriptBytes)
  // IKM = shared secret (ZAB)
  const prk = await hkdfExtract(transcriptHash, sharedSecret);
  
  // HKDF-Expand for SKReader: info = "SKReader" (UTF-8)
  const readerInfo = enc.encode('SKReader');
  const readerKey = await hkdfExpand(prk, readerInfo, 32);  // 32 bytes for A256GCM
  
  // HKDF-Expand for SKDevice: info = "SKDevice" (UTF-8)
  const deviceInfo = enc.encode('SKDevice'); 
  const deviceKey = await hkdfExpand(prk, deviceInfo, 32);  // 32 bytes for A256GCM
  
  console.log('🔐 ISO 18013-5 key derivation (AES-256-GCM):');
  console.log('- SKReader (32 bytes):', hex(readerKey));
  console.log('- SKReader (base64):', btoa(String.fromCharCode(...readerKey)));
  console.log('- SKDevice (32 bytes):', hex(deviceKey));
  console.log('- SKDevice (base64):', btoa(String.fromCharCode(...deviceKey)));
  console.log();

  // Expose for debugging/inspection in devtools (non-production)
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.skReader = readerKey;
  window.sessionDebug.skDevice = deviceKey;
  window.sessionDebug.transcriptHash = transcriptHash;
  
  // CRITICAL: Return BOTH keys as object
  // Reader encrypts requests with SKReader
  // Reader decrypts responses with SKDevice
  return { readerKey, deviceKey };
}

// ==== Raw AES-256-GCM Encryption (for SessionEstablishment.data field) ====
// Per ISO 18013-5 Section 9.1.1.4, SessionEstablishment.data field is:
// "concatenation of the ciphertext and all 16 bytes of the authentication tag"
// This is RAW output from AES-GCM, NOT wrapped in COSE_Encrypt0 structure
//
// CRITICAL: AAD must be EMPTY per ISO 18013-5 Section 9.1.5.2:
// "The AAD used with the AES-GCM function shall be an empty string"
async function aesGcmEncryptRaw(plaintext, keyBytes, identifier8, messageCounter = 1) {
  console.log('=== RAW AES-256-GCM ENCRYPTION (for SessionEstablishment.data) ===');
  console.log('Plaintext length:', plaintext.length);
  console.log('Key length:', keyBytes.length, 'bytes (should be 32 for A256GCM)');
  console.log('Message counter:', messageCounter);
  
  // Build IV per ISO 18013-5: identifier (8 bytes) || counter (4 bytes big-endian)
  const iv = new Uint8Array(12);
  iv.set(identifier8, 0);  // 8-byte identifier (0x00×8 for reader)
  iv[8] = (messageCounter >> 24) & 0xFF;
  iv[9] = (messageCounter >> 16) & 0xFF;
  iv[10] = (messageCounter >> 8) & 0xFF;
  iv[11] = messageCounter & 0xFF;
  
  console.log('IV (identifier || counter):', hex(iv));
  console.log('  - Identifier (8 bytes):', hex(identifier8));
  console.log('  - Counter (4 bytes BE):', hex(iv.slice(8, 12)), '=', messageCounter);
  
  // AAD for GCM shall be EMPTY per ISO 18013-5 Section 9.1.5.2
  // "The AAD used with the AES-GCM function shall be an empty string"
  const aad = new Uint8Array(0);
  console.log('AAD for AES-GCM: <EMPTY> (per ISO 18013-5 Section 9.1.5.2)');
  console.log('⚠️ Note: This is DIFFERENT from COSE_Encrypt0 which uses Enc_structure');
  
  const key = await crypto.subtle.importKey('raw', keyBytes, 
    { name: 'AES-GCM', length: 256 }, false, ['encrypt']);
  
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: aad, tagLength: 128 },
    key, plaintext
  );
  
  const result = new Uint8Array(encrypted);
  console.log('Raw encrypted length:', result.length, '(plaintext + 16-byte auth tag)');
  console.log('Raw encrypted (first 32 bytes):', hex(result.slice(0, 32)));
  console.log('✅ Returns: ciphertext || 16-byte authentication_tag (no COSE wrapper, no Enc_structure AAD)');
  
  return result;
}

// ==== COSE_Encrypt0 (AES-256-GCM per ISO 18013-5) ====
// CRITICAL: Per ISO 18013-5 Section 9.1.5.2:
// - IV = identifier (8 bytes) || message counter (4 bytes big-endian)
// - Reader identifier: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
// - Counter starts at 1 for first message
// - AAD for GCM function shall be EMPTY STRING
async function coseEncrypt0_AESGCM_Enc0(plaintext, externalAAD, keyBytes, messageCounter = 1) {
  console.log('=== COSE_Encrypt0 ENCRYPTION (ISO 18013-5) ===');
  console.log('Plaintext length:', plaintext.length);
  console.log('Key length:', keyBytes.length, 'bytes (should be 32 for A256GCM)');
  console.log('Message counter:', messageCounter);
  
  if (keyBytes.length !== 32) {
    console.warn('⚠️ WARNING: Key length is not 32 bytes - ISO 18013-5 requires AES-256-GCM');
  }
  
  // Build IV per ISO 18013-5: identifier (8 bytes) || counter (4 bytes big-endian)
  // Reader identifier: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
  const iv = new Uint8Array(12);
  // First 8 bytes are 0x00 (reader identifier)
  // Last 4 bytes are message counter in big-endian
  iv[8] = (messageCounter >> 24) & 0xFF;
  iv[9] = (messageCounter >> 16) & 0xFF;
  iv[10] = (messageCounter >> 8) & 0xFF;
  iv[11] = messageCounter & 0xFF;
  
  console.log('IV (identifier || counter):', hex(iv));
  console.log('  - Identifier (8 bytes):', hex(iv.slice(0, 8)));
  console.log('  - Counter (4 bytes BE):', hex(iv.slice(8, 12)), '=', messageCounter);
  
  // AAD for GCM shall be EMPTY per ISO 18013-5
  const aad = new Uint8Array(0);
  console.log('AAD for GCM: <empty> (per ISO 18013-5)');
  
  const key = await crypto.subtle.importKey('raw', keyBytes, { name:'AES-GCM' }, false, ['encrypt']);
  const ciphertext = new Uint8Array(
    await crypto.subtle.encrypt({ name:'AES-GCM', iv, additionalData: aad }, key, plaintext)
  );
  
  console.log('Ciphertext length:', ciphertext.length);
  console.log('Ciphertext (first 32 bytes):', hex(ciphertext.slice(0, 32)));

  // Capture IV/key usage for debugging from DevTools
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.lastEncrypt = {
    messageCounter,
    iv: iv.slice(),
    key: keyBytes.slice(),
    aad: externalAAD ? externalAAD.slice?.() || externalAAD : null,
    plaintextSample: plaintext.slice(0, 32)
  };
  
  // Build COSE_Encrypt0 structure per RFC 8152 and ISO 18013-5
  // MUST manually encode to avoid CBOR tag 64 being added to byte strings
  // Structure: [protected, unprotected, ciphertext]
  
  // 1. Protected header: bstr containing {1: 3} for A256GCM
  //    Manual encoding: 43 A1 01 03 = bstr(3) containing map {1: 3}
  const protectedHdr = new Uint8Array([0x43, 0xA1, 0x01, 0x03]);  // alg = 3 (A256GCM)
  console.log('Protected header (bstr with A256GCM):', hex(protectedHdr));
  
  // 2. Unprotected header: {5: iv} where iv is 12-byte bstr
  //    Manual encoding: A1 05 4C <12 bytes>
  const unprotectedHdr = new Uint8Array([
    0xA1,  // map(1)
    0x05,  // key = 5 (IV label)
    0x4C,  // bstr(12)
    ...iv
  ]);
  console.log('Unprotected header:', hex(unprotectedHdr));
  
  // 3. Ciphertext: bstr with length prefix
  let ciphertextEncoded;
  if (ciphertext.length < 24) {
    ciphertextEncoded = new Uint8Array([0x40 + ciphertext.length, ...ciphertext]);
  } else if (ciphertext.length < 256) {
    ciphertextEncoded = new Uint8Array([0x58, ciphertext.length, ...ciphertext]);
  } else {
    ciphertextEncoded = new Uint8Array([
      0x59,
      (ciphertext.length >> 8) & 0xFF,
      ciphertext.length & 0xFF,
      ...ciphertext
    ]);
  }
  console.log('Ciphertext encoded length:', ciphertextEncoded.length);
  
  // 4. Combine into COSE_Encrypt0 array: [protected, unprotected, ciphertext]
  const enc0 = new Uint8Array([
    0x83,  // array(3)
    ...protectedHdr,
    ...unprotectedHdr,
    ...ciphertextEncoded
  ]);
  
  console.log('Final COSE_Encrypt0 length:', enc0.length);
  console.log('COSE_Encrypt0 hex (first 50 bytes):', hex(enc0.slice(0, 50)));
  console.log('Expected format: 83 43 a1 01 03 a1 05 4c <12-byte IV> 59 ... <ciphertext>');
  console.log('Algorithm: A256GCM (alg=3) - 32-byte key');
  
  // Verify structure can be decoded
  try {
    const verify = CBOR.decode(enc0);
    if (!Array.isArray(verify) || verify.length !== 3) {
      throw new Error('Invalid COSE_Encrypt0 structure');
    }
    console.log('✅ COSE_Encrypt0 structure validation passed (AES-256-GCM)');
    console.log('✅ NO CBOR TAG 64 - manually encoded to ISO 18013-5 spec');
  } catch (e) {
    console.error('❌ COSE_Encrypt0 validation failed:', e.message);
    throw e;
  }
  
  return enc0;
}

// ==== Messages ====

// Custom CBOR encoder for COSE_Key to avoid tag 64 on byte strings
function encodeCoseKeyManually(coseKey) {
  // Manually build CBOR map: A4 (map with 4 items) + key-value pairs
  const result = [];
  
  // Map header: 0xA4 = map with 4 items
  result.push(0xA4);
  
  // Item 1: key=1 (kty), value=2 (EC2)
  result.push(0x01);  // positive int 1
  result.push(0x02);  // positive int 2
  
  // Item 2: key=-1 (crv), value=1 (P-256)
  result.push(0x20);  // negative int -1 (encoded as 0x20)
  result.push(0x01);  // positive int 1
  
  // Item 3: key=-2 (x), value=<32 bytes>
  const x = coseKey.get(-2);
  console.log('X coordinate type:', x.constructor.name, 'length:', x.length);
  console.log('X coordinate (hex):', hex(x));
  result.push(0x21);  // negative int -2 (encoded as 0x21)
  result.push(0x58, 0x20);  // byte string, length 32
  result.push(...x);
  
  // Item 4: key=-3 (y), value=<32 bytes>
  const y = coseKey.get(-3);
  console.log('Y coordinate type:', y.constructor.name, 'length:', y.length);
  console.log('Y coordinate (hex):', hex(y));
  result.push(0x22);  // negative int -3 (encoded as 0x22)
  result.push(0x58, 0x20);  // byte string, length 32
  result.push(...y);
  
  const encoded = new Uint8Array(result);
  console.log('Manual COSE_Key encoding (hex):', hex(encoded));
  console.log('Should be: A4 01 02 20 01 21 58 20 <x> 22 58 20 <y>');
  
  return encoded;
}

// Manually encode tag 24 wrapped byte string to avoid tag 64
function encodeTag24ByteString(data) {
  // Tag 24 (0xD8 0x18) + byte string header + data
  const result = [];
  
  // Tag 24: 0xD8 (tag follows) 0x18 (tag number 24)
  result.push(0xD8, 0x18);
  
  // Byte string with length
  if (data.length < 24) {
    result.push(0x40 + data.length);  // short byte string
  } else if (data.length < 256) {
    result.push(0x58, data.length);   // byte string, 1-byte length
  } else {
    result.push(0x59, data.length >> 8, data.length & 0xFF);  // byte string, 2-byte length
  }
  
  result.push(...data);
  
  return new Uint8Array(result);
}
// ISO 18013-5 compliant SessionEstablishment with manual CBOR encoding
async function buildLegacySessionEstablishmentWithData() {
  // ISO 18013-5 compliant SessionEstablishment
  // Per spec Section 9.1.1.4: {eReaderKey, data: <encrypted>}
  // data field uses RAW AES-GCM output (ciphertext || 16-byte auth_tag)
  
  const readerCoseKey = buildReaderCoseKey();
  
  // LOG: Verify which key we're using
  const keyX = readerCoseKey.get(-2);
  const keyY = readerCoseKey.get(-3);
  const fingerprint = hex(keyX.slice(0, 4));
  console.log('🔑 [SessionEstablishment] Using EReaderKey - fingerprint:', fingerprint);
  console.log('   [SessionEstablishment] X:', hex(keyX));
  console.log('   [SessionEstablishment] Y:', hex(keyY));
  
  // Manually encode and wrap COSE_Key in tag 24 (avoids tag 64)
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  const publicKeyBytes = encodeTag24ByteString(coseKeyEncoded);
  
  // Build and encrypt the mDL request
  console.log('Building mDL request for SessionEstablishment (publicKey variant)...');
  const mdlRequest = await buildRequestByType();
  
  // Derive session keys if needed
  if (!skReader || !transcriptAAD) {
    console.log('Deriving session keys per ISO 18013-5 (independent derivation)...');
    console.log('Using eSenderKey from DeviceEngagement (field 33) for ECDH');
    const mdocPub = await importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
    const shared = await deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);
    console.log('Building SessionTranscript for key derivation...');
    transcriptAAD = await buildTranscriptAAD();
    
    // Derive both session keys
    const keys = await deriveSessionKey(new Uint8Array(shared), transcriptAAD);
  skReader = keys.readerKey;  // Reader encrypts requests with SKReader
  skDevice = keys.deviceKey;  // Reader decrypts responses with SKDevice
  sessionKey = skReader;      // Compatibility alias
    sessionEstablished = true;
    window.sessionEstablished = true;
  }
  
  // Encrypt the request WITH SKReader (not SKDevice!)
  // Per ISO 18013-5: "The mdoc reader shall encrypt its mdoc requests with SKReader"
  // CRITICAL: SessionEstablishment.data field uses RAW AES-GCM output (not COSE_Encrypt0!)
  // Spec Section 9.1.1.4: "concatenation of the ciphertext and all 16 bytes of the authentication tag"
  // AAD: EMPTY per ISO 18013-5 Section 9.1.5.2
  console.log('🔐 Encrypting request with SKReader (raw AES-GCM for SessionEstablishment.data)...');
  console.log(' Request CBOR length:', mdlRequest.length, 'bytes');
  console.log('📦 Request CBOR (first 64 bytes):', hex(mdlRequest.slice(0, 64)));
  console.log('📝 AAD: EMPTY (per ISO 18013-5)');
  
  // Use reader identifier: 8 zero bytes
  const readerIdentifier = new Uint8Array(8); // 0x00 × 8
  const encryptedRequest = await aesGcmEncryptRaw(mdlRequest, skReader, readerIdentifier, 1);
  
  // Manually build SessionEstablishment - just a plain map, no outer tag 24
  const result = [];
  result.push(0xA2);  // Map with 2 items
  
  // Key 1: "eReaderKey" (10 characters) - per ISO 18013-5 spec
  result.push(0x6A);  // text string, length 10
  result.push(...Array.from('eReaderKey').map(c => c.charCodeAt(0)));
  result.push(...publicKeyBytes);  // tag(24, bstr .cbor COSE_Key)
  
  // Key 2: "data" (4 characters)
  result.push(0x64);
  result.push(...Array.from('data').map(c => c.charCodeAt(0)));
  
  // Value 2: encrypted request
  if (encryptedRequest.length < 24) {
    result.push(0x40 + encryptedRequest.length);
  } else if (encryptedRequest.length < 256) {
    result.push(0x58, encryptedRequest.length);
  } else {
    result.push(0x59, encryptedRequest.length >> 8, encryptedRequest.length & 0xFF);
  }
  result.push(...encryptedRequest);
  
  // That's it - just a plain map
  const final = new Uint8Array(result);
  
  console.log('SessionEstablishment (ISO 18013-5 compliant), length:', final.length);
  console.log('SessionEstablishment hex (first 200 bytes):', hex(final.slice(0, 200)));
  
  // DIAGNOSTIC: Decode to verify structure
  try {
    const decoded = CBOR.decode(final);
    console.log('=== DIAGNOSTIC: SessionEstablishment (ISO 18013-5) ===');
    console.log('Is a Map:', decoded instanceof Map || typeof decoded === 'object');
    console.log('Has eReaderKey:', 'eReaderKey' in decoded || decoded.get?.('eReaderKey'));
    console.log('Has data:', 'data' in decoded || decoded.get?.('data'));
    console.log('Data length:', (decoded.data || decoded.get?.('data'))?.length || 0);
    console.log('=== END DIAGNOSTIC ===');
  } catch (diagError) {
    console.error('Diagnostic decode failed:', diagError);
  }
  
  return final;
}

// Build different request types for common use cases
// Can now accept array of request types to create multiple docRequests
async function buildRequestByType(requestTypes) {
  // Get selected request types if not provided
  if (!requestTypes) {
    requestTypes = Array.from(document.querySelectorAll('input[name="requestType"]:checked'))
      .map(cb => cb.value);
  }
  
  // If single value provided, convert to array
  if (!Array.isArray(requestTypes)) {
    requestTypes = [requestTypes];
  }
  
  // If no types selected, default to mDL Full
  if (requestTypes.length === 0) {
    requestTypes = ['full'];
  }
  
  console.log('Building request for types:', requestTypes);
  
  // Build base request structure
  const deviceRequest = {
    version: "1.0",
    docRequests: []
  };
  
  // Build each document request
  for (const requestType of requestTypes) {
    const docRequest = buildSingleDocRequest(requestType);
    if (docRequest) {
      deviceRequest.docRequests.push(docRequest);
    }
  }
  
  console.log('→ Device Request with', deviceRequest.docRequests.length, 'document(s):', deviceRequest);
  
  return CBOR.encode(deviceRequest);
}

// Helper: Build a single document request based on type
function buildSingleDocRequest(requestType) {
  let docType, namespace, fields;
  let micovAttestationFields = null; // for org.micov.attestation.1
  
  // Determine document type and namespace
  if (requestType.startsWith('pid_')) {
    docType = "eu.europa.ec.eudi.pid.1";
    namespace = "eu.europa.ec.eudi.pid.1";
  } else if (requestType.startsWith('age_verify_')) {
    docType = "eu.europa.ec.av.1";
    namespace = "eu.europa.ec.av.1";
  } else if (requestType.startsWith('photoid_')) {
    docType = "org.iso.23220.photoID.1";
    namespace = "org.iso.23220.1";
    console.log('📸 Building Photo ID request - docType:', docType, 'namespace:', namespace);
  } else if (requestType.startsWith('micov_')) {
    // Per user: mICOV identifiers
    docType = "org.micov.1";
    namespace = "org.micov.vtr.1";
    console.log('💉 Building mICOV request - docType:', docType, 'namespace:', namespace);
  } else if (requestType.startsWith('mvc_')) {
    // Per user: mVC identifiers
    docType = "org.iso.7367.1.mVC";
    namespace = "org.iso.7367.1";
    console.log('🚗 Building mVC request - docType:', docType, 'namespace:', namespace);
  } else {
    docType = "org.iso.18013.5.1.mDL";
    namespace = "org.iso.18013.5.1";
  }
  
  // Build fields based on request type
  switch (requestType) {
    case 'basic':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "portrait": true
      };
      break;

    case 'age':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "birth_date": true
      };
      break;

    case 'driving':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "driving_privileges": true,
        "issue_date": true,
        "expiry_date": true,
        "document_number": true,
        "portrait": true
      };
      break;

    case 'full':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "age_over_18": true,
        "age_over_21": true,
        "issue_date": true,
        "expiry_date": true,
        "issuing_country": true,
        "issuing_authority": true,
        "document_number": true,
        "driving_privileges": true,
        "height": true,
        "weight": true,
        "eye_colour": true,
        "hair_colour": true,
        "sex": true,
        "resident_address": true,
        "resident_city": true,
        "resident_state": true,
        "resident_postal_code": true,
        "resident_country": true,
        "portrait": true,
        "signature_usual_mark": true
      };
      break;

    case 'pid_basic':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "portrait": true
      };
      break;

    case 'pid_age':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "birth_date": true
      };
      break;

    case 'pid_full':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "birth_place": true,
        "birth_country": true,
        "birth_state": true,
        "birth_city": true,
        "resident_address": true,
        "resident_country": true,
        "resident_state": true,
        "resident_city": true,
        "resident_postal_code": true,
        "resident_street": true,
        "resident_house_number": true,
        "gender": true,
        "nationality": true,
        "age_over_18": true,
        "age_over_21": true,
        "age_in_years": true,
        "age_birth_year": true,
        "family_name_birth": true,
        "given_name_birth": true,
        "portrait": true,
        "issuing_authority": true,
        "issuing_country": true,
        "issuance_date": true,
        "expiry_date": true,
        "document_number": true
      };
      break;

    // EU Age Verification (Proof of Age) cases
    case 'age_verify_18':
      fields = {
        "age_over_18": true
      };
      break;

    case 'age_verify_21':
      fields = {
        "age_over_18": true,
        "age_over_21": true
      };
      break;

    case 'age_verify_full':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "age_in_years": true,
        "age_birth_year": true,
        "birth_date": true,
        "issuing_country": true,
        "issuance_date": true,
        "expiry_date": true
      };
      break;

    // ISO 23220 Photo ID cases
    case 'photoid_full':
      fields = {
        "given_name": true,
        "family_name": true,
        "birth_date": true,
        "portrait": true,
        "issuing_country": true,
        "issuing_authority": true,
        "document_number": true,
        "issuance_date": true,
        "expiry_date": true,
        "sex": true,
        "nationality": true,
        "height": true,
        "eye_colour": true,
        "resident_address": true,
        "resident_city": true,
        "resident_postal_code": true,
        "resident_country": true
      };
      console.log('📸 Photo ID fields:', Object.keys(fields).length, 'attributes requested');
      break;

    // mICOV (Mobile International Certificate of Vaccination)
    case 'micov_full':
      fields = {
        // Holder identity
        "fn": true, // ok
        "gn": true, // ok
        "dob": true, // ok
        "sex": true, // ok
        "pid_PPN": true, // ok
        "pid_DL": true, // ok
        // Vaccination details (generic keys, may vary by issuer spec)
        "v_RA01_1": true, // ok
        "v_RA01_2": true, // ok
      };
      // Attestation namespace fields (org.micov.attestation.1)
      micovAttestationFields = {
        "1D47_vaccinated": true,
        "RA01_vaccinated": true,
        "RA01_test": true,
        "safeEntry_Leisure": true,
        "fac": true, // jpeg portrait
        "fni": true,
        "gni": true,
        "by": true,
        "bm": true,
        "bd": true
      };
      console.log('💉 mICOV VTR fields:', Object.keys(fields).length, '• Attestation fields:', Object.keys(micovAttestationFields).length);
      break;

    // mVC (Mobile Vehicle Registration Certificate)
    case 'mvc_full':
      fields = {
        // Vehicle and registration
        "registration_number": true, // ok
        "issue_date": true, // ok
        "expiry_date": true, // ok
        "issuing_country": true, // ok
        "issuing_authority_unicode": true, // ok
        "document_number": true, // ok
        "un_distinguishing_signs": true, // ok
        "date_of_registration": true, // ok
        "date_of_first_registration": true, // ok
        // Vehicle characteristics
        "vehicle_identification_number": true, // ok
        "basic_vehicle_info": true, // ok
        "mass_info": true, // ok
        "trailer_mass_info": true, // ok
        "engine_info": true, // ok 
        "seating_info": true, // ok
        // Owner
         "registered_users": true, // ok
      };
      console.log('🚗 mVC fields:', Object.keys(fields).length, 'attributes requested');
      break;

    default:
      console.warn('Unknown request type:', requestType);
      return null;
  }
  
  // Build the itemsRequest
  // Special handling: mICOV uses two namespaces (vtr + attestation)
  let nameSpacesObj;
  if (requestType.startsWith('micov_')) {
    nameSpacesObj = {
      'org.micov.vtr.1': fields,
      'org.micov.attestation.1': micovAttestationFields || {}
    };
  } else {
    nameSpacesObj = {
      [namespace]: fields
    };
  }

  const itemsRequest = {
    docType: docType,
    nameSpaces: nameSpacesObj,
    requestInfo: {}
  };
  
  const nsKeys = Object.keys(nameSpacesObj);
  const totalFields = nsKeys.reduce((sum, k) => sum + Object.keys(nameSpacesObj[k]).length, 0);
  console.log('📋 ItemsRequest built:', {
    docType,
    namespaces: nsKeys,
    fieldCount: totalFields
  });
  
  // Per ISO 18013-5, itemsRequest must be tag(24, bstr .cbor ItemsRequest)
  const itemsRequestCbor = CBOR.encode(itemsRequest);
  const taggedItemsRequest = new CBOR.Tagged(24, itemsRequestCbor);
  
  const docRequest = {
    itemsRequest: taggedItemsRequest
  };
  
  return docRequest;
}

// ==== Mode switching ====
function updateBleRoleUI() {
  // Function kept for compatibility but no longer manages button states
  // Requests are sent automatically after session establishment
}

// Handle request type changes (now supports multiple selections)
requestTypeCheckboxes.forEach(checkbox => {
  checkbox.addEventListener('change', (e) => {
    const selected = Array.from(document.querySelectorAll('input[name="requestType"]:checked'))
      .map(cb => cb.value);
    
    if (selected.length === 0) {
      log('⚠️ No document types selected - will default to mDL Full');
    } else if (selected.length === 1) {
      const type = selected[0];
      let description = '';
      switch(type) {
        case 'basic':
          description = 'Basic ID: name, birth_date, portrait';
          break;
        case 'age':
          description = 'Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'driving':
          description = 'Driving license: name, birth_date, driving_privileges, license info, portrait';
          break;
        case 'full':
          description = 'Full mDL: all available fields including address, physical characteristics';
          break;
        case 'pid_basic':
          description = 'Basic EU PID: name, birth_date, portrait';
          break;
        case 'pid_age':
          description = 'EU PID Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'pid_full':
          description = 'Full EU PID: all available fields including address, nationality, birth details';
          break;
        case 'age_verify_18':
          description = 'Age Verification 18+: age_over_18 only';
          break;
        case 'age_verify_21':
          description = 'Age Verification 21+: age_over_18, age_over_21';
          break;
        case 'age_verify_full':
          description = 'Age Verification Full: age checks, birth_date, age_in_years, issuing info';
          break;
        case 'photoid_full':
          description = 'ISO 23220 Photo ID: name, birth_date, portrait, nationality, physical characteristics, address';
          break;
        case 'micov_full':
          description = 'mICOV: identity + vaccination details (vtr) plus attestation namespace';
          break;
        case 'mvc_full':
          description = 'mVC: vehicle registration details, vehicle characteristics, owner';
          break;
      }
      log(`Selected request type: ${type.toUpperCase()} - ${description}`);
    } else {
      // Multiple documents selected
      const docTypes = selected.map(t => {
        if (t.startsWith('pid_')) return 'EU PID';
        if (t.startsWith('age_verify_')) return 'Age Verification';
        if (t.startsWith('photoid_')) return 'Photo ID';
        if (t.startsWith('micov_')) return 'mICOV';
        if (t.startsWith('mvc_')) return 'mVC';
        return 'mDL';
      });
      const uniqueTypes = [...new Set(docTypes)];
      log(`📋 Multi-document request: ${selected.length} document(s) selected (${uniqueTypes.join(' + ')})`);
    }
  });
});

// Initialize UI
updateBleRoleUI();

// ==== UI actions ====

// ========================================
// PWA Service Worker Registration
// ========================================
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });
      
      console.log('✅ Service Worker registered successfully:', registration.scope);
      
      // Check for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('🔄 Service Worker update found');
        
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('✨ New content available, please refresh');
            // Optionally show a toast notification to user
            showUpdateNotification();
          }
        });
      });
      
      // Handle controller change (after update)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('♻️ Service Worker controller changed, reloading...');
        window.location.reload();
      });
      
      // Check for updates periodically (every 60 seconds)
      setInterval(() => {
        registration.update().then(() => {
          console.log('🔍 Checked for Service Worker updates');
        }).catch(err => {
          console.warn('Update check failed:', err);
        });
      }, 60000); // Check every minute
      
      // Also check for updates when page becomes visible
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && registration) {
          registration.update();
          console.log('🔍 Checking for updates (page visible)');
        }
      });
      
    } catch (error) {
      console.error('❌ Service Worker registration failed:', error);
    }
  });
}

// PWA Install Prompt
let deferredPrompt;
const pwaInstallBanner = document.createElement('div');

// Footer: show APP_VERSION
window.addEventListener('DOMContentLoaded', () => {
  const footerVersion = document.getElementById('appVersionFooter');
  if (footerVersion) {
    footerVersion.innerText = `v${APP_VERSION}`;
  }
});

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;
  
  // Show custom install banner
  showInstallBanner();
});

function showInstallBanner() {
  pwaInstallBanner.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #1d4ed8, #2563eb);
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 12px;
    box-shadow: 0 10px 40px -15px rgba(29, 78, 216, 0.6);
    display: flex;
    align-items: center;
    gap: 1rem;
    z-index: 10000;
    max-width: 90%;
    animation: slideUp 0.3s ease-out;
  `;
  
  pwaInstallBanner.innerHTML = `
    <div style="flex: 1;">
      <div style="font-weight: 600; margin-bottom: 0.25rem;">Install mDL Reader</div>
      <div style="font-size: 0.875rem; opacity: 0.9;">Access offline and faster</div>
    </div>
    <button id="installBtn" style="
      background: white;
      color: #1d4ed8;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.875rem;
    ">Install</button>
    <button id="dismissInstall" style="
      background: transparent;
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
    ">✕</button>
  `;
  
  document.body.appendChild(pwaInstallBanner);
  
  // Install button handler
  document.getElementById('installBtn').addEventListener('click', async () => {
    if (!deferredPrompt) return;
    
    // Show the install prompt
    deferredPrompt.prompt();
    
    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);
    
    // Clear the deferred prompt
    deferredPrompt = null;
    
    // Hide the banner
    pwaInstallBanner.remove();
  });
  
  // Dismiss button handler
  document.getElementById('dismissInstall').addEventListener('click', () => {
    pwaInstallBanner.remove();
    // Remember dismissal for 7 days
    localStorage.setItem('pwa-install-dismissed', Date.now().toString());
  });
  
  // Check if dismissed recently
  const dismissed = localStorage.getItem('pwa-install-dismissed');
  if (dismissed && (Date.now() - parseInt(dismissed)) < 7 * 24 * 60 * 60 * 1000) {
    pwaInstallBanner.remove();
  }
}

// Add slideUp animation
const style = document.createElement('style');
style.textContent = `
  @keyframes slideUp {
    from {
      transform: translateX(-50%) translateY(100px);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
`;
document.head.appendChild(style);

// Track successful installation
window.addEventListener('appinstalled', () => {
  console.log('✅ PWA installed successfully');
  pwaInstallBanner.remove();
  deferredPrompt = null;
});

// Show update notification
function showUpdateNotification() {
  const updateBanner = document.createElement('div');
  updateBanner.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #059669;
    color: white;
    padding: 0.75rem 1.25rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    gap: 1rem;
    z-index: 10001;
    animation: slideDown 0.3s ease-out;
  `;
  
  updateBanner.innerHTML = `
    <span>✨ Update available!</span>
    <button id="updateBtn" style="
      background: white;
      color: #059669;
      border: none;
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.875rem;
    ">Refresh</button>
  `;
  
  document.body.appendChild(updateBanner);
  
  document.getElementById('updateBtn').addEventListener('click', () => {
    window.location.reload();
  });
  
  // Auto-dismiss after 10 seconds
  setTimeout(() => {
    updateBanner.style.animation = 'slideUp 0.3s ease-out reverse';
    setTimeout(() => updateBanner.remove(), 300);
  }, 10000);
}

const slideDownStyle = document.createElement('style');
slideDownStyle.textContent = `
  @keyframes slideDown {
    from {
      transform: translateX(-50%) translateY(-100px);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
`;
document.head.appendChild(slideDownStyle);

</script>
</html>