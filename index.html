<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ISO 18013-5 Web Proximity Reader</title>
  <style>
    :root { color-scheme: light dark; font-family: "Inter", "Segoe UI", sans-serif; line-height: 1.5; }
    body { margin: 0; background: #F2F4F8; color: #111827; }
    .page-header { background: linear-gradient(135deg,#0f172a,#1e293b); color: #f8fafc; padding: 2.5rem 1.5rem 2rem; text-align: center; }
    .page-header h1 { margin: 0; font-size: clamp(1.8rem,3vw,2.4rem); font-weight: 600; }
    .page-header p { margin: 0.75rem auto 0; max-width: 720px; color: rgba(248,250,252,0.8); }
    main { max-width: 1100px; margin: -2rem auto 3rem; padding: 0 1.5rem 3rem; }
    .card { background: #ffffff; border-radius: 18px; padding: 1.75rem; margin-top: 2rem; box-shadow: 0 20px 45px -25px rgba(15,23,42,0.35); border: 1px solid rgba(148,163,184,0.25); }
    .card h2 { margin-top: 0; font-size: 1.35rem; font-weight: 600; color: #0f172a; }
    .card h3 { margin-bottom: 0.5rem; margin-top: 1.5rem; font-size: 1.15rem; color: #0f172a; }
    .muted { color: #64748b; font-size: 0.95rem; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-top: 1rem; }
    .scanner { display: grid; gap: 1.5rem; margin-top: 1rem; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); align-items: start; }
    .video-frame { position: relative; border-radius: 16px; overflow: hidden; background: #020617; min-height: 220px; }
    video#video { width: 100%; height: 100%; object-fit: cover; display: block; }
    canvas#canvas { display: none; }
  .status-panel { background: #f1f5f9; border-radius: 14px; padding: 1rem 1.25rem; font-size: 0.95rem; line-height: 1.6; }
    .status-panel span { font-family: "SFMono-Regular", "JetBrains Mono", ui-monospace, monospace; word-break: break-all; }
    label.inline { display: flex; align-items: center; gap: 0.5rem; font-weight: 500; }
    label.inline input[type="text"],
    label.inline input[type="number"] { flex: 1; min-width: 12rem; padding: 0.45rem 0.65rem; border-radius: 8px; border: 1px solid rgba(148,163,184,0.6); font-size: 0.95rem; }
  .manual-entry { margin-top: 1.5rem; display: grid; gap: 0.75rem; }
  .manual-entry textarea { width: 100%; min-height: 110px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.9rem; background: #f8fafc; resize: vertical; }
  .manual-entry textarea:focus { outline: 2px solid rgba(37,99,235,0.4); outline-offset: 2px; }
    button { font: inherit; font-weight: 600; padding: 0.55rem 1rem; border-radius: 10px; border: 1px solid rgba(15,23,42,0.08); background: #1d4ed8; color: #fff; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease; }
    button.secondary { background: #0f172a; }
    button:disabled { background: rgba(15,23,42,0.2); color: rgba(15,23,42,0.4); cursor: not-allowed; transform: none; box-shadow: none; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 12px 24px -18px rgba(30,64,175,0.9); }
    .button-grid { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; }
    .radio-group { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.75rem; }
    .radio-chip { display: inline-flex; align-items: center; gap: 0.45rem; background: #e2e8f0; border-radius: 999px; padding: 0.35rem 0.85rem; font-size: 0.95rem; cursor: pointer; transition: background 0.2s ease; }
    .radio-chip input { accent-color: #2563eb; }
    .radio-chip:hover { background: #cbd5f5; }
    .radio-group.request-type { gap: 0.5rem; }
    .radio-chip.small { padding: 0.3rem 0.75rem; font-size: 0.9rem; }
    #roleDescription { margin-top: 0.65rem; }
    .log { background: #0f172a; color: #f8fafc; padding: 1rem; border-radius: 14px; min-height: 200px; max-height: 280px; overflow-y: auto; font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.85rem; }
    pre#rx { background: #f8fafc; border-radius: 14px; padding: 1rem; white-space: pre-wrap; word-break: break-word; min-height: 120px; border: 1px solid rgba(148,163,184,0.35); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; }
    
    /* Response Display Styles */
    #responseDisplay { background: #f8fafc; border-radius: 14px; padding: 1.5rem; border: 1px solid rgba(148,163,184,0.35); }
    .response-header { background: linear-gradient(135deg, #0f3d76, #1466b8); color: white; padding: 1rem 1.25rem; border-radius: 12px; margin-bottom: 1.5rem; }
    .response-header h3 { margin: 0; font-size: 1.25rem; font-weight: 600; color: white; }
    .response-meta { color: rgba(255,255,255,0.9); font-size: 0.9rem; margin-top: 0.35rem; }
    .document-card { background: white; border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; border: 1px solid rgba(148,163,184,0.25); box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
    .document-type { font-size: 0.85rem; color: #0f766e; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; }
    .namespace-section { margin-top: 1rem; }
    .namespace-title { background: #e0f2fe; color: #0c4a6e; padding: 0.5rem 0.75rem; border-radius: 8px; font-size: 0.9rem; font-weight: 600; margin-bottom: 0.75rem; display: inline-block; }
    .data-item { display: grid; grid-template-columns: 140px 1fr; gap: 0.75rem; padding: 0.65rem 0; border-bottom: 1px solid rgba(148,163,184,0.15); }
    .data-item:last-child { border-bottom: none; }
    .data-label { font-weight: 600; color: #475569; font-size: 0.9rem; }
    .data-value { color: #0f172a; font-size: 0.9rem; word-break: break-word; }
    .data-value.binary { color: #64748b; font-style: italic; }
    .data-value.portrait-preview { display: flex; align-items: center; gap: 0.75rem; }
    .portrait-thumbnail { max-width: 80px; max-height: 100px; border-radius: 6px; border: 2px solid rgba(148,163,184,0.3); }
    .no-data { color: #94a3b8; font-style: italic; text-align: center; padding: 2rem; }
    
    .chip-list { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-top: 0.5rem; }
    .chip { background: #e2e8f0; border-radius: 999px; padding: 0.25rem 0.75rem; font-size: 0.8rem; color: #0f172a; }
    footer { text-align: center; padding: 2rem 1rem 3rem; color: #64748b; font-size: 0.9rem; }
    @media (max-width: 640px) {
      .card { padding: 1.25rem; border-radius: 14px; }
      button { width: 100%; justify-content: center; }
      .button-grid { flex-direction: column; }
      .status-panel { font-size: 0.9rem; }
      .data-item { grid-template-columns: 1fr; gap: 0.25rem; }
    }
  </style>
</head>
<body>
  <header class="page-header">
    <h1>ISO 18013-5 Web Proximity Reader</h1>
    <p>Scan an mDL/mDoc device engagement QR, connect over Web Bluetooth, and request digital credentials.</p>
  </header>
  <main>
    <section class="card" id="requestSection">
      <h2>1. Request Digital Credentials</h2>
      <p class="muted">Select one or more digital credential. You can request multiple digital credentials (e.g., mDL + PID) in a single session.</p>
      
      <div style="margin-bottom: 15px;">
        <strong>mDL (Mobile Driver's License)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="basic"> mDL Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age"> mDL Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="driving"> mDL Driving
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="full" checked> mDL Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>EU PID (Personal Identity Document)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_basic"> EU PID Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_age"> EU PID Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_full"> EU PID Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>EU Age Verification (Proof of Age)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_18"> Age 18+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_21"> Age 21+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_full"> Age Full
        </label>
      </div>
    </section>

    <section class="card" id="qrSection">
      <h2>2. Device Engagement</h2>
      <p class="muted">Use your computer camera to capture the wallet's QR code or paste details manually.</p>
      <div class="row">
        <button id="btnScan">Scan QR Code</button>
        <button id="btnScanBLE" class="secondary">Scan Nearby BLE</button>
      </div>
      <div class="scanner">
        <div class="video-frame">
          <video id="video" playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="status-panel">
          <p><strong>Status:</strong> <span id="qrStatus">Idle</span></p>
          <p><strong>Device Engagement URI:</strong> <span id="mdocUri">‚Äî</span></p>
          <p><strong>Service UUID:</strong> <span id="svcUuid">‚Äî</span></p>
          <p><strong>BLE Address:</strong> <span id="bleAddr">‚Äî</span></p>
        </div>
      </div>
      <div class="row">
        <label class="inline muted">Service UUID override
          <input id="svcOverride" type="text" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
        </label>
        <button id="btnUseOverride">Use override</button>
        <label class="inline muted">Chunk bytes
          <input id="chunk" type="number" min="5" max="240" value="20">
        </label>
      </div>

      <div class="manual-entry">
        <label class="muted" for="qrInput">Manual QR payload (paste from clipboard or laser scanner)</label>
        <textarea id="qrInput" placeholder="Paste the full mdoc: URI or CBOR payload here"></textarea>
        <div class="row" style="margin-top:0">
          <button id="btnParseQr" class="secondary">Use manual QR payload</button>
          <button id="btnClearQr">Clear</button>
        </div>
      </div>
    </section>

    <section class="card" id="responseSection" style="display: none;">
      <h2>Wallet Response</h2>
      <div id="responseDisplay"></div>
    </section>

    <section class="card" id="logsSection">
      <h2>3. Activity Log</h2>
      <div class="log" id="log" role="log" aria-live="polite" aria-label="Session activity log"></div>
    </section>
  </main>
  <footer>
    Built by <a href="https://stelau.com">Stelau</a> for rapid ISO 18013-5 experimentation. Web Bluetooth requires HTTPS and a compatible browser.
  </footer>

<!-- Load libs BEFORE the module -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.min.js"></script>

<script type="module">
// ==== CBOR bootstrap (works even if global isn't set) ====
let CBORRef = self.CBOR || self.cbor;
if (!CBORRef) {
  try { CBORRef = await import('https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.mjs'); }
  catch (e) { console.error('CBOR library load failed', e); }
}
if (!CBORRef) throw new Error('CBOR library unavailable. Check network/CSP.');
const CBOR = CBORRef;

// ==== DOM refs ====
const logEl = document.getElementById('log');
const responseDisplayEl = document.getElementById('responseDisplay');
const responseSectionEl = document.getElementById('responseSection');
const statusEl = document.getElementById('qrStatus');
const mdocUriEl = document.getElementById('mdocUri');
const svcUuidEl = document.getElementById('svcUuid');
const bleAddrEl = document.getElementById('bleAddr');
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const qrInput = document.getElementById('qrInput');
const btnParseQr = document.getElementById('btnParseQr');
const btnClearQr = document.getElementById('btnClearQr');

const btnScan = document.getElementById('btnScan');
const btnScanBLE = document.getElementById('btnScanBLE');
const btnSend = document.getElementById('btnSend');
const chunkInput = document.getElementById('chunk');
const svcOverrideInput = document.getElementById('svcOverride');
const btnUseOverride = document.getElementById('btnUseOverride');

// Removed buttons (kept as null for legacy code compatibility)
const btnAdvertise = null;
const btnStopAdvertise = null;
const btnCompatMode = null;
const btnConnect = null;
const btnStart = null;
const btnEstablish = null;
const btnEstablishAlt = null;
const btnTestRequest = null;
const btnDiagnose = null;
const btnEnd = null;
const btnQuickReconnect = null;
const btnDisc = null;

// Request type elements (now checkboxes for multi-document selection)
const requestTypeCheckboxes = document.querySelectorAll('input[name="requestType"]');

// ==== State ====
let scanRunning = false;
let device, server, service, chState, chC2S, chS2C;
let rxBuffer = [];
let svcUUID = null;
let bleAddr = null;
let currentBleRole = 'central'; // Always central mode now

let deBytes = null;              // Raw DeviceEngagement CBOR bytes
let mdocPubKey = null;           // { x:Uint8Array, y:Uint8Array } P-256
let readerKeyPair = null;        // CryptoKeyPair (ECDH)
let skReader = null;             // Uint8Array(32) - Reader encrypts requests with this
let skDevice = null;             // Uint8Array(32) - Reader decrypts responses with this
let sessionKey = null;           // DEPRECATED - kept for compatibility
let transcriptAAD = null;        // Uint8Array (SHA-256 of transcript CBOR)
let walletEphemeralKey = null;   // CryptoKey from wallet SessionEstablishment response
let sessionEstablished = false;  // Tracks if both sides derived matching session keys

// ==== Utils ====
const enc = new TextEncoder();
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.innerHTML += `[${t}] ${msg}<br>`;
  logEl.scrollTop = logEl.scrollHeight;
}
function hex(buf) { return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join(' '); }
function concatUint8(...arrs){ const n=arrs.reduce((s,a)=>s+a.length,0); const out=new Uint8Array(n); let o=0; for(const a of arrs){out.set(a,o);o+=a.length;} return out; }

// ==== BLE transport (GATT) ====
const UUIDS = { // characteristic UUIDs used by common 18013-5 demos/drafts
  state: '00000001-a123-48ce-896b-4c76973373e6',
  c2s:   '00000002-a123-48ce-896b-4c76973373e6',
  s2c:   '00000003-a123-48ce-896b-4c76973373e6'
};

async function handleServer2Client(event) {
  const data = new Uint8Array(event.target.value.buffer);
  if (data.length === 0) return;
  const flag = data[0];
  const chunk = data.slice(1);
  rxBuffer.push(chunk);
  log(`S‚ÜíC notify: flag=0x${flag.toString(16)} len=${chunk.length}`);
  if (flag === 0x00) {
    const len = rxBuffer.reduce((n,a)=>n+a.length,0);
    const assembled = new Uint8Array(len);
    let o=0; for (const seg of rxBuffer) { assembled.set(seg,o); o+=seg.length; }
    rxBuffer = [];
    log(`S‚ÜíC complete: ${len} bytes`);
    
    console.log('=== RECEIVED DATA FROM WALLET ===');
    console.log('Length:', len);
    console.log('Hex:', hex(assembled));
    
    // Try to decode the response
    try {
      const decoded = CBOR.decode(assembled);
      console.log('Decoded wallet response:', decoded);
      console.log('Response type:', typeof decoded);
      console.log('Is Map:', decoded instanceof Map);
      console.log('Is Object:', decoded && typeof decoded === 'object');
      
      // Check if this is a SessionEstablishment response (contains eDeviceKey)
      let isSessionResponse = false;
      
      // Log all fields to see what we actually received
      if (decoded instanceof Map) {
        console.log('Response is a Map with keys:', Array.from(decoded.keys()));
        if (decoded.has('eDeviceKey') || decoded.has('data') || decoded.has('status')) {
          isSessionResponse = true;
          console.log('‚úÖ Detected SessionEstablishment response (Map)');
        }
      } else if (decoded && typeof decoded === 'object') {
        console.log('Response object keys:', Object.keys(decoded));
        if (decoded.eDeviceKey || decoded.eReaderKey || decoded.data || decoded.status) {
          isSessionResponse = true;
          console.log('‚úÖ Detected SessionEstablishment response (Object)');
        }
      }
      
      // ANY response before session is established should be considered a session response
      // Check if session keys are established (skReader and skDevice are set)
      if (!skReader || !skDevice) {
        isSessionResponse = true;
        console.log('‚úÖ Detected response before session established - treating as session response');
      }
      
      if (isSessionResponse) {
        log('üìã Received session establishment response from wallet');
        log(`üîó Response size: ${len} bytes`);
        
        // Signal to session establishment handler
        window.sessionResponseReceived = true;
        window.sessionResponseData = assembled;
        
        try {
          await processSessionResponse(assembled);
        } catch (processError) {
          console.error('Failed to finalize session from response:', processError);
          log('‚ùå Session finalization failed: ' + processError.message);
        }
        
        console.log('Session response captured and signaled');
        
      } else if (skDevice && assembled.length > 20) {
        // This might be an encrypted DeviceResponse
        log('üîê Received encrypted response - attempting to decrypt...');
        try {
          // Decrypt and display the response
          await decryptAndDisplayResponse(assembled);
        } catch (decryptError) {
          console.error('Decryption failed:', decryptError);
          log('‚ùå Decryption failed: ' + decryptError.message);
        }
      } else {
        log(`üìÑ Received ${len}-byte response from wallet`);
      }
    } catch (e) {
      console.log('Could not decode CBOR response:', e.message);
      log(`üìÑ Received ${len}-byte binary response from wallet`);
    }
  }
}

// Decrypt and display mDL response
async function decryptAndDisplayResponse(encryptedData) {
  console.log('=== DECRYPTING DEVICE RESPONSE ===');
  console.log('Encrypted data length:', encryptedData.length);
  console.log('Encrypted data hex:', hex(encryptedData));
  
  // Decode COSE_Encrypt0 structure
  const coseEnc0 = CBOR.decode(encryptedData.buffer);
  
  if (!Array.isArray(coseEnc0) || coseEnc0.length !== 3) {
    throw new Error('Invalid COSE_Encrypt0 structure - expected 3-element array');
  }
  
  const [protectedHeaderBytes, unprotectedHeader, ciphertext] = coseEnc0;
  
  console.log('Protected header:', protectedHeaderBytes);
  console.log('Unprotected header:', unprotectedHeader);
  console.log('Ciphertext length:', ciphertext.length);
  
  // Decode protected header
  let protectedHeader = {};
  if (protectedHeaderBytes && protectedHeaderBytes.length > 0) {
    protectedHeader = CBOR.decode(protectedHeaderBytes.buffer);
    console.log('Decoded protected header:', protectedHeader);
  }
  
  // Get IV from unprotected header (label 5)
  const iv = unprotectedHeader instanceof Map ? unprotectedHeader.get(5) : unprotectedHeader[5];
  
  if (!iv) {
    throw new Error('No IV found in unprotected header');
  }
  
  console.log('IV:', hex(new Uint8Array(iv)));
  console.log('Ciphertext (with auth tag):', hex(new Uint8Array(ciphertext)));
  
  // Decrypt with SKDevice (wallet encrypted with SKDevice, we decrypt with SKDevice)
  const plaintext = await aesGcmDecrypt(new Uint8Array(ciphertext), skDevice, new Uint8Array(iv), '');
  
  console.log('‚úÖ Decryption successful!');
  console.log('Plaintext length:', plaintext.length);
  console.log('Plaintext hex:', hex(plaintext));
  
  // Decode the DeviceResponse
  const deviceResponse = CBOR.decode(plaintext.buffer);
  console.log('Decoded DeviceResponse:', deviceResponse);
  
  // Display the response
  displayDeviceResponse(deviceResponse);
  
  log('‚úÖ Response decrypted and displayed successfully!');
}

// AES-GCM decryption
async function aesGcmDecrypt(ciphertextWithTag, keyBytes, iv, aad) {
  console.log('=== AES-GCM DECRYPTION ===');
  console.log('Key length:', keyBytes.length);
  console.log('IV length:', iv.length);
  console.log('AAD:', aad);
  console.log('Ciphertext+tag length:', ciphertextWithTag.length);
  
  const key = await crypto.subtle.importKey(
    'raw',
    keyBytes,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
  
  const aadBytes = typeof aad === 'string' ? enc.encode(aad) : new Uint8Array(aad || 0);
  
  try {
    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv,
        additionalData: aadBytes,
        tagLength: 128  // 16 bytes
      },
      key,
      ciphertextWithTag
    );
    
    return new Uint8Array(decrypted);
  } catch (e) {
    console.error('AES-GCM decrypt error:', e);
    throw new Error('AES-GCM decryption failed: ' + e.message);
  }
}

// ===== SIGNATURE VERIFICATION FUNCTIONS =====

// Extract public key from X.509 certificate (DER format)
async function extractPublicKeyFromCert(certDer) {
  try {
    console.log('Extracting public key from certificate, size:', certDer.length);
    
    // Parse the certificate to find the Subject Public Key Info
    // X.509 structure: SEQUENCE { tbsCertificate, signatureAlgorithm, signature }
    // We need to extract the public key from tbsCertificate
    
    // For now, we'll use a simple approach: look for the EC public key pattern
    // EC public key is typically 65 bytes: 0x04 || X (32 bytes) || Y (32 bytes)
    
    // Better approach: Parse the SEQUENCE structure
    const cert = new Uint8Array(certDer);
    
    // Find the public key (look for SEQUENCE tag followed by BIT STRING containing the key)
    // The public key in X.509 is in SubjectPublicKeyInfo
    // For EC keys, it's typically: BIT STRING with 0x04 prefix + 64 bytes (uncompressed point)
    
    let publicKeyBytes = null;
    
    // Look for the uncompressed EC point pattern (0x04 followed by 64 bytes)
    for (let i = 0; i < cert.length - 65; i++) {
      if (cert[i] === 0x04) {
        // Check if this looks like an EC public key (uncompressed point)
        // It should be 65 bytes total: 0x04 + 32 bytes X + 32 bytes Y
        const candidate = cert.slice(i, i + 65);
        
        // Verify it's preceded by reasonable DER structure
        // Typically: 0x03 (BIT STRING tag), length, 0x00 (no unused bits), 0x04...
        if (i >= 2 && cert[i - 1] === 0x00 && cert[i - 2] >= 66) {
          publicKeyBytes = candidate;
          console.log('Found EC public key at offset', i);
          break;
        }
      }
    }
    
    if (!publicKeyBytes) {
      throw new Error('Could not find EC public key in certificate');
    }
    
    // Extract X and Y coordinates (skip the 0x04 prefix)
    const x = publicKeyBytes.slice(1, 33);
    const y = publicKeyBytes.slice(33, 65);
    
    console.log('Extracted X:', hex(x));
    console.log('Extracted Y:', hex(y));
    
    // Import as P-256 public key for ECDSA verification
    const jwk = {
      kty: 'EC',
      crv: 'P-256',
      x: base64UrlEncode(x),
      y: base64UrlEncode(y)
    };
    
    const publicKey = await crypto.subtle.importKey(
      'jwk',
      jwk,
      { name: 'ECDSA', namedCurve: 'P-256' },
      true,
      ['verify']
    );
    
    console.log('‚úÖ Public key imported successfully');
    return publicKey;
    
  } catch (err) {
    console.error('Error extracting public key:', err);
    throw err;
  }
}

// Helper: Base64 URL encode (without padding)
function base64UrlEncode(bytes) {
  const base64 = btoa(String.fromCharCode(...bytes));
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

// Helper: Create download link for JPEG2000 image
function createJp2DownloadLink(jp2Bytes, portraitId) {
  const base64 = btoa(String.fromCharCode(...jp2Bytes));
  const dataUri = `data:image/jp2;base64,${base64}`;
  
  return `
    <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;">
      <div style="padding: 0.75rem 1rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 8px; font-size: 0.9rem;">
        ‚ö†Ô∏è JPEG2000 format - Browser cannot display natively
      </div>
      <a href="${dataUri}" download="portrait.jp2" style="display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.9rem; background: #1d4ed8; color: white; border-radius: 8px; text-decoration: none; font-size: 0.9rem; font-weight: 600;">
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
          <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
        </svg>
        Download JPEG2000
      </a>
      <div style="font-size: 0.85rem; color: #64748b;">
        Convert to JPEG using online tools or image viewer
      </div>
    </div>
  `;
}

// Extract certificate information (Subject CN, Issuer CN) from X.509 DER certificate
function extractCertInfo(certDer) {
  try {
    const cert = new Uint8Array(certDer);
    
    // Helper to parse DER length
    function parseDerLength(bytes, offset) {
      const firstByte = bytes[offset];
      if (firstByte < 0x80) {
        return { length: firstByte, bytesUsed: 1 };
      }
      const numBytes = firstByte & 0x7F;
      let length = 0;
      for (let i = 0; i < numBytes; i++) {
        length = (length << 8) | bytes[offset + 1 + i];
      }
      return { length, bytesUsed: 1 + numBytes };
    }
    
    // Helper to extract PrintableString or UTF8String
    function extractString(bytes, offset) {
      const tag = bytes[offset];
      const lenInfo = parseDerLength(bytes, offset + 1);
      const strStart = offset + 1 + lenInfo.bytesUsed;
      const strEnd = strStart + lenInfo.length;
      
      // Tags: 0x0C = UTF8String, 0x13 = PrintableString, 0x16 = IA5String
      if (tag === 0x0C || tag === 0x13 || tag === 0x16) {
        const strBytes = bytes.slice(strStart, strEnd);
        return new TextDecoder().decode(strBytes);
      }
      return null;
    }
    
    // Find Common Name (CN) in a Name structure
    // CN OID is 2.5.4.3 = 06 03 55 04 03
    function findCN(bytes, start, end) {
      const cnOid = new Uint8Array([0x06, 0x03, 0x55, 0x04, 0x03]);
      
      for (let i = start; i < end - 10; i++) {
        // Check if we found the CN OID
        if (bytes[i] === 0x06 && bytes[i + 1] === 0x03 &&
            bytes[i + 2] === 0x55 && bytes[i + 3] === 0x04 && bytes[i + 4] === 0x03) {
          // CN OID found, next should be the string value
          // Skip to the string (usually right after the OID)
          let offset = i + 5;
          // The string is typically wrapped in a SET, then the actual string
          if (bytes[offset] === 0x31) { // SET tag
            offset++; // skip tag
            const lenInfo = parseDerLength(bytes, offset);
            offset += lenInfo.bytesUsed;
          }
          // Now should be the string (PrintableString, UTF8String, etc.)
          const cn = extractString(bytes, offset);
          if (cn) return cn;
        }
      }
      return null;
    }
    
    // X.509 Certificate structure:
    // SEQUENCE {
    //   tbsCertificate SEQUENCE {
    //     version [0] EXPLICIT
    //     serialNumber
    //     signature (algorithm)
    //     issuer Name      <-- We want CN from here
    //     validity
    //     subject Name     <-- We want CN from here
    //     ...
    //   }
    // }
    
    // Start by finding the main SEQUENCE
    let offset = 0;
    if (cert[offset] !== 0x30) throw new Error('Not a valid DER certificate');
    offset++;
    
    const certLenInfo = parseDerLength(cert, offset);
    offset += certLenInfo.bytesUsed;
    
    // Now we're inside the certificate SEQUENCE
    // Next should be tbsCertificate SEQUENCE
    if (cert[offset] !== 0x30) throw new Error('Invalid tbsCertificate');
    offset++;
    
    const tbsLenInfo = parseDerLength(cert, offset);
    const tbsStart = offset + tbsLenInfo.bytesUsed;
    const tbsEnd = tbsStart + tbsLenInfo.length;
    offset = tbsStart;
    
    // Skip version (optional [0] EXPLICIT)
    if (cert[offset] === 0xA0) {
      offset++; // skip tag
      const verLenInfo = parseDerLength(cert, offset);
      offset += verLenInfo.bytesUsed + verLenInfo.length;
    }
    
    // Skip serialNumber (INTEGER)
    if (cert[offset] === 0x02) {
      offset++; // skip tag
      const snLenInfo = parseDerLength(cert, offset);
      offset += snLenInfo.bytesUsed + snLenInfo.length;
    }
    
    // Skip signature algorithm (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const algLenInfo = parseDerLength(cert, offset);
      offset += algLenInfo.bytesUsed + algLenInfo.length;
    }
    
    // Now we should be at issuer Name (SEQUENCE)
    let issuerCN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const issuerLenInfo = parseDerLength(cert, offset);
      const issuerStart = offset + issuerLenInfo.bytesUsed;
      const issuerEnd = issuerStart + issuerLenInfo.length;
      
      issuerCN = findCN(cert, issuerStart, issuerEnd);
      
      offset = issuerEnd;
    }
    
    // Skip validity (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const valLenInfo = parseDerLength(cert, offset);
      offset += valLenInfo.bytesUsed + valLenInfo.length;
    }
    
    // Now we should be at subject Name (SEQUENCE)
    let subjectCN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const subjectLenInfo = parseDerLength(cert, offset);
      const subjectStart = offset + subjectLenInfo.bytesUsed;
      const subjectEnd = subjectStart + subjectLenInfo.length;
      
      subjectCN = findCN(cert, subjectStart, subjectEnd);
    }
    
    return { subjectCN, issuerCN };
    
  } catch (err) {
    console.warn('Error parsing certificate info:', err);
    return { subjectCN: null, issuerCN: null };
  }
}

// Verify COSE_Sign1 signature
async function verifyCoseSign1(coseSign1, publicKey) {
  try {
    console.log('=== VERIFYING COSE_Sign1 SIGNATURE ===');
    
    // COSE_Sign1 = [protected, unprotected, payload, signature]
    if (!Array.isArray(coseSign1) || coseSign1.length < 4) {
      throw new Error('Invalid COSE_Sign1 structure');
    }
    
    const [protectedHeader, unprotectedHeader, payload, signature] = coseSign1;
    
    console.log('Protected header length:', protectedHeader?.length || 0);
    console.log('Payload length:', payload?.length || 0);
    console.log('Signature length:', signature?.length || 0);
    
    // Convert protected header to Uint8Array if it's not already
    const protectedHeaderBytes = protectedHeader instanceof Uint8Array 
      ? protectedHeader 
      : new Uint8Array(protectedHeader);
    
    const payloadBytes = payload instanceof Uint8Array 
      ? payload 
      : new Uint8Array(payload);
      
    console.log('Protected header bytes:', hex(protectedHeaderBytes));
    console.log('Payload bytes (first 32):', hex(payloadBytes.slice(0, 32)));
    
    // Reconstruct Sig_structure per RFC 8152 Section 4.4
    // Sig_structure = [
    //   context : "Signature1",
    //   body_protected : bstr .cbor header_map,
    //   external_aad : bstr,
    //   payload : bstr
    // ]
    // 
    // CRITICAL: protectedHeaderBytes and payloadBytes are ALREADY CBOR-encoded,
    // so we need to manually build the array with them as bstr, not let CBOR.encode()
    // double-encode them.
    
    // Manually construct Sig_structure CBOR:
    // 84                    # array(4)
    //   6A 5369676E617475726531  # text(10) "Signature1"
    //   43 <protected bytes>      # bstr(3) - protected header (already CBOR)
    //   40                        # bstr(0) - empty AAD
    //   59 XXXX <payload bytes>   # bstr(length) - payload (already CBOR)
    
    function encodeBstr(bytes) {
      // CBOR byte string encoding
      const len = bytes.length;
      if (len <= 23) {
        return new Uint8Array([0x40 + len, ...bytes]);
      } else if (len <= 0xFF) {
        return new Uint8Array([0x58, len, ...bytes]);
      } else if (len <= 0xFFFF) {
        return new Uint8Array([0x59, len >> 8, len & 0xFF, ...bytes]);
      } else {
        throw new Error('Payload too large for this implementation');
      }
    }
    
    const sigStructureParts = [];
    
    // Array header: 84 (array of 4 elements)
    sigStructureParts.push(new Uint8Array([0x84]));
    
    // Element 1: "Signature1" as text string
    const contextStr = "Signature1";
    const contextBytes = new TextEncoder().encode(contextStr);
    sigStructureParts.push(new Uint8Array([0x6A, ...contextBytes])); // 0x6A = text(10)
    
    // Element 2: protected header as bstr
    sigStructureParts.push(encodeBstr(protectedHeaderBytes));
    
    // Element 3: empty AAD as bstr
    sigStructureParts.push(new Uint8Array([0x40])); // empty byte string
    
    // Element 4: payload as bstr
    sigStructureParts.push(encodeBstr(payloadBytes));
    
    // Concatenate all parts
    const totalLength = sigStructureParts.reduce((sum, part) => sum + part.length, 0);
    const sigStructureBytes = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of sigStructureParts) {
      sigStructureBytes.set(part, offset);
      offset += part.length;
    }
    
    console.log('Sig_structure CBOR (manual):', hex(sigStructureBytes));
    console.log('Sig_structure length:', sigStructureBytes.length);
    
    // Convert signature to the format expected by Web Crypto
    // COSE signature is raw r||s format (64 bytes for P-256)
    // Web Crypto expects the same format for ECDSA
    const signatureBytes = new Uint8Array(signature);
    console.log('Signature bytes:', hex(signatureBytes));
    
    if (signatureBytes.length !== 64) {
      console.warn('‚ö†Ô∏è Expected 64-byte signature for ES256, got', signatureBytes.length);
    }
    
    // Verify the signature
    // Web Crypto will hash the data with SHA-256 internally for ES256
    const isValid = await crypto.subtle.verify(
      {
        name: 'ECDSA',
        hash: { name: 'SHA-256' }
      },
      publicKey,
      signatureBytes,
      sigStructureBytes // Verify against the original Sig_structure (will be hashed internally)
    );
    
    console.log('Signature verification result:', isValid);
    return isValid;
    
  } catch (err) {
    console.error('‚ùå Signature verification error:', err);
    throw err;
  }
}

// Helper: Convert CBOR structures to plain JSON
function convertToJSON(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  // Handle CBOR.Tagged values
  if (obj instanceof CBOR.Tagged) {
    if (obj.tag === 1004) {
      // full-date
      return { _type: 'full-date', value: obj.value };
    } else if (obj.tag === 0) {
      // date-time string
      return { _type: 'date-time', value: obj.value };
    } else if (obj.tag === 1) {
      // epoch timestamp
      return { _type: 'epoch', value: obj.value };
    } else if (obj.tag === 24) {
      // Encoded CBOR data item
      try {
        const decoded = CBOR.decode(new Uint8Array(obj.value).buffer);
        return convertToJSON(decoded);
      } catch (e) {
        return { _type: 'encoded-cbor', _tag: obj.tag, value: Array.from(new Uint8Array(obj.value)) };
      }
    } else {
      return { _tag: obj.tag, value: convertToJSON(obj.value) };
    }
  }
  
  // Handle Map
  if (obj instanceof Map) {
    const result = {};
    for (const [key, value] of obj.entries()) {
      result[String(key)] = convertToJSON(value);
    }
    return result;
  }
  
  // Handle Uint8Array and other ArrayBuffer views
  if (obj instanceof Uint8Array || ArrayBuffer.isView(obj)) {
    return {
      _type: 'bytes',
      _length: obj.length,
      _base64: btoa(String.fromCharCode(...new Uint8Array(obj)))
    };
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => convertToJSON(item));
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return obj.toISOString();
  }
  
  // Handle plain objects
  if (typeof obj === 'object') {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertToJSON(value);
    }
    return result;
  }
  
  // Primitives
  return obj;
}

// Display DeviceResponse in a nice format
function displayDeviceResponse(deviceResponse) {
  console.log('=== DISPLAYING DEVICE RESPONSE ===');
  
  // Show the response section
  responseSectionEl.style.display = 'block';
  
  // Scroll to response
  setTimeout(() => {
    responseSectionEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
  
  // Handle both Map and Object formats
  const getField = (obj, key) => {
    if (obj instanceof Map) return obj.get(key);
    return obj[key];
  };
  
  // Extract version
  const version = getField(deviceResponse, 'version') || '1.0';
  
  // Extract documents
  const documents = getField(deviceResponse, 'documents');
  
  if (!documents || !Array.isArray(documents) || documents.length === 0) {
    responseDisplayEl.innerHTML = `
      <div class="response-header">
        <h3>üéâ Response Received</h3>
        <div class="response-meta">Version: ${version}</div>
      </div>
      <div class="no-data">No documents found in response</div>
    `;
    return;
  }
  
  // Build HTML
  let html = `
    <div class="response-header">
      <h3>üéâ Response Received</h3>
      <div class="response-meta">Version: ${version} ‚Ä¢ ${documents.length} document(s)</div>
      <button id="btnCopyResponse" class="copy-btn" style="margin-top: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
        üìã Copy as JSON
      </button>
    </div>
  `;
  
  // Process each document
  documents.forEach((doc, docIndex) => {
    const docType = getField(doc, 'docType') || 'Unknown';
    
    html += `
      <div class="document-card">
        <div class="document-type">üìÑ ${escapeHtml(docType)}</div>
    `;
    
    // Extract issuerSigned
    const issuerSigned = getField(doc, 'issuerSigned');
    if (!issuerSigned) {
      html += '<div class="no-data">No issuerSigned data</div>';
      html += '</div>';
      return;
    }
    
    // Extract namespaces
    const nameSpaces = getField(issuerSigned, 'nameSpaces');
    if (!nameSpaces) {
      html += '<div class="no-data">No nameSpaces data</div>';
      html += '</div>';
      return;
    }
    
    // Handle both Map and Object for nameSpaces
    const nsEntries = nameSpaces instanceof Map 
      ? Array.from(nameSpaces.entries())
      : Object.entries(nameSpaces);
    
    // Process each namespace
    nsEntries.forEach(([nsName, nsItems]) => {
      html += `
        <div class="namespace-section">
          <div class="namespace-title">üì¶ ${escapeHtml(nsName)}</div>
      `;
      
      if (!Array.isArray(nsItems) || nsItems.length === 0) {
        html += '<div class="no-data">No items in namespace</div>';
        html += '</div>';
        return;
      }
      
      // Process each item in the namespace
      nsItems.forEach((item, itemIndex) => {
        try {
          // Items are IssuerSignedItem objects, possibly tag(24) wrapped
          let issuerSignedItem = item;
          
          // Unwrap tag(24) if present
          if (item instanceof CBOR.Tagged && item.tag === 24) {
            const itemBytes = new Uint8Array(item.value);
            issuerSignedItem = CBOR.decode(itemBytes.buffer);
          }
          
          // Extract fields from IssuerSignedItem
          const elementIdentifier = getField(issuerSignedItem, 'elementIdentifier');
          const elementValue = getField(issuerSignedItem, 'elementValue');
          
          if (elementIdentifier && elementValue !== undefined) {
            // Format the value based on type
            let valueHtml;
            let rawValue = elementValue;
            
            // Handle CBOR tagged values
            if (elementValue instanceof CBOR.Tagged) {
              if (elementValue.tag === 1004) {
                // Tag 1004 = full-date (tdate) - ISO 8601 date string
                const dateStr = elementValue.value;
                try {
                  const date = new Date(dateStr);
                  const formatted = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                  });
                  valueHtml = `<div class="data-value">üìÖ ${formatted} <span class="binary" style="font-size:0.85em">(${dateStr})</span></div>`;
                  rawValue = dateStr;
                } catch (e) {
                  valueHtml = `<div class="data-value">${escapeHtml(String(elementValue.value))}</div>`;
                  rawValue = elementValue.value;
                }
              } else if (elementValue.tag === 0) {
                // Tag 0 = date-time string
                valueHtml = `<div class="data-value">üïê ${escapeHtml(elementValue.value)}</div>`;
                rawValue = elementValue.value;
              } else if (elementValue.tag === 1) {
                // Tag 1 = epoch timestamp
                const date = new Date(elementValue.value * 1000);
                valueHtml = `<div class="data-value">üïê ${date.toLocaleString()}</div>`;
                rawValue = elementValue.value;
              } else {
                // Other tagged values
                valueHtml = `<div class="data-value">Tag(${elementValue.tag}): ${escapeHtml(String(elementValue.value))}</div>`;
                rawValue = elementValue.value;
              }
            } else if (elementValue instanceof Uint8Array || ArrayBuffer.isView(elementValue)) {
              // Binary data (like portrait)
              const byteLength = elementValue.length;
              
              // Try to detect if it's an image
              if (elementIdentifier.toLowerCase().includes('portrait') || 
                  elementIdentifier.toLowerCase().includes('image') ||
                  elementIdentifier.toLowerCase().includes('photo')) {
                // Detect image format by magic bytes
                let mimeType = 'application/octet-stream';
                let formatLabel = 'Unknown';
                
                if (elementValue.length >= 2) {
                  // JPEG: FF D8 FF
                  if (elementValue[0] === 0xFF && elementValue[1] === 0xD8 && elementValue[2] === 0xFF) {
                    mimeType = 'image/jpeg';
                    formatLabel = 'JPEG';
                  }
                  // JPEG2000: 00 00 00 0C 6A 50 20 20 0D 0A 87 0A (JP2 signature box)
                  else if (elementValue.length >= 12 &&
                           elementValue[0] === 0x00 && elementValue[1] === 0x00 &&
                           elementValue[2] === 0x00 && elementValue[3] === 0x0C &&
                           elementValue[4] === 0x6A && elementValue[5] === 0x50 &&
                           elementValue[6] === 0x20 && elementValue[7] === 0x20 &&
                           elementValue[8] === 0x0D && elementValue[9] === 0x0A &&
                           elementValue[10] === 0x87 && elementValue[11] === 0x0A) {
                    mimeType = 'image/jp2';
                    formatLabel = 'JPEG2000';
                  }
                  // Alternative JPEG2000 codestream: FF 4F FF 51
                  else if (elementValue[0] === 0xFF && elementValue[1] === 0x4F &&
                           elementValue.length >= 4 &&
                           elementValue[2] === 0xFF && elementValue[3] === 0x51) {
                    mimeType = 'image/jp2';
                    formatLabel = 'JPEG2000';
                  }
                }
                
                // Try to display as image using base64 data URI
                try {
                  let base64;
                  let displayMimeType = mimeType;
                  let displayFormat = formatLabel;
                  
                  if (mimeType === 'image/jp2') {
                    // JPEG2000 - provide download link since browsers don't support it natively
                    const portraitId = `portrait-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    valueHtml = `
                      <div class="data-value portrait-preview">
                        ${createJp2DownloadLink(elementValue, portraitId)}
                        <span class="binary" style="margin-top: 0.5rem;">${byteLength.toLocaleString()} bytes (${formatLabel})</span>
                      </div>
                    `;
                  } else {
                    // JPEG or other formats - display directly
                    base64 = btoa(String.fromCharCode(...elementValue));
                    const dataUri = `data:${displayMimeType};base64,${base64}`;
                    valueHtml = `
                      <div class="data-value portrait-preview">
                        <img src="${dataUri}" alt="Portrait" class="portrait-thumbnail" />
                        <span class="binary">${byteLength.toLocaleString()} bytes (${displayFormat})</span>
                      </div>
                    `;
                  }
                } catch (e) {
                  valueHtml = `<div class="data-value binary">&lt;binary data, ${byteLength.toLocaleString()} bytes&gt;</div>`;
                }
              } else {
                valueHtml = `<div class="data-value binary">&lt;binary data, ${byteLength.toLocaleString()} bytes&gt;</div>`;
              }
            } else if (elementValue instanceof Date) {
              valueHtml = `<div class="data-value">${elementValue.toISOString().split('T')[0]}</div>`;
            } else if (Array.isArray(elementValue)) {
              // Array value (like driving_privileges)
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${escapeHtml(JSON.stringify(elementValue, null, 2))}</pre></div>`;
            } else if (typeof elementValue === 'object' && elementValue !== null) {
              // Object value
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${escapeHtml(JSON.stringify(elementValue, null, 2))}</pre></div>`;
            } else if (typeof elementValue === 'boolean') {
              valueHtml = `<div class="data-value">${elementValue ? '‚úì Yes' : '‚úó No'}</div>`;
            } else {
              valueHtml = `<div class="data-value">${escapeHtml(String(elementValue))}</div>`;
            }
            
            html += `
              <div class="data-item">
                <div class="data-label">${escapeHtml(formatFieldName(elementIdentifier))}</div>
                ${valueHtml}
              </div>
            `;
          }
        } catch (itemError) {
          console.error('Error processing item:', itemError);
          html += `
            <div class="data-item">
              <div class="data-label">Item ${itemIndex + 1}</div>
              <div class="data-value binary">(parse error: ${escapeHtml(itemError.message)})</div>
            </div>
          `;
        }
      });
      
      html += '</div>'; // End namespace-section
    });
    
    // Add signer information and signature verification section
    const issuerAuth = getField(issuerSigned, 'issuerAuth');
    if (issuerAuth) {
      html += `
        <div class="signer-section" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
          <div style="font-weight: bold; margin-bottom: 10px; color: #007bff;">üîê Issuer Signature Information</div>
      `;
      
      try {
        // issuerAuth is a COSE_Sign1 structure
        // Decode if it's wrapped in tag(24)
        let coseSign1 = issuerAuth;
        
        console.log('=== PARSING ISSUER AUTH ===');
        console.log('issuerAuth type:', issuerAuth?.constructor?.name);
        console.log('issuerAuth:', issuerAuth);
        
        if (issuerAuth instanceof CBOR.Tagged && issuerAuth.tag === 24) {
          console.log('Unwrapping tag(24)...');
          const coseBytes = new Uint8Array(issuerAuth.value);
          console.log('COSE bytes length:', coseBytes.length);
          coseSign1 = CBOR.decode(coseBytes.buffer);
          console.log('Decoded COSE_Sign1:', coseSign1);
        }
        
        // COSE_Sign1 = [protected, unprotected, payload, signature]
        if (Array.isArray(coseSign1) && coseSign1.length >= 4) {
          const [protectedHeader, unprotectedHeader, payload, signature] = coseSign1;
          
          console.log('Protected header:', protectedHeader);
          console.log('Unprotected header:', unprotectedHeader);
          console.log('Payload length:', payload?.length);
          console.log('Signature length:', signature?.length);
          
          // Decode protected header
          let protectedData = {};
          if (protectedHeader && protectedHeader.length > 0) {
            try {
              // CRITICAL FIX: Create a new independent buffer from the view
              // protectedHeader is a Uint8Array view, we need to copy it to decode correctly
              const protectedHeaderCopy = new Uint8Array(protectedHeader);
              console.log('Protected header bytes to decode:', hex(protectedHeaderCopy));
              const decoded = CBOR.decode(protectedHeaderCopy.buffer);
              console.log('Decoded protected header:', decoded);
              if (decoded instanceof Map) {
                protectedData = Object.fromEntries(decoded);
              } else {
                protectedData = decoded;
              }
              console.log('Protected data:', protectedData);
            } catch (e) {
              console.warn('Could not decode protected header:', e);
            }
          }
          
          // Display algorithm
          const alg = protectedData[1] || (unprotectedHeader instanceof Map ? unprotectedHeader.get(1) : unprotectedHeader?.[1]);
          console.log('Algorithm value:', alg);
          console.log('Algorithm from protected:', protectedData[1]);
          console.log('Algorithm from unprotected:', unprotectedHeader instanceof Map ? unprotectedHeader.get(1) : unprotectedHeader?.[1]);
          
          let algName = 'Unknown';
          if (alg === -7) algName = 'ES256 (ECDSA with SHA-256)';
          else if (alg === -35) algName = 'ES384 (ECDSA with SHA-384)';
          else if (alg === -36) algName = 'ES512 (ECDSA with SHA-512)';
          else if (alg === -8) algName = 'EdDSA';
          else if (alg) algName = `Algorithm ${alg}`;
          
          console.log('Algorithm name:', algName);
          
          html += `
            <div class="data-item">
              <div class="data-label">Signature Algorithm</div>
              <div class="data-value">${escapeHtml(algName)}</div>
            </div>
          `;
          
          // Display certificate chain if present (x5chain)
          const x5chain = unprotectedHeader instanceof Map ? unprotectedHeader.get(33) : unprotectedHeader?.[33];
          if (x5chain) {
            const certCount = Array.isArray(x5chain) ? x5chain.length : 1;
            html += `
              <div class="data-item">
                <div class="data-label">Certificate Chain</div>
                <div class="data-value">‚úì ${certCount} certificate(s) provided</div>
              </div>
            `;
            
            // Extract and display certificate information
            try {
              const cert = Array.isArray(x5chain) ? x5chain[0] : x5chain;
              if (cert instanceof Uint8Array || ArrayBuffer.isView(cert)) {
                html += `
                  <div class="data-item">
                    <div class="data-label">Certificate Size</div>
                    <div class="data-value">${cert.length} bytes</div>
                  </div>
                `;
                
                // Extract Subject CN and Issuer CN
                const certInfo = extractCertInfo(cert);
                
                if (certInfo.subjectCN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Subject CN</div>
                      <div class="data-value">${escapeHtml(certInfo.subjectCN)}</div>
                    </div>
                  `;
                }
                
                if (certInfo.issuerCN) {
                  html += `
                    <div class="data-item">
                      <div class="data-label">Issuer CN</div>
                      <div class="data-value">${escapeHtml(certInfo.issuerCN)}</div>
                    </div>
                  `;
                }
              }
            } catch (certError) {
              console.warn('Certificate parsing error:', certError);
            }
          }
          
          // Display signature
          if (signature instanceof Uint8Array || ArrayBuffer.isView(signature)) {
            html += `
              <div class="data-item">
                <div class="data-label">Signature</div>
                <div class="data-value binary">${signature.length} bytes</div>
              </div>
            `;
            
            // Signature verification status (will be updated asynchronously)
            const verifyId = `verify-${docIndex}`;
            html += `
              <div class="data-item">
                <div class="data-label">Verification Status</div>
                <div class="data-value" id="${verifyId}" style="color: #6c757d;">üîÑ Verifying signature...</div>
              </div>
            `;
            
            // Perform verification asynchronously
            // Capture variables in closure for async callback
            const capturedCoseSign1 = coseSign1;
            const capturedX5chain = x5chain;
            
            setTimeout(async () => {
              const statusEl = document.getElementById(verifyId);
              if (!statusEl) return;
              
              try {
                // Extract public key from certificate
                const cert = Array.isArray(capturedX5chain) ? capturedX5chain[0] : capturedX5chain;
                if (!cert) {
                  statusEl.innerHTML = '<span style="color: #ffc107;">‚ö†Ô∏è No certificate found for verification</span>';
                  return;
                }
                
                statusEl.innerHTML = '<span style="color: #6c757d;">üîÑ Extracting public key from certificate...</span>';
                const publicKey = await extractPublicKeyFromCert(cert);
                
                statusEl.innerHTML = '<span style="color: #6c757d;">üîÑ Verifying ECDSA signature...</span>';
                const isValid = await verifyCoseSign1(capturedCoseSign1, publicKey);
                
                if (isValid) {
                  statusEl.innerHTML = '<span style="color: #28a745;">‚úÖ Signature verified successfully!</span>';
                  log(`‚úÖ Document ${docIndex + 1} signature verified`);
                } else {
                  statusEl.innerHTML = '<span style="color: #dc3545;">‚ùå Signature verification failed</span>';
                  log(`‚ùå Document ${docIndex + 1} signature verification failed`);
                }
              } catch (verifyError) {
                console.error('Verification error:', verifyError);
                statusEl.innerHTML = `<span style="color: #dc3545;">‚ùå Verification error: ${escapeHtml(verifyError.message)}</span>`;
                log(`‚ùå Document ${docIndex + 1} verification error: ${verifyError.message}`);
              }
            }, 100);
          }
          
          // Show payload size
          if (payload) {
            const payloadSize = payload instanceof Uint8Array ? payload.length : 
                               ArrayBuffer.isView(payload) ? payload.length :
                               JSON.stringify(payload).length;
            html += `
              <div class="data-item">
                <div class="data-label">Signed Payload</div>
                <div class="data-value">${payloadSize} bytes (MSO - Mobile Security Object)</div>
              </div>
            `;
          }
          
        } else {
          html += `<div class="data-value">‚ö†Ô∏è Unexpected COSE_Sign1 structure</div>`;
        }
        
      } catch (sigError) {
        console.error('Error parsing issuerAuth:', sigError);
        html += `
          <div class="data-item">
            <div class="data-value" style="color: #dc3545;">‚ùå Error parsing signature: ${escapeHtml(sigError.message)}</div>
          </div>
        `;
      }
      
      html += '</div>'; // End signer-section
    } else {
      html += `
        <div class="signer-section" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">
          <div style="color: #856404;">‚ö†Ô∏è No issuer signature found (issuerAuth missing)</div>
        </div>
      `;
    }
    
    html += '</div>'; // End document-card
  });
  
  responseDisplayEl.innerHTML = html;
  
  // Add copy button event listener
  setTimeout(() => {
    const btnCopy = document.getElementById('btnCopyResponse');
    if (btnCopy) {
      btnCopy.addEventListener('click', async () => {
        try {
          // Convert deviceResponse to a clean JSON object
          const jsonData = convertToJSON(deviceResponse);
          const jsonString = JSON.stringify(jsonData, null, 2);
          
          await navigator.clipboard.writeText(jsonString);
          
          // Visual feedback
          const originalText = btnCopy.textContent;
          btnCopy.textContent = '‚úÖ Copied!';
          btnCopy.style.background = '#218838';
          
          setTimeout(() => {
            btnCopy.textContent = originalText;
            btnCopy.style.background = '#28a745';
          }, 2000);
          
          log('üìã Response copied to clipboard as JSON');
        } catch (err) {
          console.error('Copy failed:', err);
          log('‚ùå Failed to copy: ' + err.message);
        }
      });
    }
  }, 100);
  
  log('‚úÖ Response decrypted and displayed successfully!');
  
  // Automatic cleanup: Send END state and close connection
  setTimeout(async () => {
    try {
      // Check if still connected and characteristic is valid
      if (device?.gatt?.connected && chState) {
        try {
          log('üîö Sending END state (0x02) to wallet...');
          await writeState(0x02);
          log('‚úÖ END state sent');
          
          // Give wallet time to process, then disconnect
          setTimeout(() => {
            if (device?.gatt?.connected) {
              log('üîå Closing BLE connection...');
              device.gatt.disconnect();
              log('‚úÖ Connection closed - ready for next scan');
            }
          }, 500);
        } catch (stateError) {
          // Wallet already disconnected or GATT service gone
          console.log('State write skipped (wallet disconnected):', stateError.message);
          if (device?.gatt?.connected) {
            device.gatt.disconnect();
          }
          log('‚úÖ Connection closed - ready for next scan');
        }
      } else {
        // Already disconnected by wallet
        log('‚úÖ Wallet disconnected - ready for next scan');
      }
    } catch (cleanupError) {
      console.error('Cleanup error:', cleanupError);
      log('‚úÖ Session ended - ready for next scan');
    }
  }, 1000); // Wait 1 second before cleanup
}

// Helper: Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Decrypt SessionEstablishment response data field (raw AES-GCM format)
async function decryptSessionEstablishmentData(encryptedData) {
  console.log('=== DECRYPTING SESSION ESTABLISHMENT DATA ===');
  console.log('Encrypted data length:', encryptedData.length);
  console.log('Encrypted data hex (first 64 bytes):', hex(encryptedData.slice(0, 64)));
  
  // Per ISO 18013-5: SessionEstablishment data field is RAW encrypted data
  // Format: ciphertext || 16-byte auth tag
  // Encrypted with SKDevice, counter starts at 1
  // IV = mdoc_identifier(8 bytes) || counter(4 bytes)
  
  // Mdoc identifier: 8 bytes, last byte is 0x01
  const mdocIdentifier = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);
  const counter = 1; // First message from mdoc
  
  // Build IV: identifier || counter (big-endian)
  const iv = new Uint8Array(12);
  iv.set(mdocIdentifier, 0);
  const dv = new DataView(iv.buffer, 8, 4);
  dv.setUint32(0, counter, false); // Big-endian
  
  console.log('IV for decryption:', hex(iv));
  console.log('  - Mdoc identifier (8 bytes):', hex(mdocIdentifier));
  console.log('  - Counter (4 bytes BE):', counter);
  console.log('Using SKDevice for decryption:', hex(skDevice));
  
  // Decrypt with AES-256-GCM
  const key = await crypto.subtle.importKey(
    'raw',
    skDevice,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
  
  try {
    const decrypted = await crypto.subtle.decrypt(
      { 
        name: 'AES-GCM', 
        iv, 
        additionalData: new Uint8Array(0), // Empty AAD per spec
        tagLength: 128 
      },
      key,
      encryptedData
    );
    
    const plaintext = new Uint8Array(decrypted);
    console.log('‚úÖ Decryption successful!');
    console.log('Plaintext length:', plaintext.length);
    console.log('Plaintext hex (first 64 bytes):', hex(plaintext.slice(0, 64)));
    
    // Decode the DeviceResponse
    const deviceResponse = CBOR.decode(plaintext.buffer);
    console.log('Decoded DeviceResponse:', deviceResponse);
    
    // Display the response
    displayDeviceResponse(deviceResponse);
    
  } catch (decryptError) {
    console.error('‚ùå Decryption failed:', decryptError);
    log('‚ùå Decryption failed - may be wrong key or IV');
    throw decryptError;
  }
}

// Helper: Format field names to be more readable
function formatFieldName(fieldName) {
  return fieldName
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

async function processSessionResponse(assembled) {
  console.log('=== FINALIZING SESSION FROM WALLET RESPONSE ===');
  console.log('Raw response bytes:', hex(assembled));

  if (!readerKeyPair) {
    throw new Error('Reader ephemeral key pair not initialized');
  }

  let decoded;
  try {
    decoded = CBOR.decode(assembled.buffer.slice(0));
    console.log('Decoded session response:', decoded);
  } catch (decodeError) {
    console.warn('Session response is not valid CBOR:', decodeError.message);
    decoded = null;
  }

  // Helper to coerce Map/Object into Map-like accessor
  const toMap = (value) => {
    if (!value) return null;
    if (value instanceof Map) return value;
    if (typeof value === 'object') {
      const map = new Map();
      for (const key of Object.keys(value)) {
        map.set(key, value[key]);
      }
      return map;
    }
    return null;
  };

  const decodedMap = toMap(decoded);
  let eDeviceKey = null;

  const possibleLabels = ['eDeviceKey', 'publicKey', 'deviceKey'];
  if (decodedMap) {
    for (const label of possibleLabels) {
      if (decodedMap.has(label)) {
        eDeviceKey = decodedMap.get(label);
        console.log(`Found potential wallet key under label "${label}"`);
        break;
      }
    }
  }

  // Some wallets nest the key inside the "deviceEngagement" or similar structures
  if (!eDeviceKey && decodedMap) {
    for (const value of decodedMap.values()) {
      const nested = toMap(value);
      if (nested) {
        for (const label of possibleLabels) {
          if (nested.has(label)) {
            eDeviceKey = nested.get(label);
            console.log(`Found nested wallet key under label "${label}"`);
            break;
          }
        }
      }
      if (eDeviceKey) break;
    }
  }

  let walletKeyMap = null;
  if (eDeviceKey) {
    if (eDeviceKey instanceof CBOR.Tagged) {
      console.log('Wallet key is CBOR.Tagged - decoding value');
      const value = eDeviceKey.value;
      const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);
      walletKeyMap = toMap(CBOR.decode(bytes.buffer.slice(0)));
    } else if (eDeviceKey instanceof Uint8Array) {
      console.log('Wallet key is raw Uint8Array - decoding');
      walletKeyMap = toMap(CBOR.decode(eDeviceKey.buffer.slice(0)));
    } else if (ArrayBuffer.isView(eDeviceKey)) {
      console.log('Wallet key is ArrayBuffer view - decoding');
      const bytes = new Uint8Array(eDeviceKey.buffer, eDeviceKey.byteOffset, eDeviceKey.byteLength);
      walletKeyMap = toMap(CBOR.decode(bytes.buffer.slice(0)));
    } else {
      walletKeyMap = toMap(eDeviceKey);
    }
  }

  if (walletKeyMap) {
    console.log('Wallet COSE_Key map:', walletKeyMap);
  }

  let sharedSecretBuffer = null;
  let usedEphemeralKey = false;

  if (walletKeyMap) {
    const xField = walletKeyMap.get(-2) || walletKeyMap.get('x');
    const yField = walletKeyMap.get(-3) || walletKeyMap.get('y');

    if (xField && yField) {
      console.log('Extracted wallet eDeviceKey coordinates');
      const x = new Uint8Array(xField);
      const y = new Uint8Array(yField);
      console.log('  x:', hex(x));
      console.log('  y:', hex(y));

      walletEphemeralKey = await importMdocPubKeyXY(x, y);
      sharedSecretBuffer = await deriveSharedSecretBits(readerKeyPair.privateKey, walletEphemeralKey);
      usedEphemeralKey = true;
      log('‚úÖ Derived shared secret using wallet ephemeral key');
    }
  }

  if (!sharedSecretBuffer) {
    log('‚ö†Ô∏è Wallet response did not contain an ephemeral key. Falling back to static DeviceEngagement key.');
    const mdocPub = await importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
    sharedSecretBuffer = await deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);
  }

  const sharedSecretBytes = new Uint8Array(sharedSecretBuffer);
  transcriptAAD = await buildTranscriptAAD();
  const keys = await deriveSessionKey(sharedSecretBytes, transcriptAAD);

  skReader = keys.readerKey;
  skDevice = keys.deviceKey;
  sessionKey = skReader; // Maintain compatibility with legacy code paths
  sessionEstablished = true;
  window.sessionEstablished = true;

  console.log('Session keys ready. SKReader:', hex(skReader));
  console.log('Session keys ready. SKDevice:', hex(skDevice));

  if (usedEphemeralKey) {
    log('üéØ Session established using wallet ephemeral key (ISO 18013-5 compliant)');
  } else {
    log('‚úÖ Session ready using static DeviceEngagement key');
  }

  // Now decrypt and display the documents from the 'data' field
  log('üîì Decrypting wallet response to extract documents...');
  
  // Get the 'data' field from the response (decodedMap already declared above)
  const responseData = decodedMap ? (decodedMap.get('data') || decodedMap.get(4)) : null;
  
  if (responseData && responseData.length > 0) {
    try {
      // The 'data' field contains RAW encrypted DeviceResponse (not COSE_Encrypt0)
      // Per ISO 18013-5: SessionEstablishment response uses same format as request
      // Format: ciphertext || 16-byte auth tag (encrypted with SKDevice)
      await decryptSessionEstablishmentData(responseData);
    } catch (decryptError) {
      console.error('Failed to decrypt documents:', decryptError);
      log('‚ùå Failed to decrypt documents: ' + decryptError.message);
    }
  } else {
    log('‚ö†Ô∏è No document data found in wallet response');
  }
}
async function writeState(byte) {
  await chState.writeValueWithoutResponse(Uint8Array.of(byte));
  log(`State set to 0x${byte.toString(16)}`);
}
async function sendFragmented(payload) {
  if (!chC2S) throw new Error('Client-to-Server characteristic not available');
  if (!device?.gatt?.connected) throw new Error('Device not connected');
  
  const sz = parseInt(chunkInput.value,10) || 20; // Web Bluetooth doesn't expose MTU
  let off = 0;
  while (off < payload.length) {
    const rem = payload.length - off;
    const take = Math.min(rem, sz);
    const last = rem <= sz;
    const frag = new Uint8Array(1 + take);
    frag[0] = last ? 0x00 : 0x01;
    frag.set(payload.slice(off, off+take), 1);
    
    try {
      await chC2S.writeValueWithoutResponse(frag);
      log(`C‚ÜíS write: flag=0x${frag[0].toString(16)} len=${take}`);
    } catch (e) {
      throw new Error(`Write failed: ${e.message}`);
    }
    
    off += take;
    
    // Small delay between fragments to avoid overwhelming the connection
    if (off < payload.length) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
  }
}

// ==== QR scanning ====
async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
  video.srcObject = stream;
  await video.play();
  canvas.width = video.videoWidth || 1280;
  canvas.height = video.videoHeight || 720;
  scanRunning = true;
  statusEl.textContent = 'Scanning‚Ä¶';
  requestAnimationFrame(tick);
}
function tick() {
  if (!scanRunning) return;
  const ctx2d = canvas.getContext('2d', { willReadFrequently:true });
  ctx2d.drawImage(video, 0, 0, canvas.width, canvas.height);
  const img = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
  const code = jsQR(img.data, img.width, img.height, { inversionAttempts: "dontInvert" });
  if (code?.data) {
    scanRunning = false; video.pause(); statusEl.textContent='QR detected';
    handleQrPayload(code.data, 'camera scan');
    return;
  }
  requestAnimationFrame(tick);
}
btnScan.addEventListener('click', () => startCamera().catch(e => log('Camera error: '+e.message)));

// Normalize QR payloads coming from camera, manual paste, or laser scanner.
async function handleQrPayload(raw, sourceLabel) {
  const payload = (raw || '').trim();
  if (!payload) {
    log('‚ö†Ô∏è No QR payload provided');
    statusEl.textContent = 'No payload';
    return;
  }

  try {
    const { uuid, addr } = parseMdocUriAndDE(payload);
    svcUUID = uuid;
    bleAddr = addr;
    svcUuidEl.textContent = uuid || '‚Äî';
    bleAddrEl.textContent = addr || '‚Äî';
    statusEl.textContent = `Parsed from ${sourceLabel}`;
    qrInput.value = payload;
    updateBleRoleUI();
    log(`‚úÖ Parsed QR payload from ${sourceLabel}. Service UUID: ${uuid || 'n/a'}`);
    
    // Show message to user about clicking to connect
    log('üöÄ Ready to connect! Click "Connect & Request Digital Credentials" below to continue...');
    
    // Enable and show a connect button
    if (!document.getElementById('btnAutoConnect')) {
      const connectBtn = document.createElement('button');
      connectBtn.id = 'btnAutoConnect';
      connectBtn.textContent = 'üöÄ Connect & Request Digital Credentials';
      connectBtn.style.cssText = 'margin: 1rem 0; padding: 0.75rem 1.5rem; font-size: 1.1em; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;';
      connectBtn.onclick = async () => {
        connectBtn.disabled = true;
        connectBtn.textContent = 'Connecting...';
        try {
          await autoConnectFlow();
          connectBtn.remove(); // Remove button after successful connection
        } catch (error) {
          connectBtn.disabled = false;
          connectBtn.textContent = 'üöÄ Connect & Start Session';
          log(`‚ùå Connection failed: ${error.message}`);
        }
      };
      
      // Insert button after the QR section
      const qrSection = document.getElementById('qrSection');
      qrSection.appendChild(connectBtn);
    }
    
  } catch (e) {
    log(`‚ùå ${sourceLabel} QR parse error: ${e.message}`);
    statusEl.textContent = 'Parse failed';
  }
}

// BLE Connection function (extracted from button handler)
async function bleConnect() {
  if (!svcUUID) throw new Error('Service UUID missing (scan QR or use override)');
  
  console.log('Starting BLE connection with UUID:', svcUUID);
  
  // Check if Web Bluetooth is supported
  if (!navigator.bluetooth) {
    throw new Error('Web Bluetooth not supported in this browser');
  }
  
  // Request device
  device = await navigator.bluetooth.requestDevice({ 
    filters: [{ services: [svcUUID] }], 
    optionalServices: [svcUUID] 
  });
  console.log('Device selected:', device);
  log(`Device selected: ${device.name || '(unnamed)'} (${device.id})`);
  
  // Setup disconnect handler
  device.addEventListener('gattserverdisconnected', () => {
    log('üì± Wallet disconnected from reader.');
    console.log('GATT server disconnected');
    
    // Reset connection state
    server = service = chState = chC2S = chS2C = null;
    
    log('üí° To continue, scan QR code again.');
  });
  
  console.log('Attempting GATT connection...');
  log(`Connecting to ${device.name || '(unnamed)'}‚Ä¶`);
  
  server = await device.gatt.connect();
  console.log('GATT connected, server:', server);
  log('GATT connected successfully');
  
  console.log('Getting primary service:', svcUUID);
  service = await server.getPrimaryService(svcUUID);
  console.log('Service found:', service);
  log('Service found');
  
  console.log('Getting characteristics...');
  chState = await service.getCharacteristic(UUIDS.state);
  console.log('State characteristic found:', chState);
  
  chC2S = await service.getCharacteristic(UUIDS.c2s);
  console.log('C2S characteristic found:', chC2S);
  
  chS2C = await service.getCharacteristic(UUIDS.s2c);
  console.log('S2C characteristic found:', chS2C);
  
  log('All characteristics found');
  
  console.log('Starting notifications...');
  await chS2C.startNotifications();
  chS2C.addEventListener('characteristicvaluechanged', handleServer2Client);
  console.log('Notifications started successfully');
  log('GATT ready. Notifications enabled.');
  
  console.log('‚è∏Ô∏è Session key derivation postponed until after SessionEstablishment response');
}

// Automated connection and session establishment flow
async function autoConnectFlow() {
  try {
    // Step 1: Connect to wallet
    if (!device || !server || !service) {
      log('üì± Connecting to wallet...');
      await bleConnect();
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait for connection to stabilize
    }
    
    // Step 2: Start session (state 0x01)
    if (chState) {
      log('üé¨ Starting session (state 0x01)...');
      await writeState(0x01);
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // Step 3: Send alternative SessionEstablishment
    log('üîê Sending SessionEstablishment...');
    
    // Reset session state
    _readerCoseKeyCached = null;
    skReader = null;
    skDevice = null;
    sessionKey = null;
    transcriptAAD = null;
    walletEphemeralKey = null;
    sessionEstablished = false;
    window.sessionEstablished = false;

    // Generate ephemeral key pair
    readerKeyPair = await makeReaderEphemeralKeyPair();
    await exportReaderPublicToCoseKey();
    log('‚úÖ Generated ephemeral key pair');
    
    // Build and send SessionEstablishment message
    const legacyMessage = await buildLegacySessionEstablishmentWithData();
    console.log('SessionEstablishment message length:', legacyMessage.length);
    await sendFragmented(legacyMessage);
    
    log('üì§ SessionEstablishment sent (includes encrypted document request).');
    
    // Note: The wallet will first respond with SessionEstablishment response (to finalize session keys)
    // Then it will send DeviceResponse with the actual documents
    log('‚è≥ Waiting for wallet to process request...');
    log('ÔøΩ You may need to approve data sharing in your wallet app');
    
  } catch (error) {
    console.error('Auto-connect flow error:', error);
    log(`‚ùå Auto-connect failed: ${error.message}`);
  }
}

// Function to send device request (extracted from btnSend click handler)
async function sendDeviceRequest() {
  try {
    if (!sessionEstablished || !skReader || !transcriptAAD) {
      throw new Error('Session not established. Run SessionEstablishment first.');
    }
    
    // CRITICAL: Check if we need to send state transition first
    log('üîç Verifying protocol state before request...');
    
    // Read current state to verify wallet is ready
    try {
      const stateValue = await chState.readValue();
      const currentState = stateValue.getUint8(0);
      log(`üìä Current protocol state: 0x${currentState.toString(16).padStart(2, '0')}`);
      
      if (currentState === 0x00) {
        log('‚ö†Ô∏è Wallet is in IDLE state (0x00) - must start protocol first!');
        throw new Error('Protocol not started - wallet in IDLE state');
      }
      
      if (currentState !== 0x01) {
        log(`‚ö†Ô∏è Unexpected state: 0x${currentState.toString(16)} (expected 0x01 for data transfer)`);
      }
    } catch (stateError) {
      log(`‚ö†Ô∏è Could not read state: ${stateError.message} - proceeding anyway`);
    }
    
    // Comprehensive connection verification
    log('üîç Verifying BLE connection before sending request...');
    
    if (!device || !device.gatt || !device.gatt.connected) {
      throw new Error('BLE device not connected. Please reconnect first.');
    }
    
    if (!service || !chC2S) {
      throw new Error('BLE service not available. Please reconnect.');
    }
    
    // Additional check: Try to verify service is still accessible
    // Note: This check may fail if wallet disconnected/reconnected, but that's okay
    try {
      const characteristics = await service.getCharacteristics();
      if (!characteristics.find(c => c.uuid === chC2S.uuid)) {
        log('‚ö†Ô∏è Service characteristics changed - wallet may have reconnected');
      } else {
        log('‚úÖ BLE service verification passed');
      }
    } catch (serviceError) {
      log('‚ö†Ô∏è Service verification skipped: ' + serviceError.message);
      log('üí° Attempting to send request anyway...');
    }
    
    // Get selected request type
    const selectedType = document.querySelector('input[name="requestType"]:checked')?.value || 'full';
    const isPID = selectedType.startsWith('pid_');
    const docType = isPID ? 'EU PID' : 'mDL';
    log(`Building ${selectedType} ${docType} request...`);
    
    // Brief pause to ensure wallet readiness
    log('‚è≥ Brief pause to ensure wallet readiness...');
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Re-verify connection after delay
    if (!device.gatt.connected) {
      throw new Error('Connection lost during preparation. Please reconnect.');
    }
    
    const req = buildRequestByType(selectedType);
    
    // Debug: Log the request structure
    try {
      const decoded = CBOR.decode(req);
      const requestDoc = decoded.docRequests[0].itemsRequest;
      const namespace = isPID ? "eu.europa.ec.eudi.pid.1" : "org.iso.18013.5.1";
      
      if (requestDoc.nameSpaces && requestDoc.nameSpaces[namespace]) {
        const fields = Object.keys(requestDoc.nameSpaces[namespace]);
        log(`üìã Requesting ${fields.length} fields from ${requestDoc.docType}`);
      }
    } catch (e) {
      console.error('Could not decode request for logging:', e);
    }
    
    // Final connection check before encryption
    if (!device.gatt.connected) {
      throw new Error('Connection lost before encryption. Please reconnect.');
    }
    
    // Encrypt and send
    const enc0 = await coseEncrypt0_AESGCM_Enc0(req, transcriptAAD, skReader);
    log(`Sending encrypted request (${enc0.length} bytes)...`);
    
    await sendFragmented(enc0);
    
    // Verify connection after send
    if (!device.gatt.connected) {
      log('‚ö†Ô∏è WARNING: BLE disconnected immediately after sending!');
    } else {
      log('‚úÖ BLE connection stable after send');
    }
    
    log(`‚úÖ ${selectedType.toUpperCase()} ${docType} request sent successfully.`);
    log('‚è≥ Waiting for wallet response...');
    log('üì± CHECK YOUR WALLET: You may need to approve the data sharing request');
    
  } catch (e) { 
    console.error('Send error:', e);
    log('Send error: ' + e.message);
    
    if (e.message.includes('GATT') || e.message.includes('not connected')) {
      log('üîÑ BLE Connection Issue Detected');
      log('üí° Try scanning the QR code again to reconnect');
    }
  }
}

btnParseQr.addEventListener('click', () => handleQrPayload(qrInput.value, 'manual input'));
btnClearQr.addEventListener('click', () => {
  qrInput.value = '';
  statusEl.textContent = 'Idle';
  qrInput.focus();
});

qrInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    handleQrPayload(qrInput.value, 'manual input');
  }
});

// ==== Manual Service UUID override ====
btnUseOverride.addEventListener('click', () => {
  const v = (svcOverrideInput.value || '').trim();
  if (!v) return;
  svcUUID = v;
  svcUuidEl.textContent = v;
  updateBleRoleUI(); // Update button states based on current mode
  log('Using manual Service UUID override.');
});

// ==== Robust mdoc URI ‚Üí CBOR extraction helpers ====
function b64ToBytesBrowserSafe(b64) {
  b64 = b64.replace(/\s+/g, '').replace(/[^A-Za-z0-9+/=]/g, '');
  const pad = b64.length % 4 === 0 ? 0 : (4 - (b64.length % 4));
  b64 += '='.repeat(pad);
  const raw = atob(b64);
  const out = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
  return out;
}
function b64urlToBytesSafe(maybeB64Url) {
  let s = maybeB64Url.trim();
  try { s = decodeURIComponent(s); } catch (_) {}
  s = s.replace(/-/g, '+').replace(/_/g, '/');
  return b64ToBytesBrowserSafe(s);
}
function looksLikeHex(s) {
  const cleaned = s.replace(/[\s:]/g, '');
  return cleaned.length >= 2 && /^[0-9A-Fa-f]+$/.test(cleaned);
}
function hexToBytes(s) {
  const cleaned = s.replace(/[\s:]/g, '');
  const out = new Uint8Array(cleaned.length / 2);
  for (let i = 0; i < cleaned.length; i += 2) out[i/2] = parseInt(cleaned.substr(i, 2), 16);
  return out;
}
function extractCborFromMdocUri(uri) {
  console.log('Extracting CBOR from URI:', uri);
  let s = uri.trim();
  const schemeMatch = s.match(/^[A-Za-z]+:/);
  if (schemeMatch) {
    console.log('Found scheme:', schemeMatch[0]);
    s = s.slice(schemeMatch[0].length);
  }
  console.log('After scheme removal:', s);

  if (/^data:application\/cbor;base64,/i.test(s)) {
    console.log('Detected data URI format');
    const b64 = s.split(',')[1] || '';
    console.log('Base64 part:', b64);
    const result = b64ToBytesBrowserSafe(b64);
    console.log('Decoded bytes from data URI:', hex(result));
    return result;
  }
  
  const qm = s.indexOf('?');
  if (qm >= 0) {
    console.log('Found query parameters at position:', qm);
    const params = new URLSearchParams(s.slice(qm + 1));
    console.log('Query parameters:', [...params.entries()]);
    const cand = params.get('de') || params.get('data') || params.get('ep');
    if (!cand) throw new Error('mdoc URI has query but no DE param');
    console.log('Found DE parameter:', cand);
    if (looksLikeHex(cand)) {
      console.log('DE parameter looks like hex');
      const result = hexToBytes(cand);
      console.log('Decoded bytes from hex:', hex(result));
      return result;
    }
    console.log('DE parameter looks like base64url');
    const result = b64urlToBytesSafe(cand);
    console.log('Decoded bytes from base64url:', hex(result));
    return result;
  }
  
  if (/[;,]/.test(s)) {
    console.log('Found semicolon/comma separators');
    const parts = s.split(/[;,]/).map(p => p.trim()).filter(Boolean).sort((a,b)=>b.length-a.length);
    console.log('Split parts:', parts);
    for (const part of parts) {
      try {
        console.log('Trying part:', part);
        const sub = part.replace(/^(de2?|ep|data):/i, '');
        console.log('After prefix removal:', sub);
        if (looksLikeHex(sub)) {
          console.log('Part looks like hex');
          const result = hexToBytes(sub);
          console.log('Decoded bytes from hex part:', hex(result));
          return result;
        }
        console.log('Part looks like base64url');
        const result = b64urlToBytesSafe(sub);
        console.log('Decoded bytes from base64url part:', hex(result));
        return result;
      } catch (e) {
        console.log('Failed to decode part:', part, e.message);
      }
    }
  }
  
  console.log('Trying final fallback methods...');
  try {
    if (looksLikeHex(s)) {
      console.log('URI looks like hex');
      const result = hexToBytes(s);
      console.log('Decoded bytes from hex URI:', hex(result));
      return result;
    }
    console.log('URI looks like base64url');
    const result = b64urlToBytesSafe(s); // your QR style: everything after "mdoc:"
    console.log('Decoded bytes from base64url URI:', hex(result));
    return result;
  } catch (e) {
    console.log('Fallback methods failed:', e.message);
    const m = uri.match(/[A-Za-z0-9\-_]{20,}={0,2}/);
    if (m) {
      console.log('Found potential base64 match:', m[0]);
      const result = b64urlToBytesSafe(m[0]);
      console.log('Decoded bytes from regex match:', hex(result));
      return result;
    }
    throw new Error('Unable to locate/normalize CBOR payload in mdoc URI');
  }
}

// ==== BLE options extraction (tolerant) - ENHANCED VERSION ====
function nodeKeys(n){
  if (!n) return [];
  if (n instanceof Map) return Array.from(n.keys()).map(String);
  if (Array.isArray(n)) return n.map((_,i)=>`[${i}]`);
  if (typeof n === 'object') return Object.keys(n);
  return [];
}

function tryExtractBleOptions(root) {
  // Helpers
  const isUUIDStr = (s) => typeof s === 'string' &&
    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(s);

  const asUuidString = (bytes) => {
    if (!(bytes instanceof Uint8Array) || bytes.length !== 16) return null;
    const h = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('');
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  };

  const takeFirst = (found) => {
    if (found.uuidStr) return { uuidStr: found.uuidStr.toLowerCase(), uuidBytes: null, addrBytes: found.addrBytes || null };
    if (found.uuidBytes) return { uuidBytes: found.uuidBytes, uuidStr: null, addrBytes: found.addrBytes || null };
    return null;
  };

  // Accumulator for what we find while walking
  const found = { uuidBytes: null, uuidStr: null, addrBytes: null };

  // Read "options" of a BLE method (accept Maps with int keys or plain objects)
  function readBleOptions(opts) {
    if (!opts) return;
    const scanKV = (k, v) => {
      // Numeric labels from drafts: 
      // 10 = service UUID (bstr 16); 11 = service UUID (alternative); 20 = BLE device address (bstr)
      if ((k === 10 || k === 11 || k === 'uuid' || k === 'serviceUuid' || k === 'service_uuid') && v) {
        if (!found.uuidBytes && v instanceof Uint8Array && v.length === 16) found.uuidBytes = v;
        if (!found.uuidStr  && isUUIDStr(v)) found.uuidStr = v;
      }
      if ((k === 20 || k === 'bleDeviceAddress' || k === 'address' || k === 'mac' || k === 'addr') && v instanceof Uint8Array) {
        if (!found.addrBytes) found.addrBytes = v;
      }
      // Some vendors nest { uuid: <bstr> } under another map
      if (v && typeof v === 'object') {
        if (v instanceof Map) {
          for (const [kk, vv] of v.entries()) scanKV(kk, vv);
        } else {
          for (const kk of Object.keys(v)) scanKV(kk, v[kk]);
        }
      }
    };

    if (opts instanceof Map) {
      for (const [k, v] of opts.entries()) scanKV(k, v);
    } else if (typeof opts === 'object') {
      for (const k of Object.keys(opts)) scanKV(k, opts[k]);
    }
  }

  // Decide whether a node is a BLE "method"
  function isBleMethod(node) {
    if (!node) return false;

    // Numeric code under key 0 or 'type': 2 = BLE in many drafts
    const typeNum = node instanceof Map ? (node.has(0) ? node.get(0) : (node.get('type') ?? node.get('t'))) :
                    (typeof node === 'object' ? (node.type ?? node.t ?? node[0]) : undefined);
    if (typeNum === 2) return true;

    // String fallback (transport/method fields)
    const getStr = (k) => {
      if (node instanceof Map) return (node.get(k) ?? '').toString().toLowerCase();
      if (typeof node === 'object') return (node[k] ?? '').toString().toLowerCase();
      return '';
    };
    const tstr = [getStr('transport'), getStr('method'), getStr('type')].join(' ');
    return ['ble','bluetooth','bluetoothle','gatt'].some(s => tstr.includes(s));
  }

  // For a method node, try to locate its "options" (common labels: 2, or "options", or nested "peripheral/server")
  function getMethodOptions(node) {
    if (!node) return null;
    if (node instanceof Map) {
      // numeric '2' is often used for options in draft encodings
      if (node.has(2)) return node.get(2);
      if (node.has('options')) return node.get('options');
      // try common nests
      return node.get('peripheral') || node.get('server') || node.get('central') || null;
    } else if (typeof node === 'object') {
      return node[2] || node.options || node.peripheral || node.server || node.central || null;
    }
    return null;
  }

  // DFS over any shape (Arrays, Maps, Objects)
  function dfs(node) {
    if (!node) return;
    
    // If this node itself looks like a BLE method, read its options immediately
    if (isBleMethod(node)) {
      readBleOptions(getMethodOptions(node));
      if (takeFirst(found)) return; // we've got enough
    }

    // Special handling for array patterns like [2, 1, {...options...}]
    if (Array.isArray(node) && node.length >= 3 && node[0] === 2) {
      // This looks like a BLE method: [type=2, param, options]
      readBleOptions(node[2]);
      if (takeFirst(found)) return;
    }

    if (Array.isArray(node)) {
      for (const it of node) dfs(it);
      return;
    }
    if (node instanceof Map) {
      for (const [k, v] of node.entries()) {
        // FIXED: Some DEs put "deviceRetrievalMethods" under key 1, 2, or string
        if (k === 1 || k === 2 || k === 'deviceRetrievalMethods' || k === 'methods' || k === 'transports') {
          dfs(v);
        } else {
          dfs(v);
        }
      }
      return;
    }
    if (typeof node === 'object') {
      for (const k of Object.keys(node)) {
        dfs(node[k]);
      }
    }
  }

  dfs(root);

  return takeFirst(found); // {uuidBytes|uuidStr, addrBytes} or null
}


const asUuidString = (bytes) => {
  if (!(bytes instanceof Uint8Array) || bytes.length !== 16) return null;
  const h = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
};

// ==== Parse mdoc URI + Device Engagement ====
function parseMdocUriAndDE(uri) {
  mdocUriEl.textContent = uri;
  console.log('Original URI:', uri);
  
  try {
    deBytes = extractCborFromMdocUri(uri);
    console.log('Extracted CBOR bytes:', hex(deBytes));
    console.log('CBOR bytes length:', deBytes.length);
  } catch (e) {
    console.error('Failed to extract CBOR from URI:', e);
    throw e;
  }

  // Decode CBOR; allow tag(24)-wrapped CBOR as fallback
  let de;
  try {
    console.log('Attempting first CBOR decode...');
    de = CBOR.decode(deBytes);
    console.log('First decode successful:', de);
  } catch (firstError) {
    console.log('First decode failed:', firstError.message);
    try {
      console.log('Attempting fallback decode...');
      const maybe = CBOR.decode(deBytes);
      console.log('Fallback intermediate result:', maybe);
      if (maybe instanceof CBOR.Tagged && maybe.tag === 24 && maybe.value instanceof Uint8Array) {
        console.log('Found tag(24), decoding inner value...');
        de = CBOR.decode(maybe.value);
        console.log('Tag(24) decode successful:', de);
      } else {
        console.error('Unexpected fallback structure:', maybe);
        throw new Error('CBOR decode failed for Device Engagement');
      }
    } catch (secondError) {
      console.error('Both decode attempts failed:', firstError, secondError);
      throw new Error('CBOR decode failed for Device Engagement: ' + firstError.message);
    }
  }

  // BLE options
  const bo = tryExtractBleOptions(de);
  if (!bo) throw new Error('BLE options not found in Device Engagement');

  let uuid = null;
  if (bo.uuidStr) uuid = bo.uuidStr;
  else if (bo.uuidBytes) uuid = asUuidString(bo.uuidBytes);

  let addr = null;
  if (bo.addrBytes) addr = Array.from(bo.addrBytes).map(b=>b.toString(16).padStart(2,'0')).join(':');

  // mdoc ephemeral COSE_Key (EC2 P-256 x/y)
  console.log('Device Engagement structure:', de);
  let coseKey = null;
  
  // ISO 18013-5: Security element can contain:
  // - Field 3: mdoc authentication public key (for signatures)
  // - Field 33: mdoc ephemeral public key eSenderKey (for ECDH) <-- WE NEED THIS ONE
  
  // Check if de.security is an array (as per spec)
  if (Array.isArray(de?.security)) {
    console.log('üìã DeviceEngagement.security is an array with', de.security.length, 'element(s)');
    
    // Look for the Security element containing field 33 (eSenderKey)
    for (let i = 0; i < de.security.length; i++) {
      const sec = de.security[i];
      console.log(`  Security[${i}]:`, sec);
      
      if (sec instanceof Map) {
        console.log(`    Field 3 (auth key):`, sec.has(3) ? 'present' : 'absent');
        console.log(`    Field 33 (eSenderKey):`, sec.has(33) ? 'present' : 'absent');
        
        // Prefer field 33 (eSenderKey for ECDH)
        if (sec.has(33)) {
          coseKey = sec.get(33);
          console.log('‚úÖ Using field 33 (eSenderKey) for ECDH from Security[' + i + ']');
          break;
        }
      } else if (typeof sec === 'object') {
        console.log(`    Field 3 (auth key):`, (3 in sec) ? 'present' : 'absent');
        console.log(`    Field 33 (eSenderKey):`, (33 in sec) ? 'present' : 'absent');
        
        // Prefer field 33 (eSenderKey for ECDH)
        if (33 in sec) {
          coseKey = sec[33];
          console.log('‚úÖ Using field 33 (eSenderKey) for ECDH from Security[' + i + ']');
          break;
        }
      }
    }
    
    // Fallback: if no field 33, try field 3 (but log a warning)
    if (!coseKey) {
      for (let i = 0; i < de.security.length; i++) {
        const sec = de.security[i];
        if (sec instanceof Map && sec.has(3)) {
          coseKey = sec.get(3);
          console.warn('‚ö†Ô∏è Using field 3 (auth key) as fallback - this might be wrong!');
          break;
        } else if (typeof sec === 'object' && (3 in sec)) {
          coseKey = sec[3];
          console.warn('‚ö†Ô∏è Using field 3 (auth key) as fallback - this might be wrong!');
          break;
        }
      }
    }
  } else if (de?.security) {
    console.log('üìã DeviceEngagement.security is NOT an array, it is:', typeof de.security);
    const sec = de.security;
    
    if (sec instanceof Map) {
      console.log('  Field 3 (auth key):', sec.has(3) ? 'present' : 'absent');
      console.log('  Field 33 (eSenderKey):', sec.has(33) ? 'present' : 'absent');
      
      if (sec.has(33)) {
        coseKey = sec.get(33);
        console.log('‚úÖ Using field 33 (eSenderKey) for ECDH');
      } else if (sec.has(3)) {
        coseKey = sec.get(3);
        console.warn('‚ö†Ô∏è Using field 3 (auth key) as fallback - this might be wrong!');
      }
    } else if (typeof sec === 'object') {
      console.log('  Field 3 (auth key):', (3 in sec) ? 'present' : 'absent');
      console.log('  Field 33 (eSenderKey):', (33 in sec) ? 'present' : 'absent');
      
      if (33 in sec) {
        coseKey = sec[33];
        console.log('‚úÖ Using field 33 (eSenderKey) for ECDH');
      } else if (3 in sec) {
        coseKey = sec[3];
        console.warn('‚ö†Ô∏è Using field 3 (auth key) as fallback - this might be wrong!');
      }
    }
  }
  
  // Old fallback code (if security not found at all)
  if (!coseKey && de?.security?.deviceKey) coseKey = de.security.deviceKey;
  if (!coseKey && de?.eDeviceKey) coseKey = de.eDeviceKey;
  if (!coseKey && de?.deviceKey)  coseKey = de.deviceKey;
  
  // Check for COSE_Key wrapped in CBOR tag(24)
  if (!coseKey) {
    console.log('Searching for COSE_Key in DE structure...');
    const scan = (o, path = '') => {
      if (!o) return null;
      
      // Check if this is a CBOR Tagged value that might contain a COSE_Key
      if (o instanceof CBOR.Tagged && o.tag === 24 && o.value instanceof Uint8Array) {
        console.log(`Found CBOR tag(24) at path: ${path}, attempting to decode...`);
        try {
          const decoded = CBOR.decode(o.value);
          console.log(`Decoded tag(24) content:`, decoded);
          
          // Check if the decoded content is a COSE_Key
          if (decoded instanceof Map) {
            if (decoded.get(1)===2 && decoded.get(-1)===1 && decoded.get(-2) && decoded.get(-3)) {
              console.log('Found COSE_Key inside tag(24) at path:', path);
              return decoded;
            }
          } else if (typeof decoded === 'object' && decoded[1]===2 && decoded[-1]===1 && decoded[-2] && decoded[-3]) {
            console.log('Found COSE_Key inside tag(24) at path:', path);
            return decoded;
          }
        } catch (e) {
          console.log(`Failed to decode tag(24) at ${path}:`, e.message);
        }
      }
      
      if (o instanceof Map) {
        // Check if this map is a COSE_Key (kty=2, crv=1, x=-2, y=-3)
        if (o.get(1)===2 && o.get(-1)===1 && o.get(-2) && o.get(-3)) {
          console.log('Found COSE_Key at path:', path);
          return o;
        }
        
        for (const [k, v] of o.entries()) { 
          const r = scan(v, `${path}.Map[${k}]`); 
          if (r) return r; 
        }
      } else if (typeof o === 'object' && !Array.isArray(o)) {
        // Check if this object is a COSE_Key
        if (o[1]===2 && o[-1]===1 && o[-2] && o[-3]) {
          console.log('Found COSE_Key at path:', path);
          return o;
        }
        
        for (const [k, v] of Object.entries(o)) { 
          const r = scan(v, `${path}.${k}`); 
          if (r) return r; 
        }
      } else if (Array.isArray(o)) {
        for (let i = 0; i < o.length; i++) { 
          const r = scan(o[i], `${path}[${i}]`); 
          if (r) return r; 
        }
      }
      return null;
    };
    coseKey = scan(de);
  }
  
  if (!coseKey) {
    console.error('COSE_Key not found. Full DE structure:', JSON.stringify(de, null, 2));
    throw new Error('mdoc ephemeral COSE_Key not found in DE');
  }
  
  console.log('Found COSE_Key:', coseKey);

  const getField = (k) => (coseKey instanceof Map ? coseKey.get(k) : coseKey[k]);
  
  // Log ALL fields in the COSE_Key
  console.log('üìã COSE_Key field analysis:');
  console.log('   kty (1):', getField(1), '(should be 2 for EC2)');
  console.log('   crv (-1):', getField(-1), '(should be 1 for P-256)');
  console.log('   alg (3):', getField(3), '(algorithm, if present)');
  
  const xField = getField(-2) || getField('x');
  const yField = getField(-3) || getField('y');
  
  console.log('üîç Raw COSE_Key fields before extraction:');
  console.log('  Field -2 (x):', xField);
  console.log('  Field -3 (y):', yField);
  console.log('  Field -2 type:', Object.prototype.toString.call(xField));
  console.log('  Field -3 type:', Object.prototype.toString.call(yField));
  
  const x = new Uint8Array(xField);
  const y = new Uint8Array(yField);
  
  console.log('Extracted mdoc public key coordinates (eSenderKey from wallet):');
  console.log('  x (should be 32 bytes):', hex(x), `(length: ${x.length})`);
  console.log('  y (should be 32 bytes):', hex(y), `(length: ${y.length})`);
  
  if (x.length !== 32 || y.length !== 32) {
    console.error('‚ùå Invalid key coordinate lengths:', x.length, y.length);
    throw new Error(`Invalid COSE_Key coordinates: x=${x.length}, y=${y.length} (expected 32 each)`);
  }
  
  mdocPubKey = { x, y };
  console.log('‚úÖ mdoc public key stored successfully');

  return { uuid, addr };
}

// ==== Session Establishment (ECDH + HKDF, Transcript AAD) ====
async function importMdocPubKeyXY(x, y) {
  const u = new Uint8Array(1 + x.length + y.length);
  u[0] = 0x04; u.set(x,1); u.set(y,1+x.length);
  return crypto.subtle.importKey('raw', u, { name:'ECDH', namedCurve:'P-256' }, true, []);
}
async function makeReaderEphemeralKeyPair() {
  return crypto.subtle.generateKey({ name:'ECDH', namedCurve:'P-256' }, true, ['deriveBits']);
}
async function deriveSharedSecretBits(privKey, pubKey) {
  console.log('üîê ECDH Key Agreement:');
  console.log('  Private key type:', privKey.type);
  console.log('  Public key type:', pubKey.type);
  
  // Export public key to verify it matches what we expect (only public keys can be exported as raw)
  try {
    const pubKeyRaw = new Uint8Array(await crypto.subtle.exportKey('raw', pubKey));
    console.log('  Public key (raw, 65 bytes):', hex(pubKeyRaw));
    console.log('  Public key X:', hex(pubKeyRaw.slice(1, 33)));
    console.log('  Public key Y:', hex(pubKeyRaw.slice(33, 65)));
  } catch (e) {
    console.log('  Public key export not available (might be non-extractable)');
  }
  
  const sharedSecret = await crypto.subtle.deriveBits({ name:'ECDH', public: pubKey }, privKey, 256);
  console.log('  Shared secret (32 bytes):', hex(new Uint8Array(sharedSecret)));
  console.log('  Shared secret (base64):', btoa(String.fromCharCode(...new Uint8Array(sharedSecret))));
  
  return sharedSecret;
}
async function hkdfExtract(saltBytes, ikmBytes) {
  // HKDF-Extract: PRK = HMAC-Hash(salt, IKM)
  // Use HMAC directly, not WebCrypto's HKDF (which does extract+expand together)
  const key = await crypto.subtle.importKey('raw', saltBytes, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const prk = await crypto.subtle.sign('HMAC', key, ikmBytes);
  return new Uint8Array(prk);
}
async function hkdfExpand(prkBytes, infoBytes, length) {
  const prk = await crypto.subtle.importKey('raw', prkBytes, { name:'HMAC', hash:'SHA-256' }, false, ['sign']);
  let t = new Uint8Array(0), okm = new Uint8Array(0), counter = 1;
  while (okm.length < length) {
    const input = concatUint8(t, infoBytes, Uint8Array.of(counter));
    const mac = new Uint8Array(await crypto.subtle.sign('HMAC', prk, input));
    okm = concatUint8(okm, mac);
    t = mac; counter++;
  }
  return okm.slice(0, length);
}
async function sha256(bytes) {
  return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes));
}

let _readerCoseKeyCached = null;
function buildReaderCoseKey() {
  if (!_readerCoseKeyCached) throw new Error('reader COSE_Key not ready');
  return _readerCoseKeyCached; // Map with integer labels
}
async function exportReaderPublicToCoseKey() {
  const raw = new Uint8Array(await crypto.subtle.exportKey('raw', readerKeyPair.publicKey)); // 0x04||X||Y
  const x = raw.slice(1, 33);
  const y = raw.slice(33, 65);
  
  // Create a unique fingerprint for this key
  const fingerprint = hex(x.slice(0, 4));
  
  console.log('üì§ [CACHE] Caching EReaderKey - fingerprint:', fingerprint);
  console.log('  [CACHE] X coordinate:', hex(x));
  console.log('  [CACHE] Y coordinate:', hex(y));
  
  // Store as Map - we'll handle encoding specially to avoid tag 64
  _readerCoseKeyCached = new Map([
    [  1, 2],  // kty: EC2
    [ -1, 1],  // crv: P-256  
    [ -2, x],  // x coordinate (Uint8Array)
    [ -3, y]   // y coordinate (Uint8Array)
  ]);
  
  console.log('[CACHE] Successfully cached EReaderKey with fingerprint:', fingerprint);
  return fingerprint; // Return for tracking
}


// Build transcript AAD: hash( [ DeviceEngagementBytes, EReaderKeyBytes, Handover ] )
async function buildTranscriptAAD() {
  console.log('=== BUILDING TRANSCRIPT AAD ===');
  
  if (!deBytes) {
    console.error('‚ùå DeviceEngagement bytes not available');
    throw new Error('DeviceEngagement bytes required for transcript AAD');
  }
  
  // Build EReaderKeyBytes = tag(24, bstr .cbor COSE_Key)
  const readerCoseKey = buildReaderCoseKey();
  
  // LOG: Verify which key we're using in transcript
  const keyX = readerCoseKey.get(-2);
  const keyY = readerCoseKey.get(-3);
  const fingerprint = hex(keyX.slice(0, 4));
  console.log('üîë [Transcript] Using EReaderKey - fingerprint:', fingerprint);
  console.log('   [Transcript] X:', hex(keyX));
  console.log('   [Transcript] Y:', hex(keyY));
  
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  const eReaderKeyBytes = encodeTag24ByteString(coseKeyEncoded);
  
  console.log('EReaderKeyBytes:', hex(eReaderKeyBytes));
  
  // Manually build the transcript array to avoid any CBOR library issues
  // SessionTranscript = [DeviceEngagementBytes, Handover, EReaderKeyBytes]
  // NOTE: Wallet puts Handover BEFORE EReaderKey, not after!
  
  // üîç MULTIPAZ CONFIRMED: Uses tag(24) wrapped COSE_Keys inside SessionTranscript
  // Then wraps the whole thing in tag(24, bstr(...)) before hashing
  const useUnwrappedKeys = false;  // Keep tag(24) wrappers on COSE_Keys
  
  const result = [];
  
  // Array with 3 items
  result.push(0x83);
  
  if (useUnwrappedKeys) {
    // Item 1: DeviceEngagement COSE_Key (unwrapped - no tag 24)
    result.push(...deBytes);
    
    // Item 2: EReaderKey COSE_Key (unwrapped - no tag 24)
    result.push(...coseKeyEncoded);
  } else {
    // Original: tag(24) wrapped versions
    // Item 1: tag(24, DeviceEngagementBytes)
    result.push(0xD8, 0x18);  // tag 24
    if (deBytes.length < 24) {
      result.push(0x40 + deBytes.length);
    } else if (deBytes.length < 256) {
      result.push(0x58, deBytes.length);
    } else {
      result.push(0x59, deBytes.length >> 8, deBytes.length & 0xFF);
    }
    result.push(...deBytes);
    
    // Item 2: EReaderKeyBytes (already contains tag 24)
    result.push(...eReaderKeyBytes);
  }
  
  // Item 3: Handover per ISO 18013-5 Section 9.1.5.1
  // Per spec: "If device engagement using QR code was used, the contents shall be QRHandover"
  // QRHandover = null
  // Even though we connect via BLE, the engagement method was QR code
  console.log('üîê Using QRHandover (null) - engagement was via QR code');
  result.push(0xF6);  // CBOR null
  
  console.log(useUnwrappedKeys ? 'üß™ SessionTranscript: [DeviceEngagement (unwrapped), EReaderKey (unwrapped), null]' : 'SessionTranscript: [DeviceEngagement, EReaderKey, null]');
  
  const trCbor = new Uint8Array(result);
  console.log('Transcript CBOR length (unwrapped):', trCbor.length);
  console.log('Transcript CBOR (full):', hex(trCbor));
  console.log('üîç Using unwrapped COSE_Keys (no tag 24):', useUnwrappedKeys);
  
  // Verify by decoding
  try {
    const decoded = CBOR.decode(trCbor.buffer);
    console.log('Transcript decoded (verification):', decoded);
  } catch (e) {
    console.error('Failed to decode transcript:', e);
  }
  
  // Per ISO 18013-5 Section 9.1.5.2:
  // SessionTranscriptBytes is the CBOR encoding of SessionTranscript
  // Salt = SHA-256(SessionTranscriptBytes)
  
  // üîç MULTIPAZ EXPECTS: tag(24, bstr(SessionTranscript)) before hashing!
  // This is what Multipaz does: Cbor.encode(Tagged(24, Bstr(encodedSessionTranscript)))
  const wrappedTranscript = encodeTag24ByteString(trCbor);
  
  console.log('üîç SessionTranscript for hashing (WRAPPED in tag 24 bstr):');
  console.log('Unwrapped length:', trCbor.length);
  console.log('Unwrapped hex:', hex(trCbor));
  console.log('Unwrapped base64:', btoa(String.fromCharCode(...trCbor)));
  console.log('Wrapped length:', wrappedTranscript.length);
  console.log('Wrapped hex:', hex(wrappedTranscript));
  console.log('Wrapped base64:', btoa(String.fromCharCode(...wrappedTranscript)));
  
  // Store for debugging
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.sessionTranscript = trCbor;
  window.sessionDebug.sessionTranscriptWrapped = wrappedTranscript;
  window.sessionDebug.deviceEngagement = deBytes;
  window.sessionDebug.eReaderKey = useUnwrappedKeys ? coseKeyEncoded : eReaderKeyBytes;
  window.sessionDebug.useUnwrappedKeys = useUnwrappedKeys;
  
  const aad = await sha256(wrappedTranscript);
  console.log('Transcript AAD (SHA-256 of tag(24, bstr(SessionTranscript))):', hex(aad));
  console.log('‚úÖ Transcript AAD built successfully');
  console.log('‚úÖ Using Multipaz approach: hash(tag(24, bstr(SessionTranscript)))');
  console.log('');
  console.log('üîç DEBUG: Copy this data to compare with Multipaz:');
  console.log('  SessionTranscript unwrapped (base64):', btoa(String.fromCharCode(...trCbor)));
  console.log('  SessionTranscript wrapped tag(24,bstr) (base64):', btoa(String.fromCharCode(...wrappedTranscript)));
  console.log('  Transcript Hash (hex):', hex(aad));
  
  return aad;
}

// Derive session keys per ISO 18013-5 standard
// Per spec Section 9.1.5.2:
// - Salt = SHA-256(SessionTranscriptBytes)
// - IKM = ZAB (shared secret from ECDH)
// - Info = "SKReader" or "SKDevice" (UTF-8 encoded)
// - L = 32 octets (for AES-256)
async function deriveSessionKey(sharedSecret, transcriptHash) {
  console.log('üîê Starting session key derivation (ISO 18013-5):');
  console.log('- Shared secret (ZAB) length:', sharedSecret.length);
  console.log('- Shared secret (hex):', hex(sharedSecret));
  console.log('- Shared secret (base64):', btoa(String.fromCharCode(...sharedSecret)));
  console.log('- Salt (SessionTranscript hash) length:', transcriptHash.length);
  console.log('- Salt (hex):', hex(transcriptHash));
  
  // HKDF-Extract: PRK = HKDF-Extract(salt, IKM)
  // salt = SHA-256(SessionTranscriptBytes)
  // IKM = shared secret (ZAB)
  const prk = await hkdfExtract(transcriptHash, sharedSecret);
  
  // HKDF-Expand for SKReader: info = "SKReader" (UTF-8)
  const readerInfo = enc.encode('SKReader');
  const readerKey = await hkdfExpand(prk, readerInfo, 32);  // 32 bytes for A256GCM
  
  // HKDF-Expand for SKDevice: info = "SKDevice" (UTF-8)
  const deviceInfo = enc.encode('SKDevice'); 
  const deviceKey = await hkdfExpand(prk, deviceInfo, 32);  // 32 bytes for A256GCM
  
  console.log('üîê ISO 18013-5 key derivation (AES-256-GCM):');
  console.log('- SKReader (32 bytes):', hex(readerKey));
  console.log('- SKReader (base64):', btoa(String.fromCharCode(...readerKey)));
  console.log('- SKDevice (32 bytes):', hex(deviceKey));
  console.log('- SKDevice (base64):', btoa(String.fromCharCode(...deviceKey)));
  console.log();
  console.log('üîç MULTIPAZ COMPARISON:');
  console.log('- Multipaz readerSK should match our SKReader');
  console.log('- Multipaz deviceSK should match our SKDevice');

  // Expose for debugging/inspection in devtools (non-production)
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.skReader = readerKey;
  window.sessionDebug.skDevice = deviceKey;
  window.sessionDebug.transcriptHash = transcriptHash;
  
  // CRITICAL: Return BOTH keys as object
  // Reader encrypts requests with SKReader
  // Reader decrypts responses with SKDevice
  return { readerKey, deviceKey };
}

// ==== Raw AES-256-GCM Encryption (for SessionEstablishment.data field) ====
// Per ISO 18013-5 Section 9.1.1.4, SessionEstablishment.data field is:
// "concatenation of the ciphertext and all 16 bytes of the authentication tag"
// This is RAW output from AES-GCM, NOT wrapped in COSE_Encrypt0 structure
//
// CRITICAL: AAD must be EMPTY per ISO 18013-5 Section 9.1.5.2:
// "The AAD used with the AES-GCM function shall be an empty string"
async function aesGcmEncryptRaw(plaintext, keyBytes, identifier8, messageCounter = 1) {
  console.log('=== RAW AES-256-GCM ENCRYPTION (for SessionEstablishment.data) ===');
  console.log('Plaintext length:', plaintext.length);
  console.log('Key length:', keyBytes.length, 'bytes (should be 32 for A256GCM)');
  console.log('Message counter:', messageCounter);
  
  // Build IV per ISO 18013-5: identifier (8 bytes) || counter (4 bytes big-endian)
  const iv = new Uint8Array(12);
  iv.set(identifier8, 0);  // 8-byte identifier (0x00√ó8 for reader)
  iv[8] = (messageCounter >> 24) & 0xFF;
  iv[9] = (messageCounter >> 16) & 0xFF;
  iv[10] = (messageCounter >> 8) & 0xFF;
  iv[11] = messageCounter & 0xFF;
  
  console.log('IV (identifier || counter):', hex(iv));
  console.log('  - Identifier (8 bytes):', hex(identifier8));
  console.log('  - Counter (4 bytes BE):', hex(iv.slice(8, 12)), '=', messageCounter);
  
  // AAD for GCM shall be EMPTY per ISO 18013-5 Section 9.1.5.2
  // "The AAD used with the AES-GCM function shall be an empty string"
  const aad = new Uint8Array(0);
  console.log('AAD for AES-GCM: <EMPTY> (per ISO 18013-5 Section 9.1.5.2)');
  console.log('‚ö†Ô∏è Note: This is DIFFERENT from COSE_Encrypt0 which uses Enc_structure');
  
  const key = await crypto.subtle.importKey('raw', keyBytes, 
    { name: 'AES-GCM', length: 256 }, false, ['encrypt']);
  
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: aad, tagLength: 128 },
    key, plaintext
  );
  
  const result = new Uint8Array(encrypted);
  console.log('Raw encrypted length:', result.length, '(plaintext + 16-byte auth tag)');
  console.log('Raw encrypted (first 32 bytes):', hex(result.slice(0, 32)));
  console.log('‚úÖ Returns: ciphertext || 16-byte authentication_tag (no COSE wrapper, no Enc_structure AAD)');
  
  return result;
}

// ==== COSE_Encrypt0 (AES-256-GCM per ISO 18013-5) ====
// CRITICAL: Per ISO 18013-5 Section 9.1.5.2:
// - IV = identifier (8 bytes) || message counter (4 bytes big-endian)
// - Reader identifier: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
// - Counter starts at 1 for first message
// - AAD for GCM function shall be EMPTY STRING
async function coseEncrypt0_AESGCM_Enc0(plaintext, externalAAD, keyBytes, messageCounter = 1) {
  console.log('=== COSE_Encrypt0 ENCRYPTION (ISO 18013-5) ===');
  console.log('Plaintext length:', plaintext.length);
  console.log('Key length:', keyBytes.length, 'bytes (should be 32 for A256GCM)');
  console.log('Message counter:', messageCounter);
  
  if (keyBytes.length !== 32) {
    console.warn('‚ö†Ô∏è WARNING: Key length is not 32 bytes - ISO 18013-5 requires AES-256-GCM');
  }
  
  // Build IV per ISO 18013-5: identifier (8 bytes) || counter (4 bytes big-endian)
  // Reader identifier: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
  const iv = new Uint8Array(12);
  // First 8 bytes are 0x00 (reader identifier)
  // Last 4 bytes are message counter in big-endian
  iv[8] = (messageCounter >> 24) & 0xFF;
  iv[9] = (messageCounter >> 16) & 0xFF;
  iv[10] = (messageCounter >> 8) & 0xFF;
  iv[11] = messageCounter & 0xFF;
  
  console.log('IV (identifier || counter):', hex(iv));
  console.log('  - Identifier (8 bytes):', hex(iv.slice(0, 8)));
  console.log('  - Counter (4 bytes BE):', hex(iv.slice(8, 12)), '=', messageCounter);
  
  // AAD for GCM shall be EMPTY per ISO 18013-5
  const aad = new Uint8Array(0);
  console.log('AAD for GCM: <empty> (per ISO 18013-5)');
  
  const key = await crypto.subtle.importKey('raw', keyBytes, { name:'AES-GCM' }, false, ['encrypt']);
  const ciphertext = new Uint8Array(
    await crypto.subtle.encrypt({ name:'AES-GCM', iv, additionalData: aad }, key, plaintext)
  );
  
  console.log('Ciphertext length:', ciphertext.length);
  console.log('Ciphertext (first 32 bytes):', hex(ciphertext.slice(0, 32)));

  // Capture IV/key usage for debugging from DevTools
  window.sessionDebug = window.sessionDebug || {};
  window.sessionDebug.lastEncrypt = {
    messageCounter,
    iv: iv.slice(),
    key: keyBytes.slice(),
    aad: externalAAD ? externalAAD.slice?.() || externalAAD : null,
    plaintextSample: plaintext.slice(0, 32)
  };
  
  // Build COSE_Encrypt0 structure per RFC 8152 and ISO 18013-5
  // MUST manually encode to avoid CBOR tag 64 being added to byte strings
  // Structure: [protected, unprotected, ciphertext]
  
  // 1. Protected header: bstr containing {1: 3} for A256GCM
  //    Manual encoding: 43 A1 01 03 = bstr(3) containing map {1: 3}
  const protectedHdr = new Uint8Array([0x43, 0xA1, 0x01, 0x03]);  // alg = 3 (A256GCM)
  console.log('Protected header (bstr with A256GCM):', hex(protectedHdr));
  
  // 2. Unprotected header: {5: iv} where iv is 12-byte bstr
  //    Manual encoding: A1 05 4C <12 bytes>
  const unprotectedHdr = new Uint8Array([
    0xA1,  // map(1)
    0x05,  // key = 5 (IV label)
    0x4C,  // bstr(12)
    ...iv
  ]);
  console.log('Unprotected header:', hex(unprotectedHdr));
  
  // 3. Ciphertext: bstr with length prefix
  let ciphertextEncoded;
  if (ciphertext.length < 24) {
    ciphertextEncoded = new Uint8Array([0x40 + ciphertext.length, ...ciphertext]);
  } else if (ciphertext.length < 256) {
    ciphertextEncoded = new Uint8Array([0x58, ciphertext.length, ...ciphertext]);
  } else {
    ciphertextEncoded = new Uint8Array([
      0x59,
      (ciphertext.length >> 8) & 0xFF,
      ciphertext.length & 0xFF,
      ...ciphertext
    ]);
  }
  console.log('Ciphertext encoded length:', ciphertextEncoded.length);
  
  // 4. Combine into COSE_Encrypt0 array: [protected, unprotected, ciphertext]
  const enc0 = new Uint8Array([
    0x83,  // array(3)
    ...protectedHdr,
    ...unprotectedHdr,
    ...ciphertextEncoded
  ]);
  
  console.log('Final COSE_Encrypt0 length:', enc0.length);
  console.log('COSE_Encrypt0 hex (first 50 bytes):', hex(enc0.slice(0, 50)));
  console.log('Expected format: 83 43 a1 01 03 a1 05 4c <12-byte IV> 59 ... <ciphertext>');
  console.log('Algorithm: A256GCM (alg=3) - 32-byte key');
  
  // Verify structure can be decoded
  try {
    const verify = CBOR.decode(enc0);
    if (!Array.isArray(verify) || verify.length !== 3) {
      throw new Error('Invalid COSE_Encrypt0 structure');
    }
    console.log('‚úÖ COSE_Encrypt0 structure validation passed (AES-256-GCM)');
    console.log('‚úÖ NO CBOR TAG 64 - manually encoded to ISO 18013-5 spec');
  } catch (e) {
    console.error('‚ùå COSE_Encrypt0 validation failed:', e.message);
    throw e;
  }
  
  return enc0;
}

// ==== Messages ====

// Custom CBOR encoder for COSE_Key to avoid tag 64 on byte strings
function encodeCoseKeyManually(coseKey) {
  // Manually build CBOR map: A4 (map with 4 items) + key-value pairs
  const result = [];
  
  // Map header: 0xA4 = map with 4 items
  result.push(0xA4);
  
  // Item 1: key=1 (kty), value=2 (EC2)
  result.push(0x01);  // positive int 1
  result.push(0x02);  // positive int 2
  
  // Item 2: key=-1 (crv), value=1 (P-256)
  result.push(0x20);  // negative int -1 (encoded as 0x20)
  result.push(0x01);  // positive int 1
  
  // Item 3: key=-2 (x), value=<32 bytes>
  const x = coseKey.get(-2);
  console.log('X coordinate type:', x.constructor.name, 'length:', x.length);
  console.log('X coordinate (hex):', hex(x));
  result.push(0x21);  // negative int -2 (encoded as 0x21)
  result.push(0x58, 0x20);  // byte string, length 32
  result.push(...x);
  
  // Item 4: key=-3 (y), value=<32 bytes>
  const y = coseKey.get(-3);
  console.log('Y coordinate type:', y.constructor.name, 'length:', y.length);
  console.log('Y coordinate (hex):', hex(y));
  result.push(0x22);  // negative int -3 (encoded as 0x22)
  result.push(0x58, 0x20);  // byte string, length 32
  result.push(...y);
  
  const encoded = new Uint8Array(result);
  console.log('Manual COSE_Key encoding (hex):', hex(encoded));
  console.log('Should be: A4 01 02 20 01 21 58 20 <x> 22 58 20 <y>');
  
  return encoded;
}

// Manually encode tag 24 wrapped byte string to avoid tag 64
function encodeTag24ByteString(data) {
  // Tag 24 (0xD8 0x18) + byte string header + data
  const result = [];
  
  // Tag 24: 0xD8 (tag follows) 0x18 (tag number 24)
  result.push(0xD8, 0x18);
  
  // Byte string with length
  if (data.length < 24) {
    result.push(0x40 + data.length);  // short byte string
  } else if (data.length < 256) {
    result.push(0x58, data.length);   // byte string, 1-byte length
  } else {
    result.push(0x59, data.length >> 8, data.length & 0xFF);  // byte string, 2-byte length
  }
  
  result.push(...data);
  
  return new Uint8Array(result);
}

function buildSessionEstablishmentHello() {
  const readerCoseKey = buildReaderCoseKey();
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  const publicKeyBytes = encodeTag24ByteString(coseKeyEncoded);

  console.log('=== BUILDING SESSION ESTABLISHMENT HELLO ===');
  console.log('Public key bytes (tagged COSE_Key):', hex(publicKeyBytes));

  // Build map with both "publicKey" (some wallets) and "eReaderKey" (spec compliant)
  const result = [];
  result.push(0xA2); // map with 2 entries

  // Key 1: "publicKey"
  result.push(0x69);
  result.push(...Array.from('publicKey').map(c => c.charCodeAt(0)));
  result.push(...publicKeyBytes);

  // Key 2: "eReaderKey"
  result.push(0x6A);
  result.push(...Array.from('eReaderKey').map(c => c.charCodeAt(0)));
  result.push(...publicKeyBytes);

  const final = new Uint8Array(result);
  console.log('SessionEstablishment hello (hex):', hex(final));

  // Sanity decode
  try {
    const decoded = CBOR.decode(final);
    console.log('Hello message decoded keys:', decoded instanceof Map ? Array.from(decoded.keys()) : Object.keys(decoded));
  } catch (e) {
    console.warn('Could not decode SessionEstablishment hello for verification:', e.message);
  }

  return final;
}

async function buildSessionEstablishment() {
  // Per ISO 18013-5 spec:
  // SessionEstablishment = {
  //   "eReaderKey": EReaderKeyBytes,  // tag(24, bstr .cbor COSE_Key)
  //   "data": bstr                    // Encrypted mdoc request
  // }
  
  const readerCoseKey = buildReaderCoseKey();
  
  // Step 1: Manually encode the COSE_Key to avoid tag 64
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  console.log('COSE_Key manually encoded:', hex(coseKeyEncoded));
  
  // Step 2: Manually wrap in tag 24 as byte string (avoids tag 64)
  const eReaderKeyBytes = encodeTag24ByteString(coseKeyEncoded);
  console.log('eReaderKey with tag 24 (manual):', hex(eReaderKeyBytes));
  
  // Step 3: Build and encrypt the mDL request
  console.log('Building mDL request for SessionEstablishment...');
  const mdlRequest = buildRequestByType();
  
  // Derive session key first
  if (!skReader || !transcriptAAD) {
    console.log('Deriving session keys for encryption...');
    
    // Use static mdoc key from Device Engagement (static handover)
    const mdocPub = await importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
    const shared = await deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);
    transcriptAAD = await buildTranscriptAAD();
    
    // Derive both session keys
    const keys = await deriveSessionKey(new Uint8Array(shared), transcriptAAD);
  skReader = keys.readerKey;  // Reader encrypts requests with SKReader
  skDevice = keys.deviceKey;  // Reader decrypts responses with SKDevice
  sessionKey = skReader;      // Compatibility alias for legacy code paths
    
    console.log('‚úÖ Session keys derived:');
    console.log('  - SKReader for encrypting requests');
    console.log('  - SKDevice for decrypting responses');
  }
  
  // Encrypt the request WITH SKReader (not SKDevice!)
  // Per ISO 18013-5: "The mdoc reader shall encrypt its mdoc requests with SKReader"
  console.log('üîê Encrypting request with SKReader...');
  const encryptedRequest = await coseEncrypt0_AESGCM_Enc0(mdlRequest, transcriptAAD, skReader);
  console.log('Encrypted request length:', encryptedRequest.length);
  console.log('Encrypted request (first 32 bytes):', hex(encryptedRequest.slice(0, 32)));
  
  // Step 4: Manually build SessionEstablishment CBOR
  // Structure: { "eReaderKey": tag(24, bstr .cbor COSE_Key), "data": bstr }
  // NOTE: No outer tag 24 wrapper!
  
  const result = [];
  
  // Map with 2 items
  result.push(0xA2);
  
  // Key 1: "eReaderKey" (10 characters)
  result.push(0x6A);  // text string, length 10
  result.push(...Array.from('eReaderKey').map(c => c.charCodeAt(0)));
  
  // Value 1: tag(24, bstr .cbor COSE_Key) - already encoded
  result.push(...eReaderKeyBytes);
  
  // Key 2: "data" (4 characters)
  result.push(0x64);  // text string, length 4
  result.push(...Array.from('data').map(c => c.charCodeAt(0)));
  
  // Value 2: encrypted request (byte string)
  if (encryptedRequest.length < 24) {
    result.push(0x40 + encryptedRequest.length);
  } else if (encryptedRequest.length < 256) {
    result.push(0x58, encryptedRequest.length);
  } else {
    result.push(0x59, encryptedRequest.length >> 8, encryptedRequest.length & 0xFF);
  }
  result.push(...encryptedRequest);
  
  // That's it - just a plain map, no outer wrapping
  const final = new Uint8Array(result);
  
  console.log('SessionEstablishment (fully manual encoding), length:', final.length);
  console.log('SessionEstablishment hex (first 200 bytes):', hex(final.slice(0, 200)));
  
  // DIAGNOSTIC: Decode to verify structure
  try {
    const decoded = CBOR.decode(final);
    console.log('=== DIAGNOSTIC: SessionEstablishment Structure ===');
    console.log('Is a Map:', decoded instanceof Map || typeof decoded === 'object');
    console.log('Has eReaderKey:', 'eReaderKey' in decoded || decoded.get?.('eReaderKey'));
    console.log('Has data:', 'data' in decoded || decoded.get?.('data'));
    
    const eReaderKey = decoded.eReaderKey || decoded.get?.('eReaderKey');
    if (eReaderKey) {
      console.log('eReaderKey type:', eReaderKey.constructor.name);
      console.log('eReaderKey tag:', eReaderKey.tag);
      
      if (eReaderKey.value) {
        const coseKey = CBOR.decode(eReaderKey.value.buffer || eReaderKey.value);
        console.log('COSE_Key decoded:', coseKey);
        console.log('COSE_Key has field 1 (kty):', coseKey[1] || coseKey.get?.(1));
        console.log('COSE_Key has field -1 (crv):', coseKey[-1] || coseKey.get?.(-1));
        console.log('COSE_Key has field -2 (x):', coseKey[-2] || coseKey.get?.(-2));
        console.log('COSE_Key has field -3 (y):', coseKey[-3] || coseKey.get?.(-3));
      }
    }
    console.log('=== END DIAGNOSTIC ===');
  } catch (diagError) {
    console.error('Diagnostic decode failed:', diagError);
  }
  
  return final;
}

// ISO 18013-5 compliant SessionEstablishment with manual CBOR encoding
// This version uses fully manual encoding to avoid tag 64 issues from cbor-web library
async function buildLegacySessionEstablishmentWithData() {
  console.warn('========================================');
  console.warn('‚ö†Ô∏è ALTERNATE SESSION ESTABLISHMENT');
  console.warn('========================================');
  console.warn('Per ISO 18013-5 spec Section 9.1.1.4:');
  console.warn('- Reader generates EReaderKey');
  console.warn('- Both sides derive session keys independently');
  console.warn('- Reader sends {eReaderKey, data: <encrypted>} together');
  console.warn('');
  console.warn('‚úÖ FIX APPLIED: Using RAW AES-GCM output for data field');
  console.warn('   data = ciphertext || 16-byte auth_tag (no COSE_Encrypt0 wrapper)');
  console.warn('   Per spec: "concatenation of the ciphertext and all 16 bytes of the authentication tag"');
  console.warn('========================================');
  
  const readerCoseKey = buildReaderCoseKey();
  
  // LOG: Verify which key we're using
  const keyX = readerCoseKey.get(-2);
  const keyY = readerCoseKey.get(-3);
  const fingerprint = hex(keyX.slice(0, 4));
  console.log('üîë [SessionEstablishment] Using EReaderKey - fingerprint:', fingerprint);
  console.log('   [SessionEstablishment] X:', hex(keyX));
  console.log('   [SessionEstablishment] Y:', hex(keyY));
  
  // Manually encode and wrap COSE_Key in tag 24 (avoids tag 64)
  const coseKeyEncoded = encodeCoseKeyManually(readerCoseKey);
  const publicKeyBytes = encodeTag24ByteString(coseKeyEncoded);
  
  // Build and encrypt the mDL request
  console.log('Building mDL request for SessionEstablishment (publicKey variant)...');
  const mdlRequest = buildRequestByType();
  
  // Derive session keys if needed
  if (!skReader || !transcriptAAD) {
    console.log('Deriving session keys per ISO 18013-5 (independent derivation)...');
    console.log('Using eSenderKey from DeviceEngagement (field 33) for ECDH');
    const mdocPub = await importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
    const shared = await deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);
    console.log('Building SessionTranscript for key derivation...');
    transcriptAAD = await buildTranscriptAAD();
    
    // Derive both session keys
    const keys = await deriveSessionKey(new Uint8Array(shared), transcriptAAD);
  skReader = keys.readerKey;  // Reader encrypts requests with SKReader
  skDevice = keys.deviceKey;  // Reader decrypts responses with SKDevice
  sessionKey = skReader;      // Compatibility alias
    sessionEstablished = true;
    window.sessionEstablished = true;
  }
  
  // Encrypt the request WITH SKReader (not SKDevice!)
  // Per ISO 18013-5: "The mdoc reader shall encrypt its mdoc requests with SKReader"
  // CRITICAL: SessionEstablishment.data field uses RAW AES-GCM output (not COSE_Encrypt0!)
  // Spec Section 9.1.1.4: "concatenation of the ciphertext and all 16 bytes of the authentication tag"
  // AAD: EMPTY per ISO 18013-5 Section 9.1.5.2
  console.log('üîê Encrypting request with SKReader (raw AES-GCM for SessionEstablishment.data)...');
  console.log(' Request CBOR length:', mdlRequest.length, 'bytes');
  console.log('üì¶ Request CBOR (first 64 bytes):', hex(mdlRequest.slice(0, 64)));
  console.log('üìù AAD: EMPTY (per ISO 18013-5)');
  
  // Use reader identifier: 8 zero bytes
  const readerIdentifier = new Uint8Array(8); // 0x00 √ó 8
  const encryptedRequest = await aesGcmEncryptRaw(mdlRequest, skReader, readerIdentifier, 1);
  
  // Manually build SessionEstablishment - just a plain map, no outer tag 24
  const result = [];
  result.push(0xA2);  // Map with 2 items
  
  // Key 1: "eReaderKey" (10 characters) - per ISO 18013-5 spec
  result.push(0x6A);  // text string, length 10
  result.push(...Array.from('eReaderKey').map(c => c.charCodeAt(0)));
  result.push(...publicKeyBytes);  // tag(24, bstr .cbor COSE_Key)
  
  // Key 2: "data" (4 characters)
  result.push(0x64);
  result.push(...Array.from('data').map(c => c.charCodeAt(0)));
  
  // Value 2: encrypted request
  if (encryptedRequest.length < 24) {
    result.push(0x40 + encryptedRequest.length);
  } else if (encryptedRequest.length < 256) {
    result.push(0x58, encryptedRequest.length);
  } else {
    result.push(0x59, encryptedRequest.length >> 8, encryptedRequest.length & 0xFF);
  }
  result.push(...encryptedRequest);
  
  // That's it - just a plain map
  const final = new Uint8Array(result);
  
  console.log('SessionEstablishment (ISO 18013-5 compliant), length:', final.length);
  console.log('SessionEstablishment hex (first 200 bytes):', hex(final.slice(0, 200)));
  
  // DIAGNOSTIC: Decode to verify structure
  try {
    const decoded = CBOR.decode(final);
    console.log('=== DIAGNOSTIC: SessionEstablishment (ISO 18013-5) ===');
    console.log('Is a Map:', decoded instanceof Map || typeof decoded === 'object');
    console.log('Has eReaderKey:', 'eReaderKey' in decoded || decoded.get?.('eReaderKey'));
    console.log('Has data:', 'data' in decoded || decoded.get?.('data'));
    console.log('Data length:', (decoded.data || decoded.get?.('data'))?.length || 0);
    console.log('=== END DIAGNOSTIC ===');
  } catch (diagError) {
    console.error('Diagnostic decode failed:', diagError);
  }
  
  return final;
}

// Alternative 2: Try direct COSE_Key (no wrapper map)
function buildSessionEstablishmentAlt() {
  const readerKey = buildReaderCoseKey();
  
  console.log('Building alternative: Direct COSE_Key (no wrapper map)');
  const encoded = CBOR.encode(readerKey);
  const tagged = new CBOR.Tagged(24, encoded);
  const final = CBOR.encode(tagged);
  
  console.log('Alternative SessionEstablishment (direct COSE_Key):', hex(final));
  return final;
}

function buildDeviceRequestCBOR() {
  return CBOR.encode({
    version: "1.0",
    docRequests: [{
      itemsRequest: {
        docType: "org.iso.18013.5.1",  // FIXED: Correct docType per ISO 18013-5
        nameSpaces: {
          "org.iso.18013.5.1": {
            // Personal information
            "family_name": false,           // Mandatory
            "given_name": false,            // Mandatory  
            "birth_date": false,            // Mandatory
            "age_over_18": false,           // Age verification
            "age_over_21": false,           // Age verification
            
            // Document information
            "issue_date": false,            // When license was issued
            "expiry_date": false,           // When license expires
            "issuing_country": false,       // Country code (e.g., "US")
            "issuing_authority": false,     // State/authority that issued
            "document_number": false,       // License number
            
            // Driving privileges
            "driving_privileges": false,     // Array of vehicle categories
            
            // Physical characteristics
            "height": false,                // Height in cm
            "weight": false,                // Weight in kg
            "eye_colour": false,            // Eye color
            "hair_colour": false,           // Hair color
            "sex": false,                   // Gender
            
            // Address information
            "resident_address": false,      // Full address
            "resident_city": false,         // City
            "resident_state": false,        // State/province
            "resident_postal_code": false,  // ZIP/postal code
            "resident_country": false,      // Country
            
            // Portrait and signature
            "portrait": false,              // Photo image
            "signature_usual_mark": false   // Signature image
          }
        }
      },
      // Request specific elements based on use case
      readerAuth: null  // No reader authentication for this demo
    }]
  });
}

// Build different request types for common use cases
// Can now accept array of request types to create multiple docRequests
function buildRequestByType(requestTypes) {
  // Get selected request types if not provided
  if (!requestTypes) {
    requestTypes = Array.from(document.querySelectorAll('input[name="requestType"]:checked'))
      .map(cb => cb.value);
  }
  
  // If single value provided, convert to array
  if (!Array.isArray(requestTypes)) {
    requestTypes = [requestTypes];
  }
  
  // If no types selected, default to mDL Full
  if (requestTypes.length === 0) {
    requestTypes = ['full'];
  }
  
  console.log('Building request for types:', requestTypes);
  
  // Build base request structure
  const deviceRequest = {
    version: "1.0",
    docRequests: []
  };
  
  // Build each document request
  requestTypes.forEach(requestType => {
    const docRequest = buildSingleDocRequest(requestType);
    if (docRequest) {
      deviceRequest.docRequests.push(docRequest);
    }
  });
  
  console.log('‚Üí Device Request with', deviceRequest.docRequests.length, 'document(s):', deviceRequest);
  
  return CBOR.encode(deviceRequest);
}

// Helper: Build a single document request based on type
function buildSingleDocRequest(requestType) {
  let docType, namespace, fields;
  
  // Determine document type and namespace
  if (requestType.startsWith('pid_')) {
    docType = "eu.europa.ec.eudi.pid.1";
    namespace = "eu.europa.ec.eudi.pid.1";
  } else if (requestType.startsWith('age_verify_')) {
    docType = "eu.europa.ec.av.1";
    namespace = "eu.europa.ec.av.1";
  } else {
    docType = "org.iso.18013.5.1.mDL";
    namespace = "org.iso.18013.5.1";
  }
  
  // Build fields based on request type
  switch (requestType) {
    case 'basic':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "portrait": true
      };
      break;

    case 'age':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "birth_date": true
      };
      break;

    case 'driving':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "driving_privileges": true,
        "issue_date": true,
        "expiry_date": true,
        "document_number": true,
        "portrait": true
      };
      break;

    case 'full':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "age_over_18": true,
        "age_over_21": true,
        "issue_date": true,
        "expiry_date": true,
        "issuing_country": true,
        "issuing_authority": true,
        "document_number": true,
        "driving_privileges": true,
        "height": true,
        "weight": true,
        "eye_colour": true,
        "hair_colour": true,
        "sex": true,
        "resident_address": true,
        "resident_city": true,
        "resident_state": true,
        "resident_postal_code": true,
        "resident_country": true,
        "portrait": true,
        "signature_usual_mark": true
      };
      break;

    case 'pid_basic':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "portrait": true
      };
      break;

    case 'pid_age':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "birth_date": true
      };
      break;

    case 'pid_full':
      fields = {
        "family_name": true,
        "given_name": true,
        "birth_date": true,
        "birth_place": true,
        "birth_country": true,
        "birth_state": true,
        "birth_city": true,
        "resident_address": true,
        "resident_country": true,
        "resident_state": true,
        "resident_city": true,
        "resident_postal_code": true,
        "resident_street": true,
        "resident_house_number": true,
        "gender": true,
        "nationality": true,
        "age_over_18": true,
        "age_over_21": true,
        "age_in_years": true,
        "age_birth_year": true,
        "family_name_birth": true,
        "given_name_birth": true,
        "portrait": true,
        "issuing_authority": true,
        "issuing_country": true,
        "issuance_date": true,
        "expiry_date": true,
        "document_number": true
      };
      break;

    // EU Age Verification (Proof of Age) cases
    case 'age_verify_18':
      fields = {
        "age_over_18": true
      };
      break;

    case 'age_verify_21':
      fields = {
        "age_over_18": true,
        "age_over_21": true
      };
      break;

    case 'age_verify_full':
      fields = {
        "age_over_18": true,
        "age_over_21": true,
        "age_in_years": true,
        "age_birth_year": true,
        "birth_date": true,
        "issuing_country": true,
        "issuance_date": true,
        "expiry_date": true
      };
      break;

    default:
      console.warn('Unknown request type:', requestType);
      return null;
  }
  
  // Build the itemsRequest
  const itemsRequest = {
    docType: docType,
    nameSpaces: {
      [namespace]: fields
    },
    requestInfo: {}
  };
  
  // Per ISO 18013-5, itemsRequest must be tag(24, bstr .cbor ItemsRequest)
  const itemsRequestCbor = CBOR.encode(itemsRequest);
  const taggedItemsRequest = new CBOR.Tagged(24, itemsRequestCbor);
  
  return {
    itemsRequest: taggedItemsRequest
    // Note: No readerAuth for this demo
  };
}

// ==== Mode switching ====
function updateBleRoleUI() {
  // Function kept for compatibility but no longer manages button states
  // Requests are sent automatically after session establishment
}

// Handle request type changes (now supports multiple selections)
requestTypeCheckboxes.forEach(checkbox => {
  checkbox.addEventListener('change', (e) => {
    const selected = Array.from(document.querySelectorAll('input[name="requestType"]:checked'))
      .map(cb => cb.value);
    
    if (selected.length === 0) {
      log('‚ö†Ô∏è No document types selected - will default to mDL Full');
    } else if (selected.length === 1) {
      const type = selected[0];
      let description = '';
      switch(type) {
        case 'basic':
          description = 'Basic ID: name, birth_date, portrait';
          break;
        case 'age':
          description = 'Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'driving':
          description = 'Driving license: name, birth_date, driving_privileges, license info, portrait';
          break;
        case 'full':
          description = 'Full mDL: all available fields including address, physical characteristics';
          break;
        case 'pid_basic':
          description = 'Basic EU PID: name, birth_date, portrait';
          break;
        case 'pid_age':
          description = 'EU PID Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'pid_full':
          description = 'Full EU PID: all available fields including address, nationality, birth details';
          break;
        case 'age_verify_18':
          description = 'Age Verification 18+: age_over_18 only';
          break;
        case 'age_verify_21':
          description = 'Age Verification 21+: age_over_18, age_over_21';
          break;
        case 'age_verify_full':
          description = 'Age Verification Full: age checks, birth_date, age_in_years, issuing info';
          break;
      }
      log(`Selected request type: ${type.toUpperCase()} - ${description}`);
    } else {
      // Multiple documents selected
      const docTypes = selected.map(t => {
        if (t.startsWith('pid_')) return 'EU PID';
        if (t.startsWith('age_verify_')) return 'Age Verification';
        return 'mDL';
      });
      const uniqueTypes = [...new Set(docTypes)];
      log(`üìã Multi-document request: ${selected.length} document(s) selected (${uniqueTypes.join(' + ')})`);
    }
  });
});

// Initialize UI
updateBleRoleUI();

// ==== UI actions ====
btnScanBLE.addEventListener('click', async () => {
  try {
    log('Scanning for ALL BLE devices (no filters)...');
    console.log('Starting general BLE scan...');
    
    // Scan without any filters to see all advertising devices
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['generic_access', 'generic_attribute'] // Standard services
    });
    
    console.log('Device found:', device);
    log(`Found device: ${device.name || '(unnamed)'} (${device.id})`);
    
    // Try to connect and see what services it has
    try {
      const server = await device.gatt.connect();
      console.log('Connected to device, getting services...');
      
      const services = await server.getPrimaryServices();
      console.log('Available services:', services);
      
      log(`Device has ${services.length} services:`);
      for (const service of services) {
        console.log('Service UUID:', service.uuid);
        log(`- Service: ${service.uuid}`);
        
        // Check if this is our target service
        if (service.uuid === svcUUID) {
          log(`*** FOUND TARGET SERVICE: ${svcUUID} ***`);
        }
      }
      
      device.gatt.disconnect();
      
    } catch (e) {
      console.log('Could not connect or enumerate services:', e.message);
      log(`Could not connect: ${e.message}`);
    }
    
  } catch (e) {
    console.error('BLE scan failed:', e);
    if (e.name === 'NotFoundError') {
      log('No devices found or scan cancelled');
    } else {
      log(`BLE scan error: ${e.message}`);
    }
  }
});

if (btnAdvertise) btnAdvertise.addEventListener('click', async () => {
  try {
    if (!svcUUID) throw new Error('Service UUID missing (scan QR or use override)');
    
    console.log('Attempting to start BLE advertising with UUID:', svcUUID);
    log('Starting BLE advertising...');
    
    // Enhanced feature detection with macOS-specific checks
    console.log('=== BLE API Detection ===');
    console.log('Browser:', navigator.userAgent);
    console.log('Platform:', navigator.platform);
    console.log('Chrome Version:', navigator.userAgent.match(/Chrome\/(\d+)/)?.[1] || 'unknown');
    console.log('- navigator.bluetooth:', !!navigator.bluetooth);
    
    if (navigator.bluetooth) {
      console.log('- bluetooth.getAvailability:', typeof navigator.bluetooth.getAvailability);
      console.log('- bluetooth.requestDevice:', typeof navigator.bluetooth.requestDevice);
      console.log('- bluetooth.getDevices:', typeof navigator.bluetooth.getDevices);
      console.log('- bluetooth.advertise:', typeof navigator.bluetooth.advertise);
      console.log('- bluetooth.startAdvertising:', typeof navigator.bluetooth.startAdvertising);
      console.log('- bluetooth.watchAdvertisements:', typeof navigator.bluetooth.watchAdvertisements);
      console.log('- bluetooth.requestLEScan:', typeof navigator.bluetooth.requestLEScan);
      
      // Check availability
      try {
        const available = await navigator.bluetooth.getAvailability();
        console.log('- Bluetooth available:', available);
        log(`Bluetooth adapter available: ${available}`);
      } catch (e) {
        console.log('- Availability check failed:', e.message);
      }
    }
    
    log('Checking for experimental advertising APIs...');
    
    // Try newest API first
    if ('bluetooth' in navigator && typeof navigator.bluetooth.advertise === 'function') {
      console.log('‚úì Using navigator.bluetooth.advertise() - Latest API');
      log('Using latest Web Bluetooth advertising API');
      
      const advertiseOptions = {
        advertisementData: {
          localName: 'mDL Reader',
          serviceUuids: [svcUUID]
        }
      };
      
      console.log('Advertise options:', advertiseOptions);
      await navigator.bluetooth.advertise(advertiseOptions);
      
      isAdvertising = true;
      if (btnAdvertise) btnAdvertise.disabled = true;
      if (btnStopAdvertise) btnStopAdvertise.disabled = false;
      log('‚úì BLE advertising started successfully');
      log('üì± Wallet should now be able to discover and connect to this reader');
      
    } else if ('bluetooth' in navigator && typeof navigator.bluetooth.startAdvertising === 'function') {
      console.log('‚úì Using navigator.bluetooth.startAdvertising() - Legacy API');
      log('Using legacy Web Bluetooth advertising API');
      
      await navigator.bluetooth.startAdvertising({
        localName: 'mDL Reader',
        serviceUuids: [svcUUID]
      });
      
      isAdvertising = true;
      if (btnAdvertise) btnAdvertise.disabled = true;
      if (btnStopAdvertise) btnStopAdvertise.disabled = false;
      log('‚úì BLE advertising started successfully');
      
    } else {
      // More detailed error for macOS
      console.log('‚ùå No advertising APIs available');
      log('‚ùå BLE advertising APIs not found');
      
      // Check Chrome version for compatibility
      const chromeVersion = navigator.userAgent.match(/Chrome\/(\d+)/)?.[1];
      console.log('Chrome version:', chromeVersion);
      
      let errorMsg = 'BLE advertising not supported in this browser.\n\n';
      
      if (navigator.platform.includes('Mac')) {
        errorMsg += 'üçé macOS Chrome Canary Setup:\n\n';
        errorMsg += '1. Quit Chrome Canary completely\n';
        errorMsg += '2. Open Terminal and run:\n';
        errorMsg += '   /Applications/Google\\ Chrome\\ Canary.app/Contents/MacOS/Google\\ Chrome\\ Canary \\\n';
        errorMsg += '   --enable-experimental-web-platform-features \\\n';
        errorMsg += '   --enable-web-bluetooth-new-permissions-backend \\\n';
        errorMsg += '   --enable-features=WebBluetoothAdvertising,WebBluetoothScanAPI \\\n';
        errorMsg += '   --enable-blink-features=WebBluetoothAdvertising \\\n';
        errorMsg += '   --user-data-dir=/tmp/chrome-canary-experimental\n\n';
        errorMsg += 'OR:\n';
        errorMsg += '1. Go to chrome://flags/\n';
        errorMsg += '2. Enable "Experimental Web Platform features"\n';
        errorMsg += '3. Enable "Web Bluetooth New Permissions Backend"\n';
        errorMsg += '4. Restart Chrome Canary\n\n';
        
        // Offer fallback for testing
        if (chromeVersion && parseInt(chromeVersion) >= 100) {
          log('');
          log('üí° WORKAROUND AVAILABLE:');
          log('   Since BLE advertising isn\'t working in Chrome, try this:');
          log('   1. Switch your wallet to PERIPHERAL_SERVER mode (if possible)');
          log('   2. OR test with Central Mode anyway (will auto-switch in 3 seconds)');
          log('   3. Use "Connect to Wallet" button');
          log('');
          log('üîÑ Auto-switching to Central Mode in 3 seconds for testing...');
          
          // Auto-switch to Central Mode after 3 seconds
          setTimeout(() => {
            document.querySelector('input[value="central"]').checked = true;
            currentBleRole = 'central';
            updateBleRoleUI();
            log('‚úÖ Switched to Central Mode - you can now try "Connect to Wallet"');
            log('üì± Note: This will only work if your wallet is advertising (PERIPHERAL_SERVER)');
          }, 3000);
          
          return; // Don't throw error, offer fallback
        }
      } else {
        errorMsg += 'For Chrome Canary:\n';
        errorMsg += '1. Go to chrome://flags/\n';
        errorMsg += '2. Enable "Experimental Web Platform features"\n';
        errorMsg += '3. Restart browser\n';
      }
      
      throw new Error(errorMsg);
    }
    
  } catch (e) {
    console.error('BLE advertising failed:', e);
    log(`‚ùå BLE advertising error: ${e.message}`);
    
    if (e.message.includes('not supported') || e.message.includes('not found')) {
      log('');
      log('üîß TROUBLESHOOTING:');
      log('1. Make sure you launched Chrome Canary with experimental flags');
      log('2. Try reloading this page');
      log('3. Check chrome://flags/ for experimental features');
      log('');
    }
  }
});

if (btnStopAdvertise) btnStopAdvertise.addEventListener('click', async () => {
  try {
    console.log('Stopping BLE advertising...');
    
    if ('bluetooth' in navigator && 'stopAdvertising' in navigator.bluetooth) {
      await navigator.bluetooth.stopAdvertising();
    }
    
    isAdvertising = false;
    if (btnAdvertise) btnAdvertise.disabled = !svcUUID;
    if (btnStopAdvertise) btnStopAdvertise.disabled = true;
    log('BLE advertising stopped');
    
  } catch (e) {
    console.error('Stop advertising failed:', e);
    log(`Stop advertising error: ${e.message}`);
  }
});

if (btnConnect) btnConnect.addEventListener('click', async () => {
  try {
    if (!svcUUID) throw new Error('Service UUID missing (scan QR or use override)');
    
    console.log('Starting BLE connection with UUID:', svcUUID);
    log('Requesting BLE device‚Ä¶');
    
    // Check if Web Bluetooth is supported
    if (!navigator.bluetooth) {
      throw new Error('Web Bluetooth not supported in this browser');
    }
    
    console.log('Web Bluetooth is supported');
    console.log('Available Bluetooth APIs:');
    console.log('- getAvailability:', typeof navigator.bluetooth.getAvailability);
    console.log('- requestDevice:', typeof navigator.bluetooth.requestDevice);
    console.log('- getDevices:', typeof navigator.bluetooth.getDevices);
    
    // Check for experimental peripheral/advertising APIs
    if ('requestLEScan' in navigator.bluetooth) {
      console.log('- requestLEScan: available (experimental)');
    }
    if ('startAdvertising' in navigator.bluetooth) {
      console.log('- startAdvertising: available (experimental)');
    }
    if ('advertise' in navigator.bluetooth) {
      console.log('- advertise: available (experimental)');
    }
    
    console.log('Wallet is CENTRAL_CLIENT - it should be scanning for this reader');
    console.log('This reader is trying to act as CENTRAL, but should act as PERIPHERAL');
    console.log('Consider switching wallet to PERIPHERAL_SERVER mode if possible');
    
    console.log('Request device filters:', [{ services: [svcUUID] }]);
    
    // Request device with detailed logging
    try {
      device = await navigator.bluetooth.requestDevice({ 
        filters: [{ services: [svcUUID] }], 
        optionalServices: [svcUUID] 
      });
      console.log('Device selected:', device);
      log(`Device selected: ${device.name || '(unnamed)'} (${device.id})`);
    } catch (requestError) {
      console.error('Device request failed:', requestError);
      if (requestError.name === 'NotFoundError') {
        log('No device found or user cancelled. Make sure the wallet device is advertising and try again.');
      } else if (requestError.name === 'SecurityError') {
        log('Security error: HTTPS required for Web Bluetooth');
      } else {
        log(`Device request error: ${requestError.name} - ${requestError.message}`);
      }
      return;
    }
    
    device.addEventListener('gattserverdisconnected', () => {
      log('üì± Wallet disconnected from reader.');
      console.log('GATT server disconnected');
      
      // Reset connection state
      server = service = chState = chC2S = chS2C = null;
      
      // Reset button states
      btnSend.disabled = true;
      
      log('üí° To continue, scan QR code again.');
    });
    
    console.log('Attempting GATT connection...');
    log(`Connecting to ${device.name || '(unnamed)'}‚Ä¶`);
    
    try {
      server = await device.gatt.connect();
      console.log('GATT connected, server:', server);
      log('GATT connected successfully');
    } catch (connectError) {
      console.error('GATT connection failed:', connectError);
      log(`GATT connection failed: ${connectError.message}`);
      return;
    }
    
    console.log('Getting primary service:', svcUUID);
    try {
      service = await server.getPrimaryService(svcUUID);
      console.log('Service found:', service);
      log('Service found');
    } catch (serviceError) {
      console.error('Service not found:', serviceError);
      log(`Service ${svcUUID} not found: ${serviceError.message}`);
      return;
    }
    
    console.log('Getting characteristics...');
    try {
      chState = await service.getCharacteristic(UUIDS.state);
      console.log('State characteristic found:', chState);
      
      chC2S = await service.getCharacteristic(UUIDS.c2s);
      console.log('C2S characteristic found:', chC2S);
      
      chS2C = await service.getCharacteristic(UUIDS.s2c);
      console.log('S2C characteristic found:', chS2C);
      
      log('All characteristics found');
    } catch (charError) {
      console.error('Characteristic not found:', charError);
      log(`Characteristic not found: ${charError.message}`);
      return;
    }
    
    console.log('Starting notifications...');
    try {
      await chS2C.startNotifications();
      chS2C.addEventListener('characteristicvaluechanged', handleServer2Client);
      console.log('Notifications started successfully');
      log('GATT ready. Notifications enabled.');
    } catch (notifyError) {
      console.error('Failed to start notifications:', notifyError);
      log(`Failed to start notifications: ${notifyError.message}`);
      return;
    }
    
    // DON'T derive session keys yet - need to wait for wallet's ephemeral key!
    console.log('‚è∏Ô∏è Session key derivation postponed until after SessionEstablishment response');
    console.log('mdocPubKey from QR (static key, not for session):', mdocPubKey);
    
    log('‚úÖ BLE ready. Click "Start" then "Send SessionEstablishment" to begin session.');
    log('‚ö†Ô∏è Session keys will be derived AFTER wallet sends its ephemeral key');
    
  } catch (e) { 
    console.error('BLE connection error:', e);
    log('BLE error: ' + e.message); 
  }
});

if (btnStart) btnStart.addEventListener('click', async () => {
  try { 
    await writeState(0x01); 
    log('üöÄ Protocol started - wallet is now ready for session establishment');
    log('üëâ Next: Click "Send SessionEstablishment"');
  } catch (e) { log('State error: ' + e.message); }
});

if (btnEstablish) btnEstablish.addEventListener('click', async () => {
  try {
    log('üîê Starting session establishment (phase 1: send reader public key)...');

    // Reset session state before starting handshake
    _readerCoseKeyCached = null;
    skReader = null;
    skDevice = null;
    sessionKey = null;
    transcriptAAD = null;
    walletEphemeralKey = null;
    sessionEstablished = false;
    window.sessionEstablished = false;

  btnSend.disabled = true;
  if (btnCompatMode) btnCompatMode.disabled = true;

    // Step 1: Generate ephemeral key pair for this session
    readerKeyPair = await makeReaderEphemeralKeyPair();
    await exportReaderPublicToCoseKey();
    log('‚úÖ Generated reader ephemeral key pair');

    // Step 2: Prepare to capture wallet response
    window.sessionResponseReceived = false;
    window.sessionResponseData = null;
    log('üîç Waiting for wallet SessionEstablishment response...');

    // Step 3: Send SessionEstablishment with ONLY the reader public key
    const hello = buildSessionEstablishmentHello();
    console.log('SessionEstablishment hello length:', hello.length);
    console.log('SessionEstablishment hello hex:', hex(hello));

    await sendFragmented(hello);

    log('üì§ SessionEstablishment sent (public key only). Wallet should reply with eDeviceKey.');
    log('‚è≥ Waiting for wallet response (expecting SessionEstablishment from wallet)...');

    let attempts = 0;
    while (!window.sessionResponseReceived && attempts < 120) { // 12 seconds timeout
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
      if (attempts % 10 === 0) {
        log(`‚è≥ Still waiting for wallet response... (${attempts / 10}s)`);
      }
    }

    if (!window.sessionResponseReceived) {
      log('‚ö†Ô∏è No session response received yet. Check the wallet for prompts and try again.');
      log('üí° You can retry or use the legacy fallback button if the wallet only supports static handover.');
      return;
    }

    log('üì• Wallet responded - verifying session keys...');

    if (!sessionEstablished) {
      try {
        await processSessionResponse(window.sessionResponseData);
      } catch (processError) {
        console.error('Session finalization error:', processError);
        log('‚ùå Failed to finalize session keys: ' + processError.message);
        return;
      }
    }

    if (sessionEstablished) {
      log('‚úÖ Session establishment complete. You can now send an encrypted request.');
    } else {
      log('‚ö†Ô∏è Session not fully established. Review logs for details.');
    }

  } catch (e) {
    console.error('Session establishment error:', e);
    log('‚ùå Session establishment failed: ' + e.message);
  }
});

if (btnEstablishAlt) btnEstablishAlt.addEventListener('click', async () => {
  try {
    log('üîê Alternate SessionEstablishment: ISO 18013-5 compliant flow');
    log('üìã Sending {eReaderKey, data: <encrypted>} in one message');
    log('‚ö†Ô∏è Note: Multipaz reports decryption error with this method');
    log('');
    log('üî¨ Investigating possible causes:');
    log('   - SessionTranscript structure/ordering');
    log('   - COSE_Encrypt0 format expectations');  
    log('   - Key derivation parameters (HKDF)');
    log('   - AAD usage in AES-GCM');
    log('');
    log('üìä Full debugging details will be logged to console');

    // Reset session state to avoid mixing handshakes
    _readerCoseKeyCached = null;
    skReader = null;
    skDevice = null;
    sessionKey = null;
    transcriptAAD = null;
    walletEphemeralKey = null;
    sessionEstablished = false;
    window.sessionEstablished = false;

    readerKeyPair = await makeReaderEphemeralKeyPair();
    await exportReaderPublicToCoseKey();
    log('‚úÖ Generated ephemeral key pair');
    
    console.log('========================================');
    console.log('MULTIPAZ DEBUGGING - ALTERNATE SESSION ESTABLISHMENT');
    console.log('========================================');
    console.log('Per ISO 18013-5 Section 9.1.1.4:');
    console.log('  "The mdoc reader encrypts the mdoc request with the');
    console.log('   appropriate session key and sends it to the mdoc');
    console.log('   together with EReaderKey.Pub in a session establishment message."');
    console.log('');
    console.log('This implementation follows the spec, but Multipaz rejects it.');
    console.log('');
    console.log('Debug checklist for Multipaz comparison:');
    console.log('1. Compare SessionTranscript construction (check console below)');
    console.log('2. Compare session key derivation (SKReader/SKDevice)');
    console.log('3. Compare COSE_Encrypt0 structure');
    console.log('4. Compare IV construction and AAD usage');
    console.log('========================================');

    const legacyMessage = await buildLegacySessionEstablishmentWithData();
    console.log('SessionEstablishment message length:', legacyMessage.length);
    console.log('SessionEstablishment hex (first 120 bytes):', hex(legacyMessage.slice(0, 120)));

    await sendFragmented(legacyMessage);

    sessionEstablished = true;
    window.sessionEstablished = true;
    log('üì§ SessionEstablishment sent with encrypted request');
    log('‚è≥ Waiting for wallet response...');
    log('‚ö†Ô∏è Known issue: Multipaz will likely return "Error decrypting"');
    log('üí° Use standard "Send SessionEstablishment" as workaround');

    btnSend.disabled = false;
    if (btnCompatMode) btnCompatMode.disabled = false;

  } catch (e) {
    log('‚ùå Alternative session establishment failed: ' + e.message);
  }
});

// Legacy btnSend event listener (button removed - logic moved to sendDeviceRequest function)
if (btnSend) btnSend.addEventListener('click', async () => {
  try {
    if (!sessionEstablished || !skReader || !transcriptAAD) {
      throw new Error('Session not established. Run SessionEstablishment first.');
    }
    
    // CRITICAL: Check if we need to send state transition first
    log('üîç Verifying protocol state before request...');
    
    // Read current state to verify wallet is ready
    try {
      const stateValue = await chState.readValue();
      const currentState = stateValue.getUint8(0);
      log(`üìä Current protocol state: 0x${currentState.toString(16).padStart(2, '0')}`);
      
      if (currentState === 0x00) {
        log('‚ö†Ô∏è Wallet is in IDLE state (0x00) - must start protocol first!');
        log('üí° Click "Start (state=0x01)" button before sending request');
        throw new Error('Protocol not started - wallet in IDLE state');
      }
      
      if (currentState !== 0x01) {
        log(`‚ö†Ô∏è Unexpected state: 0x${currentState.toString(16)} (expected 0x01 for data transfer)`);
      }
    } catch (stateError) {
      log(`‚ö†Ô∏è Could not read state: ${stateError.message} - proceeding anyway`);
    }
    
    // Comprehensive connection verification
    log('üîç Verifying BLE connection before sending request...');
    
    if (!device || !device.gatt || !device.gatt.connected) {
      throw new Error('BLE device not connected. Please reconnect first.');
    }
    
    if (!service || !chC2S) {
      throw new Error('BLE service not available. Please reconnect.');
    }
    
    // Additional check: Try to verify service is still accessible
    try {
      // Quick verification that the service is still active
      const characteristics = await service.getCharacteristics();
      if (!characteristics.find(c => c.uuid === chC2S.uuid)) {
        throw new Error('Service characteristics no longer available');
      }
      log('‚úÖ BLE service verification passed');
    } catch (serviceError) {
      log('‚ö†Ô∏è Service verification failed: ' + serviceError.message);
      throw new Error('BLE service lost. Please reconnect.');
    }
    
    // Get selected request type
    const selectedType = document.querySelector('input[name="requestType"]:checked')?.value || 'full';
    const isPID = selectedType.startsWith('pid_');
    const docType = isPID ? 'EU PID' : 'mDL';
    log(`Building ${selectedType} ${docType} request...`);
    
    // Reduce delay and add connection check during delay
    log('‚è≥ Brief pause to ensure wallet readiness...');
    await new Promise(resolve => setTimeout(resolve, 100)); // Reduced to 100ms
    
    // Re-verify connection after delay
    if (!device.gatt.connected) {
      throw new Error('Connection lost during preparation. Please reconnect.');
    }
    
    const req = buildRequestByType(selectedType);
    
    // Debug: Log the request structure with comprehensive analysis
    try {
      const decoded = CBOR.decode(req);
      console.log('=== DETAILED REQUEST ANALYSIS ===');
      console.log('Full request structure:', JSON.stringify(decoded, null, 2));
      
      // Validate version
      if (!decoded.version) {
        console.error('‚ùå CRITICAL: Missing version field');
        log('‚ö†Ô∏è Request validation failed: Missing version');
      } else {
        console.log('‚úÖ Version:', decoded.version);
      }
      
      // Validate docRequests
      if (!decoded.docRequests || decoded.docRequests.length === 0) {
        console.error('‚ùå CRITICAL: Missing or empty docRequests array');
        log('‚ö†Ô∏è Request validation failed: Missing docRequests');
      } else {
        console.log('‚úÖ docRequests count:', decoded.docRequests.length);
      }
      
      const requestDoc = decoded.docRequests[0].itemsRequest;
      const namespace = isPID ? "eu.europa.ec.eudi.pid.1" : "org.iso.18013.5.1";
      
      // Validate itemsRequest structure
      if (!requestDoc) {
        console.error('‚ùå CRITICAL: Missing itemsRequest');
        log('‚ö†Ô∏è Request validation failed: Missing itemsRequest');
      } else {
        console.log('‚úÖ itemsRequest present');
        console.log('  - docType:', requestDoc.docType);
        console.log('  - requestInfo:', requestDoc.requestInfo ? 'present' : 'MISSING');
      }
      
      // Validate nameSpaces
      if (!requestDoc.nameSpaces || !requestDoc.nameSpaces[namespace]) {
        console.error('‚ùå CRITICAL: Missing or invalid nameSpaces');
        log(`‚ö†Ô∏è Request validation failed: Missing namespace ${namespace}`);
      } else {
        const fields = Object.keys(requestDoc.nameSpaces[namespace]);
        const fieldValues = Object.values(requestDoc.nameSpaces[namespace]);
        
        console.log(`‚úÖ Namespace ${namespace} present with ${fields.length} fields`);
        
        // Check field value types
        const allBoolean = fieldValues.every(v => typeof v === 'boolean');
        const allTrue = fieldValues.every(v => v === true);
        const allFalse = fieldValues.every(v => v === false);
        
        console.log('Field value analysis:');
        console.log('  - All boolean:', allBoolean);
        console.log('  - All true:', allTrue);
        console.log('  - All false:', allFalse);
        console.log('  - Field details:', requestDoc.nameSpaces[namespace]);
        
        if (allFalse) {
          console.warn('‚ö†Ô∏è WARNING: All fields are false - this indicates intent-to-retain, not request');
          log('‚ö†Ô∏è ISSUE FOUND: All request fields are FALSE - wallet expects TRUE for requested fields!');
        }
        
        log(`üìã Requesting ${fields.length} fields from ${requestDoc.docType}:`);
        fields.forEach(field => {
          const value = requestDoc.nameSpaces[namespace][field];
          log(`   - ${field}: ${value}`);
        });
      }
      
      // Check for readerAuth (should be omitted for basic requests)
      if (decoded.docRequests[0].readerAuth !== undefined) {
        console.warn('‚ö†Ô∏è WARNING: readerAuth present but should be omitted for basic requests');
        log('‚ö†Ô∏è readerAuth present (might cause issues with some wallets)');
      } else {
        console.log('‚úÖ readerAuth correctly omitted');
      }
      
      // Validate CBOR encoding size
      console.log('‚úÖ Request CBOR size:', req.length, 'bytes');
      console.log('‚úÖ Request structure validation complete');
      
      // Log hex dump for low-level debugging
      console.log('Request CBOR hex:', hex(req));
      
    } catch (e) {
      console.error('‚ùå CRITICAL: Could not decode request for validation:', e);
      log('‚ùå Request encoding failed - CBOR structure is invalid!');
      log(`Error: ${e.message}`);
      throw new Error('Invalid request CBOR structure: ' + e.message);
    }
    
    // Final connection check before encryption
    if (!device.gatt.connected) {
      throw new Error('Connection lost before encryption. Please reconnect.');
    }
    
    console.log('=== ENCRYPTING REQUEST ===');
    
    // First, verify the plaintext request
    console.log('Plaintext request CBOR:');
    console.log('  Length:', req.length, 'bytes');
    console.log('  Hex:', hex(req));
    
    // Decode and show structure
    try {
      const plainDecoded = CBOR.decode(req);
      console.log('  Decoded structure:', JSON.stringify(plainDecoded, null, 2));
    } catch (e) {
      console.error('  ERROR: Cannot decode plaintext request!', e);
    }
    
    // Verify encryption parameters
  console.log('Encryption parameters:');
  console.log('  SKReader (32 bytes):', hex(skReader));
  console.log('  Transcript AAD (32 bytes):', hex(transcriptAAD));
    
  const enc0 = await coseEncrypt0_AESGCM_Enc0(req, transcriptAAD, skReader);
    console.log('Encrypted request size:', enc0.length, 'bytes');
    
    // Verify COSE_Encrypt0 structure
    console.log('Verifying COSE_Encrypt0 structure:');
    try {
      const coseDecoded = CBOR.decode(enc0);
      console.log('  Structure is valid CBOR array');
      console.log('  Protected header:', hex(coseDecoded[0]));
      console.log('  Unprotected header IV:', coseDecoded[1] instanceof Map ? hex(coseDecoded[1].get(5)) : 'ERROR');
      console.log('  Ciphertext length:', coseDecoded[2].length, 'bytes');
      
      // Decode protected header to verify algorithm
      const protHdr = CBOR.decode(coseDecoded[0]);
      const algId = protHdr instanceof Map ? protHdr.get(1) : protHdr[1];
      console.log('  Algorithm ID:', algId, algId === 3 ? '(A256GCM ‚úÖ)' : '(WRONG! Should be 3)');
    } catch (e) {
      console.error('  ERROR: Invalid COSE_Encrypt0 structure!', e);
    }
    
    // Final connection check before sending
    if (!device.gatt.connected) {
      throw new Error('Connection lost after encryption. Please reconnect.');
    }
    
    log(`Sending encrypted request (${enc0.length} bytes)...`);
    
    // Add visual separator in logs
    log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    // Monitor connection during send
    let sendSuccess = false;
    try {
      await sendFragmented(enc0);
      sendSuccess = true;
    } catch (sendError) {
      log(`‚ùå Send failed: ${sendError.message}`);
      throw sendError;
    }
    
    // Verify connection after send
    if (!device.gatt.connected) {
      log('‚ö†Ô∏è WARNING: BLE disconnected immediately after sending!');
      log('üí° This means wallet received the request but rejected it');
      log('üí° Common causes:');
      log('   - Wrong encryption key');
      log('   - Invalid request structure');  
      log('   - Wallet doesn\'t support requested docType');
    } else {
      log('‚úÖ BLE connection stable after send');
    }
    
    log(`‚úÖ ${selectedType.toUpperCase()} ${docType} request sent as COSE_Encrypt0 (AES-256-GCM + Transcript AAD).`);
    log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    log('‚è≥ Waiting for wallet response...');
    log('üì± CHECK YOUR WALLET: You may need to approve the data sharing request');
    
    // Create expected data message based on request type
    let expectedData = '';
    let dataPoints = [];
    const requestObj = CBOR.decode(req);
    const ns = isPID ? requestObj.docRequests[0].itemsRequest.nameSpaces["eu.europa.ec.eudi.pid.1"] 
                     : requestObj.docRequests[0].itemsRequest.nameSpaces["org.iso.18013.5.1"];
    
    if (ns) {
      dataPoints = Object.keys(ns).filter(key => ns[key] === true);
      expectedData = dataPoints.join(', ');
    }
    
    if (dataPoints.length > 0) {
      log(`üí° Wallet should prompt to share ${dataPoints.length} data element(s): ${expectedData}`);
    } else {
      log(`‚ö†Ô∏è WARNING: No data elements marked as 'true' in request - wallet may not prompt!`);
    }
    
    // Set a timeout to remind user about wallet interaction
    setTimeout(() => {
      if (!rxBuffer.length) {  // Only show if no response received yet
        log('‚è∞ Still waiting for response. Check your wallet for approval prompts.');
        log(`üí° The wallet should be asking you to confirm sharing: ${expectedData || 'data'}`);
      }
    }, 10000); // 10 second reminder
    
  } catch (e) { 
    console.error('Send error:', e);
    log('Send error: ' + e.message);
    
    if (e.message.includes('GATT') || e.message.includes('not connected') || e.message.includes('service lost') || e.message.includes('no longer exists')) {
      log('ÔøΩ BLE Connection Issue Detected');
      log('üí° This is common with mDL wallets - they may disconnect between steps');
      log('‚úÖ SOLUTION: Click "Connect to Wallet" again, then "Send SessionEstablishment", then try your request');
      log('üéØ The session establishment worked perfectly - just need fresh connection');
      
      // Reset connection state but keep QR data
      device = server = service = chState = chC2S = chS2C = null;
      btnSend.disabled = true;
      
      // Offer quick reconnect if we have the service UUID
      if (svcUUID) {
        log('üöÄ QUICK TIP: Your wallet QR is still valid - just scan again!');
        btnConnect.style.color = 'white';
        setTimeout(() => {
          btnConnect.style.backgroundColor = '';
          btnConnect.style.color = '';
        }, 3000);
      }
    } else {
      log('‚ùå Request failed: ' + e.message);
      log('üí° Try using Compatibility Mode for different wallet types');
    }
  }
});

// Compatibility Mode - tries different protocol approaches
if (btnCompatMode) btnCompatMode.addEventListener('click', async () => {
  try {
    log('üîß Trying compatibility mode for wallet prompting...');
    
    // Try sending a simplified request without encryption first
    const selectedType = document.querySelector('input[name="requestType"]:checked')?.value || 'basic';
    const isPID = selectedType.startsWith('pid_');
    const docType = isPID ? 'EU PID' : 'mDL';
    
    log(`üìã Compatibility mode: ${selectedType} ${docType} request`);
    
    // Build a very basic, unencrypted request as some wallets expect this first
    const basicRequest = {
      version: "1.0",
      docRequests: [{
        itemsRequest: {
          docType: isPID ? "eu.europa.ec.eudi.pid.1" : "org.iso.18013.5.1",
          nameSpaces: isPID ? {
            "eu.europa.ec.eudi.pid.1": {
              "family_name": true,
              "given_name": true
            }
          } : {
            "org.iso.18013.5.1": {
              "family_name": true,
              "given_name": true
            }
          }
        }
      }]
    };
    
    const plainRequest = CBOR.encode(basicRequest);
    
    log('üîß Sending unencrypted basic request first...');
    await sendFragmented(plainRequest);
    
    // Wait a moment for wallet response
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    log('üîß Now trying with different encryption approach...');
    
    // Try with minimal AAD
    if (!sessionEstablished || !skReader) {
      throw new Error('Session not established ‚Äì run SessionEstablishment before compatibility mode encryption.');
    }

    const minimalAAD = new Uint8Array([0x01, 0x02, 0x03, 0x04]);
    const altEncRequest = await coseEncrypt0_AESGCM_Enc0(plainRequest, minimalAAD, skReader);
    
    log('üîß Sending minimally encrypted request...');
    await sendFragmented(altEncRequest);
    
    log('üîß Compatibility mode attempts complete. Check wallet for prompts.');
    log('üí° If still no prompt, the wallet may require a different protocol variant');
    
  } catch (e) {
    log('‚ùå Compatibility mode failed: ' + e.message);
  }
});

// Test Request - Send unencrypted to debug
if (btnTestRequest) btnTestRequest.addEventListener('click', async () => {
  try {
    log('üîç TEST MODE: Sending UNENCRYPTED request to diagnose wallet behavior...');
    log('‚ö†Ô∏è WARNING: This violates ISO 18013-5 but helps debug');
    
    const selectedType = document.querySelector('input[name="requestType"]:checked')?.value || 'basic';
    const req = buildRequestByType(selectedType);
    
    // Decode and show what we're sending
    const decoded = CBOR.decode(req);
    log('üìã Test request structure:');
    console.log('=== UNENCRYPTED TEST REQUEST ===');
    console.log('Request structure:', JSON.stringify(decoded, null, 2));
    console.log('Request CBOR hex:', hex(req));
    console.log('Request length:', req.length, 'bytes');
    
    // Verify all fields
    const ns = decoded.docRequests[0].itemsRequest.nameSpaces["org.iso.18013.5.1"] || 
               decoded.docRequests[0].itemsRequest.nameSpaces["eu.europa.ec.eudi.pid.1"];
    const fields = Object.keys(ns);
    const trueFields = fields.filter(f => ns[f] === true);
    
    log(`Request summary:`);
    log(`  docType: ${decoded.docRequests[0].itemsRequest.docType}`);
    log(`  Fields requested (${trueFields.length}): ${trueFields.join(', ')}`);
    log(`  All fields true: ${trueFields.length === fields.length ? '‚úÖ' : '‚ùå'}`);
    
    log(`‚ö° Sending ${req.length} bytes UNENCRYPTED...`);
    await sendFragmented(req);
    
    log('‚úÖ Unencrypted request sent successfully');
    log('üìä ANALYSIS:');
    log('  ‚úÖ If wallet responds: Issue is encryption/session keys');
    log('  ‚ùå If NO response: Issue is request format or BLE communication');
    log('  ‚è≥ Waiting for wallet response (check "Assembled wallet responses")...');
    
    setTimeout(() => {
      log('üí° After 5 seconds:');
      log('   - If you see S‚ÜíC response: Encryption is the problem');
      log('   - If NO response: Request format or docType mismatch');
      log('   - Some wallets reject unencrypted requests entirely');
    }, 5000);
    
  } catch (e) {
    log('‚ùå Test request error: ' + e.message);
    console.error('Test request failed:', e);
  }
});

// Full Diagnostics - Check complete state
if (btnDiagnose) btnDiagnose.addEventListener('click', async () => {
  log('üî¨ ========== FULL SYSTEM DIAGNOSTICS ==========');
  
  // 1. QR Code / Device Engagement
  log('üì± 1. DEVICE ENGAGEMENT STATUS:');
  log(`   DeviceEngagement bytes: ${deBytes ? deBytes.length + ' bytes' : 'NOT SET ‚ùå'}`);
  log(`   mdoc Public Key: ${mdocPubKey ? '‚úÖ Present (x:' + mdocPubKey.x.length + ', y:' + mdocPubKey.y.length + ')' : 'NOT SET ‚ùå'}`);
  log(`   Service UUID: ${svcUUID || 'NOT SET ‚ùå'}`);
  log(`   BLE Address: ${bleAddr || '(optional)'}`);
  
  // 2. BLE Connection
  log('üì° 2. BLE CONNECTION STATUS:');
  log(`   Device: ${device ? device.name || '(unnamed)' : 'NOT CONNECTED ‚ùå'}`);
  log(`   GATT Connected: ${device?.gatt?.connected ? '‚úÖ YES' : '‚ùå NO'}`);
  log(`   Service: ${service ? '‚úÖ Present' : '‚ùå Missing'}`);
  log(`   Characteristic State: ${chState ? '‚úÖ Present' : '‚ùå Missing'}`);
  log(`   Characteristic C2S: ${chC2S ? '‚úÖ Present' : '‚ùå Missing'}`);
  log(`   Characteristic S2C: ${chS2C ? '‚úÖ Present' : '‚ùå Missing'}`);
  
  // 3. Session Establishment
  log('üîê 3. SESSION CRYPTOGRAPHY STATUS:');
  log(`   Reader Key Pair: ${readerKeyPair ? '‚úÖ Generated' : 'NOT GENERATED ‚ùå'}`);
  log(`   Session Key (32 bytes): ${sessionKey ? '‚úÖ ' + hex(sessionKey) : 'NOT DERIVED ‚ùå'}`);
  log(`   Transcript AAD: ${transcriptAAD ? '‚úÖ ' + hex(transcriptAAD).substring(0, 40) + '...' : 'NOT BUILT ‚ùå'}`);
  
  // 4. Protocol State
  if (chState && device?.gatt?.connected) {
    try {
      const stateValue = await chState.readValue();
      const currentState = stateValue.getUint8(0);
      log(`üìä 4. PROTOCOL STATE: 0x${currentState.toString(16).padStart(2, '0')}`);
      if (currentState === 0x00) log('   ‚ö†Ô∏è IDLE - Need to click "Start (state=0x01)"');
      else if (currentState === 0x01) log('   ‚úÖ DATA TRANSFER - Ready for requests');
      else if (currentState === 0x02) log('   ‚ö†Ô∏è END - Protocol ended');
      else log('   ‚ö†Ô∏è Unknown state');
    } catch (e) {
      log(`üìä 4. PROTOCOL STATE: Cannot read (${e.message})`);
    }
  } else {
    log('üìä 4. PROTOCOL STATE: Cannot check (not connected) ‚ùå');
  }
  
  // 5. Summary
  log('üìã 5. READINESS CHECK:');
  const ready = deBytes && mdocPubKey && device?.gatt?.connected && 
                service && chState && chC2S && chS2C && 
                readerKeyPair && sessionKey && transcriptAAD;
  
  if (ready) {
    log('   ‚úÖ ALL SYSTEMS READY - Should be able to send requests');
    log('   üí° If wallet still not prompting, issue is likely:');
    log('      - Wallet requires different request format');
    log('      - Session key mismatch (wallet can\'t decrypt)');
    log('      - Wallet doesn\'t support requested docType');
  } else {
    log('   ‚ùå SYSTEM NOT READY:');
    if (!deBytes) log('      - Scan QR code first');
    if (!device?.gatt?.connected) log('      - Connect to wallet via BLE');
    if (!readerKeyPair || !sessionKey) log('      - Run session establishment');
  }
  
  log('üî¨ ========================================');
});

if (btnEnd) btnEnd.addEventListener('click', async () => {
  try { await writeState(0x02); } catch (e) { log('State error: ' + e.message); }
});

if (btnQuickReconnect) btnQuickReconnect.addEventListener('click', async () => {
  try {
    if (!svcUUID) {
      log('‚ùå No service UUID available. Please scan QR code first.');
      return;
    }
    
    log('üîÑ Quick reconnection starting...');
    log('üí° Make sure your wallet is ready and nearby');
    
    // Click connect, then establish session
    btnConnect.click();
    
    // Wait a moment then automatically establish session
    setTimeout(() => {
      if (device?.gatt?.connected && btnEstablish && !btnEstablish.disabled) {
        log('‚ö° Auto-establishing session...');
        btnEstablish.click();
      }
    }, 2000);
    
  } catch (e) {
    log('‚ùå Quick reconnect failed: ' + e.message);
  }
});

if (btnDisc) btnDisc.addEventListener('click', async () => {
  try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch (e) { log('Disconnect error: '+e.message); }
});
</script>
</html>