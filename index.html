<!doctype html>
<!--
  Copyright (c) 2025 Stelau
  Author: Nicolas Chalanset
-->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ISO 18013-5 Mobile Driver's License (mDL) mDoc Reader & Verifier</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Free web-based ISO 18013-5 mobile Driver's License (mDL) and mDoc reader and verifier. Scan QR codes, connect via Web Bluetooth, verify digital credentials, and validate IACA certificates. Works offline as a Progressive Web App.">
  <meta name="keywords" content="ISO 18013-5, mobile driver's license, mDL, mdoc, digital identity, digital credentials, Web Bluetooth, QR code scanner, IACA, certificate validation, PWA, progressive web app, CBOR, COSE, AES-GCM encryption, eIDAS, EUDIW, EUDI Wallet, EU Digital Identity Wallet">
  <meta name="author" content="Nicolas Chalanset">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  <meta name="revisit-after" content="7 days">
  <meta name="category" content="Technology">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://mdoc-web-verifier.stelau.com/">
  <meta property="og:title" content="ISO 18013-5 Mobile Driver's License Reader & Verifier">
  <meta property="og:description" content="Free web-based mDL reader with Web Bluetooth support. Scan, connect, and verify digital driver's licenses compliant with ISO 18013-5 standard.">
  <meta property="og:image" content="/assets/icon-512.png">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://mdoc-web-verifier.stelau.com/">
  <meta property="twitter:title" content="ISO 18013-5 mDL Reader & Verifier">
  <meta property="twitter:description" content="Free web-based mobile Driver's License reader with Web Bluetooth. Verify ISO 18013-5 digital credentials instantly.">
  <meta property="twitter:image" content="/assets/icon-512.png">
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#0f172a">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="mDL Reader">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://mdoc-web-verifier.stelau.com//">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Icons -->
  <link rel="icon" href="/assets/icon-192.png">
  <link rel="apple-touch-icon" href="/assets/icon-192.png">
  <link rel="mask-icon" href="/assets/icon-192.png" color="#0f172a">
  <style>
    :root { color-scheme: light dark; font-family: "Inter", "Segoe UI", sans-serif; line-height: 1.5; }
    body { margin: 0; background: #F2F4F8; color: #111827; }
    .page-header { background: linear-gradient(135deg,#0f172a,#1e293b); color: #f8fafc; margin-bottom: 3.5rem; padding: 1rem 1rem 1rem; text-align: center; }
    .page-header h1 { margin: 0; font-size: clamp(1.8rem,3vw,2.4rem); font-weight: 600; }
    .page-header p { margin: 0.75rem auto 0; max-width: 720px; color: rgba(248,250,252,0.8); }
    main { max-width: 1100px; margin: -2rem auto 3rem; padding: 0 1.5rem 3rem; }
    .card { background: #ffffff; border-radius: 18px; padding: 1.75rem; margin-top: 1.5rem; box-shadow: 0 20px 45px -25px rgba(15,23,42,0.35); border: 1px solid rgba(148,163,184,0.25); }
    .card h2 { margin-top: 0; font-size: 1.35rem; font-weight: 600; color: #0f172a; }
    .card h3 { margin-bottom: 0.5rem; margin-top: 1.5rem; font-size: 1.15rem; color: #0f172a; }
    .muted { color: #64748b; font-size: 0.95rem; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-top: 1rem; }
  .scanner { display: grid; gap: 1.5rem; margin-top: 1rem; grid-template-columns: 1fr 2fr; align-items: start; }
  .video-frame { position: relative; border-radius: 16px; overflow: hidden; background: #020617; min-height: 150px; }
    video#video { width: 100%; height: 100%; object-fit: cover; display: block; }
    canvas#canvas { display: none; }
  .status-panel { background: #f1f5f9; border-radius: 14px; padding: 1rem 1.25rem; font-size: 0.8rem; line-height: 1.2; }
    .status-panel span { font-family: "SFMono-Regular", "JetBrains Mono", ui-monospace, monospace; word-break: break-all; }
    label.inline { display: flex; align-items: center; gap: 0.5rem; font-weight: 500; }
    label.inline input[type="text"],
    label.inline input[type="number"] { flex: 1; min-width: 12rem; padding: 0.45rem 0.65rem; border-radius: 8px; border: 1px solid rgba(148,163,184,0.6); font-size: 0.95rem; }
  .manual-entry { margin-top: 1.5rem; display: grid; gap: 0.75rem; }
  .manual-entry textarea { width: 97%; min-height: 60px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.9rem; background: #f8fafc; resize: vertical; }
  .manual-entry textarea:focus { outline: 2px solid rgba(37,99,235,0.4); outline-offset: 2px; }
    button { font: inherit; font-weight: 600; padding: 0.55rem 1rem; border-radius: 10px; border: 1px solid rgba(15,23,42,0.08); background: #1d4ed8; color: #fff; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease; }
    button.secondary { background: #0f172a; }
    button:disabled { background: rgba(15,23,42,0.2); color: rgba(15,23,42,0.4); cursor: not-allowed; transform: none; box-shadow: none; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 12px 24px -18px rgba(30,64,175,0.9); }
    .button-grid { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; }
    .radio-group { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.75rem; }
    .radio-chip { display: inline-flex; align-items: center; gap: 0.45rem; background: #e2e8f0; border-radius: 999px; padding: 0.35rem 0.85rem; font-size: 0.95rem; cursor: pointer; transition: background 0.2s ease; }
    .radio-chip input { accent-color: #2563eb; }
    .radio-chip:hover { background: #cbd5f5; }
    .radio-group.request-type { gap: 0.5rem; }
    .radio-chip.small { padding: 0.3rem 0.75rem; font-size: 0.9rem; }
    #roleDescription { margin-top: 0.65rem; }
    .log { background: #0f172a; color: #f8fafc; padding: 1rem; border-radius: 14px; min-height: 200px; max-height: 280px; overflow-y: auto; font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; font-size: 0.85rem; }
    pre#rx { background: #f8fafc; border-radius: 14px; padding: 1rem; white-space: pre-wrap; word-break: break-word; min-height: 120px; border: 1px solid rgba(148,163,184,0.35); font-family: "SFMono-Regular","JetBrains Mono",ui-monospace,monospace; }
    
    /* Response Display Styles */
    #responseDisplay { background: #f8fafc; border-radius: 14px; padding: 1.5rem; border: 1px solid rgba(148,163,184,0.35); }
    .response-header { background: linear-gradient(135deg, #0f3d76, #1466b8); color: white; padding: 1rem 1.25rem; border-radius: 12px; margin-bottom: 1.5rem; }
    .response-header h3 { margin: 0; font-size: 1.25rem; font-weight: 600; color: white; }
    .response-meta { color: rgba(255,255,255,0.9); font-size: 0.9rem; margin-top: 0.35rem; }
    .document-card { background: white; border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; border: 1px solid rgba(148,163,184,0.25); box-shadow: 0 2px 8px rgba(0,0,0,0.04); }
    .document-type { font-size: 0.85rem; color: #0f766e; font-weight: 600; letter-spacing: 0.5px; margin-bottom: 0.75rem; }
    .namespace-section { margin-top: 1rem; }
    .namespace-title { background: #e0f2fe; color: #0c4a6e; padding: 0.5rem 0.75rem; border-radius: 8px; font-size: 0.9rem; font-weight: 600; margin-bottom: 0.75rem; display: inline-block; }
    .data-item { display: grid; grid-template-columns: 140px 1fr; gap: 0.75rem; padding: 0.65rem 0; border-bottom: 1px solid rgba(148,163,184,0.15); }
    .data-item:last-child { border-bottom: none; }
    .data-label { font-weight: 600; color: #475569; font-size: 0.9rem; }
    .data-value { color: #0f172a; font-size: 0.9rem; word-break: break-word; }
    .data-value.binary { color: #64748b; font-style: italic; }
    .data-value.portrait-preview { display: flex; align-items: center; gap: 0.75rem; }
    .portrait-thumbnail { max-width: 80px; max-height: 100px; border-radius: 6px; border: 2px solid rgba(148,163,184,0.3); }
    .no-data { color: #94a3b8; font-style: italic; text-align: center; padding: 2rem; }
    
    .chip-list { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-top: 0.5rem; }
    .chip { background: #e2e8f0; border-radius: 999px; padding: 0.25rem 0.75rem; font-size: 0.8rem; color: #0f172a; }
    
    /* Compatibility Warning Banner */
    .compat-warning { background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; padding: 1rem 1.5rem; margin: 0 auto 1.5rem; max-width: 1100px; border-radius: 12px; box-shadow: 0 8px 24px rgba(220, 38, 38, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); display: none; position: relative; z-index: 10; }
    .compat-warning.show { display: block; }
    .compat-warning strong { font-weight: 700; }
    .compat-warning p { margin: 0; line-height: 1.6; }
    .compat-warning ul { margin: 0.5rem 0 0 1.25rem; padding: 0; }
    .compat-warning a { color: #fef3c7; text-decoration: underline; }
    
    /* PWA Status Badge Animation */
    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }
    
    footer { text-align: center; padding: 2rem 1rem 3rem; color: #64748b; font-size: 0.9rem; }
    @media (max-width: 640px) {
  /* Stack scanner panels on small screens */
  .scanner { grid-template-columns: 1fr; }
      .card { padding: 1.25rem; border-radius: 14px; }
      button { width: 100%; justify-content: center; }
      .button-grid { flex-direction: column; }
      .status-panel { font-size: 0.9rem; }
      .data-item { grid-template-columns: 1fr; gap: 0.25rem; }
      /* Header/title tweaks for small screens */
      .page-header { padding: 0.75rem 0.75rem 0.75rem; margin-bottom: 2rem; }
      .page-header h1 { font-size: clamp(1.25rem, 5.5vw, 1.6rem); }
      .page-header p { font-size: 0.9rem; }
      main { margin: -1.25rem auto 2rem; padding: 0 1rem 2rem; }
      
      /* Response display: make denser and more legible on phones */
      #responseDisplay { padding: 1rem; border-radius: 12px; }
      .response-header { padding: 0.75rem 1rem; border-radius: 10px; }
      .response-header h3 { font-size: 1.05rem; }
      .response-meta { font-size: 0.85rem; }
      .document-card { padding: 0.9rem; margin-bottom: 0.75rem; border-radius: 10px; }
      .document-type { font-size: 0.8rem; }
      .namespace-title { font-size: 0.85rem; padding: 0.4rem 0.6rem; }
      .data-label { font-size: 0.85rem; }
      .data-value { font-size: 0.85rem; }
      .portrait-thumbnail { max-width: 68px; max-height: 86px; }
      
      /* Logs and text blocks */
      .log { font-size: 0.8rem; min-height: 160px; max-height: 240px; }
      pre#rx { font-size: 0.8rem; padding: 0.75rem; }
      
      /* Make PWA badge smaller and positioned better on mobile */
      #pwaStatus {
        top: 10px !important;
        right: 10px !important;
        padding: 0.4rem 0.75rem !important;
        font-size: 0.8rem !important;
        border-radius: 20px !important;
      }
      #pwaStatusText span {
        font-size: 0.95rem !important;
      }
    }
  </style>
  
  <!-- Structured Data (JSON-LD) for SEO -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "ISO 18013-5 Mobile Driver's License Reader",
    "alternateName": "mDL Reader",
    "url": "https://mdoc-web-verifier.stelau.com/",
    "description": "Free web-based ISO 18013-5 mobile Driver's License (mDL) reader and verifier with Web Bluetooth support, QR code scanning, and IACA certificate validation.",
    "applicationCategory": "UtilityApplication",
    "operatingSystem": "Web Browser (Chrome, Edge)",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "ISO 18013-5 Compliance",
      "Web Bluetooth GATT Communication",
      "QR Code Scanning",
      "CBOR Encoding/Decoding",
      "AES-256-GCM Encryption",
      "X.509 Certificate Validation",
      "IACA Trust Anchor Support",
      "Offline PWA Functionality",
      "Mobile Driver's License Verification",
      "Device Engagement Processing"
    ],
    "browserRequirements": "Requires HTTPS, Web Bluetooth API, Camera permission",
    "screenshot": "/assets/icon-512.png",
    "softwareVersion": "2.0",
    "datePublished": "2025-01-01",
    "dateModified": "2025-10-18",
    "creator": {
      "@type": "Organization",
      "name": "ISO 18013-5 Web Reader"
    },
    "potentialAction": {
      "@type": "UseAction",
      "target": {
        "@type": "EntryPoint",
        "urlTemplate": "https://mdoc-web-verifier.stelau.com/",
        "actionPlatform": [
          "http://schema.org/DesktopWebPlatform",
          "http://schema.org/MobileWebPlatform"
        ]
      }
    }
  }
  </script>
</head>
<body>
  <header class="page-header" role="banner">
    <h1>ISO 18013-5 Web Proximity Reader</h1>
    <p>Scan an <strong>mDL/mDoc device engagement QR code</strong>, connect over <strong>Web Bluetooth</strong>, and request <strong>digital credentials</strong>. Verify mobile Driver's Licenses compliant with <strong>ISO 18013-5 standard</strong>. Data is processed locally in the browser. No data is sent to external servers.</p>
  </header>
  
  <!-- PWA Status Badge - Fixed position top-right -->
  <div id="pwaStatus" style="
    display: none;
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(5, 150, 105, 0.95);
    backdrop-filter: blur(10px);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 24px;
    font-size: 0.85rem;
    font-weight: 500;
    box-shadow: 0 4px 16px rgba(5, 150, 105, 0.25), 0 2px 4px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    animation: slideInRight 0.3s ease-out;
    border: 1px solid rgba(255, 255, 255, 0.2);
  ">
    <span id="pwaStatusText" style="display: flex; align-items: center; gap: 0.5rem;">
      <span style="font-size: 1.1rem;">‚ú®</span>
      <span>Installed App</span>
    </span>
  </div>
  
  <div style="max-width: 1100px; margin: 0 auto; padding: 0 1.5rem;">
    <!-- Compatibility Warning Banner -->
    <div id="compatWarning" class="compat-warning">
      <p><strong>‚ö†Ô∏è Browser Compatibility Issue</strong></p>
      <p id="compatMessage"></p>
    </div>
  </div>
  
  <main>
    <section class="card" id="requestSection">
      <h2>1. Request Digital Credentials</h2>
      <p class="muted">Select one or more digital credential. You can request multiple digital credentials (e.g., PID + mDL) in a single session.</p>
      
      <div style="margin-bottom: 15px;">
        <strong>EU PID (Personal Identity Document)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_basic"> EU PID Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_age"> EU PID Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="pid_full" checked> EU PID Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>mDL (Mobile Driver's License)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mdl_basic"> mDL Basic
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mdl_age"> mDL Age Check
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mdl_driving"> mDL Driving
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mdl_full"> mDL Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>EU Age Verification (Proof of Age)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_18"> Age 18+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_21"> Age 21+
        </label>
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="age_verify_full"> Age Full
        </label>
      </div>
      
      <div style="margin: 15px 0 15px 0;">
        <strong>ISO 23220 Photo ID</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="photoid_full"> Photo ID Full
        </label>
      </div>

      <div style="margin: 15px 0 15px 0;">
        <strong>mICOV (Mobile International Certificate of Vaccination)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="micov_full"> mICOV Full
        </label>
      </div>

      <div style="margin: 15px 0 15px 0;">
        <strong>mVC (Mobile Vehicle Registration Certificate)</strong>
      </div>
      <div class="radio-group request-type">
        <label class="radio-chip small">
          <input type="checkbox" name="requestType" value="mvc_full"> mVC Full
        </label>
      </div>
    </section>

    <section class="card" id="qrSection">
      <h2>2. Device Engagement</h2>
      <p class="muted">Use your computer camera to capture the wallet's QR code or paste details manually.</p>
      <div class="row">
        <button id="btnScan">Scan QR Code</button>
      </div>
      <div class="scanner">
        <div class="video-frame">
          <video id="video" playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="status-panel">
          <p><strong>Status:</strong> <span id="qrStatus">Idle</span></p>
          <p><strong>Device Engagement URI:</strong> <span id="mdocUri">‚Äî</span></p>
          <p><strong>Service UUID:</strong> <span id="svcUuid">‚Äî</span></p>
          <p><strong>BLE Address:</strong> <span id="bleAddr">‚Äî</span></p>
        </div>
      </div>
      <div class="row">
        <label class="inline muted">BLE MTU (bytes)
          <input id="chunk" type="number" min="20" max="511" value="244">
        </label>
        <span class="muted" style="font-size: 0.9em; margin-left: 8px;">
          Packet size for BLE transmission. Default 185 bytes works with most modern devices. 
          Reduce to 20 if connection issues occur.
        </span>
      </div>

      <div class="manual-entry">
        <label class="muted" for="qrInput">Manual QR payload (paste from clipboard or laser scanner)</label>
        <textarea id="qrInput" placeholder="Paste the full mdoc: URI or CBOR payload here"></textarea>
        <div class="row" style="margin-top:0">
          <button id="btnParseQr" class="secondary">Use manual QR payload</button>
          <button id="btnClearQr">Clear</button>
        </div>
      </div>
    </section>

    <section class="card" id="responseSection" style="display: none;">
      <h2>3. Wallet Response</h2>
      <div id="responseDisplay"></div>
    </section>

    <section class="card" id="logsSection">
      <div style="display:flex; justify-content:space-between; align-items:center; gap: 8px;">
        <h2 style="margin:0;">üíª Activity Log</h2>
        <label style="display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none;">
          <span class="muted">Verbose in console</span>
          <span class="ra-switch">
            <input type="checkbox" id="toggleDebugCert" />
            <span class="ra-slider"></span>
          </span>
        </label>
      </div>
      <div class="log" id="log" role="log" aria-live="polite" aria-label="Session activity log"></div>
    </section>

    <!-- Reader Authentication Configuration (collapsible) -->
    <style>
      /* Reader Auth header toggle (switch style) */
      .ra-switch { position: relative; display: inline-block; width: 42px; height: 24px; }
      .ra-switch input { opacity: 0; width: 0; height: 0; }
      .ra-slider { position: absolute; cursor: pointer; inset: 0; background: #cbd5e1; transition: .2s; border-radius: 9999px; }
      .ra-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; top: 3px; background: #ffffff; transition: .2s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,.2); }
      .ra-switch input:checked + .ra-slider { background: #059669; }
      .ra-switch input:focus + .ra-slider { box-shadow: 0 0 0 3px rgba(5,150,105,0.25); }
      .ra-switch input:checked + .ra-slider:before { transform: translateX(18px); }
    </style>
    <section class="card" id="readerAuthSection">
      <div style="display:flex; justify-content:space-between; align-items:center; gap: 8px;">
        <h2 style="margin:0;">üîê Reader Authentication (Optional)</h2>
        <div style="display:flex; align-items:center; gap:10px;">
          <label style="display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none;">
            <span class="muted" style="font-size:0.9rem;">Enable</span>
            <span class="ra-switch">
              <input type="checkbox" id="enableReaderAuth">
              <span class="ra-slider"></span>
            </span>
          </label>
          <button 
            onclick="toggleDetails('readerAuthDetails')"
            class="secondary"
            style="display:inline-flex; align-items:center; gap:6px; padding: 6px 10px;"
          >
            <span id="readerAuthDetails-icon">‚ñ∂</span>
            Details
          </button>
        </div>
      </div>
      <p class="muted" style="margin-top: 0.5rem;">Configure reader authentication to prove your identity to the wallet. This adds a digitally signed certificate to document requests.</p>

      <div id="readerAuthDetails" style="display:none; margin-top: 0.75rem;">
        <div style="margin-top: 0.75rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
          <strong>‚ö†Ô∏è Security Warning:</strong>
          <p class="muted" style="margin-top: 0.5rem; margin-bottom: 0;">
            Reader authentication requires storing your <strong>private key</strong> in browser localStorage. 
            Only use this feature for testing purposes. In production, private keys should be stored in secure hardware (HSM/TPM).
          </p>
        </div>

        <div id="readerAuthConfig" style="margin-top: 1.0rem; display: none;">
        <div style="margin-bottom: 1rem;">
          <label class="muted">Reader Common Name (from certificate)</label>
          <div id="readerCommonName" style="width: 97%; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.3); font-size: 0.95rem; margin-top: 0.5rem; background:#f8fafc; color:#0f172a;">
            ‚Äî
          </div>
        </div>

        <div style="margin-bottom: 1rem;">
          <label class="muted" for="readerCertificate">Reader Certificate (PEM format)</label>
          <textarea id="readerCertificate" placeholder="-----BEGIN CERTIFICATE-----&#10;MIICx...&#10;-----END CERTIFICATE-----" style="width: 97%; min-height: 100px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem; background: #f8fafc; resize: vertical; margin-top: 0.5rem;"></textarea>
        </div>

        <div style="margin-bottom: 1rem;">
          <label class="muted" for="readerPrivateKey">Reader Private Key (PKCS#8 PEM format)</label>
          <textarea id="readerPrivateKey" placeholder="-----BEGIN PRIVATE KEY-----&#10;MIGHAgEAMBMGByqGSM49...&#10;-----END PRIVATE KEY-----" style="width: 97%; min-height: 70px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem; background: #f8fafc; resize: vertical; margin-top: 0.5rem;"></textarea>
        </div>

        <div class="row">
          <button id="btnSaveReaderCert">üíæ Save Reader Certificate</button>
          <button id="btnClearReaderCert" class="secondary">üóëÔ∏è Clear</button>
        </div>

        <div id="readerAuthStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 8px; display: none;">
          <!-- Status messages will appear here -->
        </div>

        <div style="margin-top: 1.0rem; padding: 1rem; background: #e7f3ff; border-radius: 8px; border: 1px solid #2196f3;">
          <strong>‚ÑπÔ∏è Testing Instructions:</strong>
          <p class="muted" style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
            Generate a self-signed certificate for testing:
          </p>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 0.75rem; border-radius: 6px; overflow-x: auto; font-size: 0.85rem; margin-top: 0.5rem;"><code># Generate P-256 private key
openssl ecparam -name prime256v1 -genkey -noout -out reader_key.pem

# Convert to PKCS#8 format (required)
openssl pkcs8 -topk8 -nocrypt -in reader_key.pem -out reader_key_pkcs8.pem

# Generate self-signed certificate
openssl req -new -x509 -key reader_key.pem -out reader_cert.pem -days 365 \
  -subj "/CN=Test Web Proximity Reader/O=ENCOM/C=US"</code></pre>
          <p class="muted" style="margin-top: 0.5rem; margin-bottom: 0;">
            Then paste the contents of <code>reader_cert.pem</code> and <code>reader_key_pkcs8.pem</code> into the fields above.
          </p>
        </div>
      </div>
    </section>

    <section class="card" id="iacaSection">
      <div style="display:flex; justify-content:space-between; align-items:center; gap: 8px;">
        <h2 style="margin:0;">‚öôÔ∏è Issuer Certificate Management (IACA)</h2>
        <div style="display:flex; align-items:center; gap:10px;">
          <span id="iacaSummaryCounts" class="muted" style="font-size:0.9rem;">Installed: Live 0 ‚Ä¢ Test 0</span>
          <button 
            onclick="toggleDetails('iacaDetails')"
            class="secondary"
            style="display:inline-flex; align-items:center; gap:6px; padding: 6px 10px;"
          >
            <span id="iacaDetails-icon">‚ñ∂</span>
            Details
          </button>
        </div>
      </div>
      <p class="muted" style="margin-top:0.5rem;">Manage Issuing Authority Certification Authority (IACA) certificates for signature verification. These are used to validate the mDoc issuer signatures.</p>
      
      <div id="iacaDetails" style="display:none; margin-top: 0.75rem;">
        <!-- Move Add New and VICAL to top -->
        <div style="margin-top: 0.5rem;">
          <strong>Add New IACA Certificate:</strong>
          <div style="margin-top: 0.75rem;">
            <label class="muted" for="iacaInput">Paste PEM certificate (-----BEGIN CERTIFICATE-----)</label>
            <textarea id="iacaInput" placeholder="-----BEGIN CERTIFICATE-----&#10;MIIDUzCCAvmgAwIBAgISESHtNjf+2KAQ0ttWtR9EhAAPMAoGCCqGSM49BAMCMIHF&#10;...&#10;-----END CERTIFICATE-----" style="width: 97%; min-height: 80px; padding: 0.75rem 0.9rem; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.85rem; background: #f8fafc; resize: vertical; margin-top: 0.5rem;"></textarea>
            <div style="margin-top: 0.75rem;">
              <label style="display: flex; align-items: center; cursor: pointer; user-select: none; gap:10px;">
                <span class="muted">This is a test/development certificate</span>
                <span class="ra-switch"><input type="checkbox" id="iacaIsTest"><span class="ra-slider"></span></span>
              </label>
            </div>
            <div class="row" style="margin-top: 0.5rem;">
              <button id="btnAddIaca">Add IACA Certificate</button>
              <button id="btnClearIacaInput" class="secondary">Clear</button>
            </div>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(148,163,184,0.35); margin: 1rem 0;" />

        <div style="margin-top: 1.0rem;">
          <strong>Import Verified Issuer CA List (VICAL):</strong>
          <p class="muted" style="margin-top: 0.35rem;">Provide a VICAL URI or upload a CBOR file containing one or more IACA certificates.</p>
          <div class="row" style="gap: 0.5rem; align-items: center; margin-top: 0.5rem; flex-wrap: wrap;">
            <input id="vicalUri" type="url" placeholder="https://example.org/vical.cbor or data:application/cbor;base64,..." style="flex: 1 1 380px; min-width: 260px; padding: 0.55rem 0.75rem; border-radius: 8px; border: 1px solid rgba(148,163,184,0.45); background: #f8fafc; font-size: 0.9rem;" />
            <button id="btnImportVicalUri">Import from URI</button>
          </div>
          <div class="row" style="gap: 0.5rem; align-items: center; margin-top: 0.5rem; flex-wrap: wrap;">
            <input id="vicalFile" type="file" accept=".cbor,.vical,application/cbor,application/octet-stream" />
            <button id="btnImportVicalFile">Import from File</button>
            <label style="display:flex; align-items:center; cursor:pointer; user-select:none; gap:10px;">
              <span class="muted">Mark imported as test</span>
              <span class="ra-switch"><input type="checkbox" id="vicalMarkTest"><span class="ra-slider"></span></span>
            </label>
          </div>
          <div id="vicalImportStatus" class="muted" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(148,163,184,0.35); margin: 1rem 0;" />

        <!-- Installed list moved below with Reset on same line -->
        <div style="margin-top: 1.0rem;">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
            <strong>Installed IACAs:</strong>
            <button 
              onclick="(function(){ if (confirm('Reset IACAs to defaults? This will remove all non-default certificates.')) { try { window.IacaManager?.resetToDefaults?.(); } catch(e) { alert('Reset failed: '+(e.message||e)); } } })()"
              class="secondary"
              title="Remove all non-default IACA certificates and restore defaults"
              style="display:inline-flex; align-items:center; gap:6px; padding: 6px 10px;"
            >
              ‚ôªÔ∏è Reset to Defaults
            </button>
          </div>
          <div id="iacaList" style="margin-top: 0.75rem; font-size: 0.9rem;">
            <div class="muted" style="font-style: italic;">Loading...</div>
          </div>
        </div>
      </div>
    </section>

    
  
  </main>
  <footer>
    Built by <a href="https://stelau.com">Stelau</a> for ISO 18013-5 experimentation. Web Bluetooth requires HTTPS and a compatible browser.
    <span id="appVersionFooter" style="display:block;margin-top:0.5rem;color:#64748b;font-size:0.7rem;"></span>
    <br>
    <span style="font-size:0.9em;color:#888;">&copy; 2025 Stelau. All rights reserved.</span>
  </footer>

<!-- Load libs BEFORE the module -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.min.js"></script>
<script src="js/noble-curves.min.js"></script>
<!-- JPEG 2000 decoder (OpenJPEG) for converting JP2/J2K portraits to JPEG -->
<script src="js/openjpeg.js"></script>
<script>
  // Setup noble-curves global access for all elliptic curves
  // The minified bundle should expose: p256, p384, p521, brainpoolP256r1, brainpoolP384r1, brainpoolP512r1
  if (typeof nobleCurves !== 'undefined') {
    window.nobleCurves = nobleCurves;
    console.log('‚úÖ @noble/curves loaded from local file');
    console.log('Available curves:', Object.keys(nobleCurves));
  } else {
    console.warn('‚ö†Ô∏è noble-curves.min.js not loaded - curve cryptography will not work');
  }
  // Optional: verify OpenJPEG availability
  if (typeof openjpeg === 'undefined') {
    console.warn('‚ö†Ô∏è JPEG2000 decoder (openjpeg) not loaded - JP2 portraits will not be auto-converted');
  } else {
    console.log('‚úÖ JPEG2000 decoder (openjpeg) loaded successfully');
  }
</script>
<!-- Feature modules (globals) -->
<script src="js/activity-log.js"></script>
  <script src="js/iaca-management.js"></script>
  <script src="js/reader-authentication.js"></script>
<script src="js/device-engagement.js"></script>
<script src="js/wallet-response.js"></script>
<script src="js/request-builder.js"></script>
<script src="js/ble-transport.js"></script>
<script src="js/session-crypto.js"></script>
<script src="js/session-establishment.js"></script>

<script type="module">
// ==== App Version (must match CACHE_VERSION in sw.js) ====
const APP_VERSION = 36; // IMPORTANT: Keep in sync with CACHE_VERSION in sw.js
// Expose globally for auxiliary modules
window.APP_VERSION = APP_VERSION;

// ==== CBOR bootstrap (works even if global isn't set) ====
let CBORRef = self.CBOR || self.cbor;
if (!CBORRef) {
  try { CBORRef = await import('https://cdn.jsdelivr.net/npm/cbor-web@9.0.2/dist/cbor.mjs'); }
  catch (e) { console.error('CBOR library load failed', e); }
}
if (!CBORRef) throw new Error('CBOR library unavailable. Check network/CSP.');
const CBOR = CBORRef;
// Expose CBOR globally for external modules
window.CBOR = CBOR;

// Simple global toggler for collapsible sections (used by inline onclick)
function toggleDetails(id) {
  try {
    const el = document.getElementById(id);
    if (!el) return;
    const visible = el.style.display !== 'none';
    el.style.display = visible ? 'none' : 'block';
    const icon = document.getElementById(`${id}-icon`);
    if (icon) icon.textContent = visible ? '‚ñ∂' : '‚ñº';
  } catch {}
}
window.toggleDetails = toggleDetails;

// ==== Browser Compatibility Check ====
function checkBrowserCompatibility() {
  const compatWarning = document.getElementById('compatWarning');
  const compatMessage = document.getElementById('compatMessage');
  const issues = [];
  
  // Check for HTTPS (required for Web Bluetooth)
  if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
    issues.push('This page must be served over HTTPS. Web Bluetooth is only available in secure contexts.');
  }
  
  // Check for Web Bluetooth API
  if (!navigator.bluetooth) {
    const userAgent = navigator.userAgent.toLowerCase();
    const isChrome = /chrome|chromium|edg/.test(userAgent) && !/firefox|safari/.test(userAgent);
    
    if (!isChrome) {
      issues.push('Web Bluetooth is not supported in this browser. Please use a Chromium-based browser (Chrome, Edge, or Brave).');
    } else {
      issues.push('Web Bluetooth API is not available. This may be due to browser flags or platform limitations.');
    }
  }
  
  // Check for required Web Bluetooth features
  if (navigator.bluetooth) {
    if (typeof navigator.bluetooth.requestDevice !== 'function') {
      issues.push('Web Bluetooth API is incomplete. The requestDevice() method is missing.');
    }
  }
  
  // Check for MediaDevices (camera for QR scanning)
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    issues.push('Camera access (MediaDevices API) is not available. QR code scanning will not work.');
  }
  
  // Check for Web Crypto API
  if (!window.crypto || !window.crypto.subtle) {
    issues.push('Web Crypto API is not available. Encryption and key derivation will fail.');
  }
  
  // Display warning if there are any issues
  if (issues.length > 0) {
    let message = '<ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem;">';
    issues.forEach(issue => {
      message += `<li>${issue}</li>`;
    });
    message += '</ul>';
    message += '<p style="margin-top: 0.75rem; font-size: 0.9rem;">For best results, use <strong>Chrome or Edge</strong> on desktop with HTTPS enabled.</p>';
    
    compatMessage.innerHTML = message;
    compatWarning.classList.add('show');
    
    console.warn('Browser compatibility issues detected:', issues);
    return false;
  }
  
  console.log('‚úì Browser compatibility check passed');
  return true;
}

// ==== PWA Status Indicator ====
function updatePWAStatus() {
  const pwaStatus = document.getElementById('pwaStatus');
  const pwaStatusText = document.getElementById('pwaStatusText');
  
  if (!pwaStatus || !pwaStatusText) return;
  
  // Check if running as installed PWA
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches 
                    || window.navigator.standalone === true
                    || document.referrer.includes('android-app://');
  
  // Check if service worker is active
  const hasServiceWorker = 'serviceWorker' in navigator && navigator.serviceWorker.controller;
  
  if (isStandalone) {
    pwaStatusText.innerHTML = '<span style="font-size: 1.1rem;">‚ú®</span><span>Installed App</span>';
    pwaStatus.style.display = 'block';
    pwaStatus.style.background = 'rgba(5, 150, 105, 0.95)';
    console.log('‚úì Running as PWA (standalone mode)');
  } else if (hasServiceWorker) {
    pwaStatusText.innerHTML = '<span style="font-size: 1.1rem;">üîÑ</span><span>Offline Ready</span>';
    pwaStatus.style.display = 'block';
    pwaStatus.style.background = 'rgba(99, 102, 241, 0.95)';
    console.log('‚úì Service Worker active (offline support enabled)');
  } else {
    pwaStatus.style.display = 'none';
  }
}

// Update PWA status on load and when display mode changes
window.addEventListener('load', updatePWAStatus);
window.matchMedia('(display-mode: standalone)').addEventListener('change', updatePWAStatus);

// Run compatibility check on page load
checkBrowserCompatibility();

// ==== DOM refs ====
const logEl = document.getElementById('log');
const responseDisplayEl = document.getElementById('responseDisplay');
const responseSectionEl = document.getElementById('responseSection');
const statusEl = document.getElementById('qrStatus');
const mdocUriEl = document.getElementById('mdocUri');
const svcUuidEl = document.getElementById('svcUuid');
const bleAddrEl = document.getElementById('bleAddr');
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const qrInput = document.getElementById('qrInput');
const btnParseQr = document.getElementById('btnParseQr');
const btnClearQr = document.getElementById('btnClearQr');

// Optional: focus the Manual QR payload textbox without scrolling the page
window.addEventListener('load', () => {
  try {
    if (qrInput && typeof qrInput.focus === 'function') {
      // Use preventScroll to avoid jumping down the page on load
      try { qrInput.focus({ preventScroll: true }); } catch { /* older browsers */ }
      // Do not fall back to plain focus() to keep the viewport at the top
    }
  } catch {}
});

const btnScan = document.getElementById('btnScan');
const btnSend = document.getElementById('btnSend');
const chunkInput = document.getElementById('chunk');

// IACA management UI elements
const iacaListEl = document.getElementById('iacaList');
const iacaInput = document.getElementById('iacaInput');
const btnAddIaca = document.getElementById('btnAddIaca');
const btnClearIacaInput = document.getElementById('btnClearIacaInput');
const toggleDebugCert = document.getElementById('toggleDebugCert');

// Helper: reveal and navigate to the Wallet Response section
function showResponseSectionAndScroll() {
  try {
    if (!responseSectionEl) return;
    responseSectionEl.style.display = 'block';
    // Smoothly scroll into view
    try { responseSectionEl.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {}
    // Update the URL hash without adding a new history entry
    try {
      if (typeof history?.replaceState === 'function') {
        history.replaceState(null, '', '#responseSection');
      } else {
        location.hash = '#responseSection';
      }
    } catch {}
  } catch {}
}
// VICAL elements
const vicalUri = document.getElementById('vicalUri');
const btnImportVicalUri = document.getElementById('btnImportVicalUri');
const vicalFile = document.getElementById('vicalFile');
const btnImportVicalFile = document.getElementById('btnImportVicalFile');
const vicalMarkTest = document.getElementById('vicalMarkTest');
const vicalImportStatus = document.getElementById('vicalImportStatus');

// Request type elements (now checkboxes for multi-document selection)
const requestTypeCheckboxes = document.querySelectorAll('input[name="requestType"]');

// Reader Authentication UI elements
const enableReaderAuth = document.getElementById('enableReaderAuth');
const readerAuthConfig = document.getElementById('readerAuthConfig');
// const readerOrgName = document.getElementById('readerOrgName'); // Removed
const readerCommonNameEl = document.getElementById('readerCommonName');
const readerCertificate = document.getElementById('readerCertificate');
const readerPrivateKey = document.getElementById('readerPrivateKey');
const btnSaveReaderCert = document.getElementById('btnSaveReaderCert');
const btnClearReaderCert = document.getElementById('btnClearReaderCert');
const readerAuthStatus = document.getElementById('readerAuthStatus');

// ==== State ====
let scanRunning = false;
 
const RX_FLUSH_TIMEOUT_MS = 1500;      // Timeout before attempting to process buffered data
 

 
let svcUUID = null;
let bleAddr = null;
let currentBleRole = 'central'; // Always central mode now

let deBytes = null;              // Raw DeviceEngagement CBOR bytes
let mdocPubKey = null;           // { x:Uint8Array, y:Uint8Array } P-256
let readerKeyPair = null;        // CryptoKeyPair (ECDH)
let skReader = null;             // Uint8Array(32) - Reader encrypts requests with this
let skDevice = null;             // Uint8Array(32) - Reader decrypts responses with this
window.skDevice = skDevice;
let sessionKey = null;           // DEPRECATED - kept for compatibility
let transcriptAAD = null;        // Uint8Array (SHA-256 of transcript CBOR)
let walletEphemeralKey = null;   // CryptoKey from wallet SessionEstablishment response
let sessionEstablished = false;  // Tracks if both sides derived matching session keys

// ==== Utils ====
const enc = new TextEncoder();
function log(msg) {
  // Delegate to global logger if available
  if (typeof window !== 'undefined' && typeof window.log === 'function') {
    return window.log(msg);
  }
  // Fallback minimal logger (keeps current behavior)
  const t = new Date().toLocaleTimeString();
  if (logEl) {
    logEl.innerHTML += `[${t}] ${msg}<br>`;
    logEl.scrollTop = logEl.scrollHeight;
  } else {
    console.log(`[log] ${msg}`);
  }
}
// Use shared helpers from SessionCrypto
const hex = (...args) => window.SessionCrypto.hex(...args);
const concatUint8 = (...args) => window.SessionCrypto.concatUint8(...args);

// Clear response panel and activity log for a new scan/manual run
function resetResponseAndLog() {
  try { if (responseDisplayEl) responseDisplayEl.innerHTML = ''; } catch {}
  try { if (responseSectionEl) responseSectionEl.style.display = 'none'; } catch {}
  try { if (logEl) logEl.innerHTML = ''; } catch {}
}

 

// Initialize debug toggle state
try {
  // Prefer general verbose key; fallback to legacy key
  let saved = localStorage.getItem('debug_verbose');
  if (saved === null) saved = localStorage.getItem('debug_cert');
  const initial = saved === null ? false : saved === 'true';
  window.DEBUG_CERT = initial;      // kept for existing gates
  window.DEBUG_VERBOSE = initial;   // general console verbose flag
  if (toggleDebugCert) {
    toggleDebugCert.checked = initial;
    toggleDebugCert.addEventListener('change', (e) => {
      const on = !!e.target.checked;
      window.DEBUG_CERT = on;
      window.DEBUG_VERBOSE = on;
      localStorage.setItem('debug_verbose', String(on));
      log(`Verbose console logging: ${on ? 'ON' : 'OFF'}`);
    });
  }
} catch {}
 

// Assemble and process a complete S‚ÜíC payload (called on final flag or timeout)
async function processS2CAssembled(assembled, reason = 'final-flag') {
  const len = assembled.length;
  log(`S‚ÜíC complete${reason ? ' (' + reason + ')' : ''}: ${len} bytes`);
  
  console.log('=== RECEIVED DATA FROM WALLET ===');
  console.log('Length:', len);
  console.log('Hex:', hex(assembled));
  
  // Try to decode the response
  try {
    const decoded = CBOR.decode(assembled);
    console.log('Decoded wallet response:', decoded);
    console.log('Response type:', typeof decoded);
    console.log('Is Map:', decoded instanceof Map);
    console.log('Is Object:', decoded && typeof decoded === 'object');
    
    // Check if this is a SessionEstablishment response (contains eDeviceKey)
    let isSessionResponse = false;
    
    // Log all fields to see what we actually received
    if (decoded instanceof Map) {
      console.log('Response is a Map with keys:', Array.from(decoded.keys()));
      if (decoded.has('eDeviceKey') || decoded.has('data') || decoded.has('status')) {
        isSessionResponse = true;
        console.log('‚úÖ Detected SessionEstablishment response (Map)');
      }
    } else if (decoded && typeof decoded === 'object') {
      console.log('Response object keys:', Object.keys(decoded));
      if (decoded.eDeviceKey || decoded.eReaderKey || decoded.data || decoded.status) {
        isSessionResponse = true;
        console.log('‚úÖ Detected SessionEstablishment response (Object)');
      }
    }
    
    // ANY response before session is established should be considered a session response
    // Check if session keys are established (skReader and skDevice are set)
    if (!skReader || !skDevice) {
      isSessionResponse = true;
      console.log('‚úÖ Detected response before session established - treating as session response');
    }
    
    if (isSessionResponse) {
      log('üìã Received session establishment response from wallet');
      log(`üîó Response size: ${len} bytes`);
      
      // Signal to session establishment handler
      window.sessionResponseReceived = true;
      window.sessionResponseData = assembled;
      
      try {
        await processSessionResponse(assembled);
      } catch (processError) {
        console.error('Failed to finalize session from response:', processError);
        log('‚ùå Session finalization failed: ' + processError.message);
      }
      
      console.log('Session response captured and signaled');
      
    } else if (skDevice && assembled.length > 20) {
      // This might be an encrypted DeviceResponse
      log('üîê Received encrypted response - attempting to decrypt...');
      try {
  // Decrypt and render the response
  await decryptAndRenderResponse(assembled);
      } catch (decryptError) {
        console.error('Decryption failed:', decryptError);
        log('‚ùå Decryption failed: ' + decryptError.message);
      }
    } else {
      log(`üìÑ Received ${len}-byte response from wallet`);
    }
  } catch (e) {
    console.log('Could not decode CBOR response:', e.message);
    log(`üìÑ Received ${len}-byte binary response from wallet`);
  }
}

 

// Bridge: Build view model from a DeviceResponse object
const buildResponseViewModel = (...args) => window.WalletResponse.buildResponseViewModel(...args);

// New: Render the wallet response view-model into the page
function renderResponseViewModel(model) {
  try {
    if (!responseDisplayEl) return;
    const version = (model && model.version) ? model.version : '1.0';
    const documents = Array.isArray(model?.documents) ? model.documents : [];
    if (!documents || documents.length === 0) {
      responseDisplayEl.innerHTML = `
        <div class="response-header">
          <h3>üéâ Response Received</h3>
          <div class="response-meta">Version: ${escapeHtml(String(version))}</div>
        </div>
        <div class="no-data">No documents found in response</div>
      `;
  if (typeof showResponseSectionAndScroll === 'function') showResponseSectionAndScroll();
      return;
    }

    let html = `
      <div class="response-header">
        <h3>üéâ Response Received</h3>
        <div class="response-meta">Version: ${escapeHtml(String(version))} ‚Ä¢ ${documents.length} document(s)</div>
        <button id="btnCopyResponse" class="copy-btn" style="margin-top: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
          üìã Copy as JSON
        </button>
      </div>
    `;

    const fmtLabel = (s) => (typeof formatFieldName === 'function') ? formatFieldName(s) : String(s);
    const esc = (s) => escapeHtml(String(s));

    // Helpers to normalize CBOR-wrapped structures that some wallets return
    const isTagged = (v) => {
      try { return v instanceof CBOR.Tagged || (v && v.constructor && v.constructor.name === 'Tagged'); } catch { return false; }
    };
    const toUint8 = (v) => {
      if (v instanceof Uint8Array) return v;
      if (ArrayBuffer.isView(v)) return new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
      if (v instanceof ArrayBuffer) return new Uint8Array(v);
      if (Array.isArray(v)) { try { return new Uint8Array(v); } catch {} }
      return null;
    };
    const tryCborDecode = (bytes) => {
      try {
        if (!bytes || !(bytes instanceof Uint8Array) || typeof CBOR?.decode !== 'function') return null;
        const decoded = CBOR.decode(bytes);
        if (decoded && (Array.isArray(decoded) || decoded instanceof Map || typeof decoded === 'object')) return decoded;
        return null;
      } catch { return null; }
    };
    const unwrapTaggedOrCbor = (v) => {
      let cur = v; let changed = true; let guard = 0;
      while (changed && guard++ < 4) {
        changed = false;
        if (isTagged(cur)) { cur = cur.value; changed = true; continue; }
        const asBytes = toUint8(cur);
        if (asBytes) {
          const dec = tryCborDecode(asBytes);
          if (dec != null) { cur = dec; changed = true; continue; }
        }
      }
      return cur;
    };
    const normalizeForPreview = (v) => {
      const cur = unwrapTaggedOrCbor(v);
      if (cur instanceof Map) {
        const obj = {};
        for (const [k, vv] of cur.entries()) obj[String(k)] = normalizeForPreview(vv);
        return obj;
      }
      if (Array.isArray(cur)) return cur.map(normalizeForPreview);
      if (cur && typeof cur === 'object') {
        const obj = {};
        for (const [k, vv] of Object.entries(cur)) obj[k] = normalizeForPreview(vv);
        return obj;
      }
      return cur;
    };

    // Pretty-print JSON content and normalize Tag(1004) full-date objects
    const normalizeTagDates = (val) => {
      const isPlainTag = (x) => x && typeof x === 'object' && typeof x.tag === 'number' && 'value' in x;
      const norm = (x) => {
        if (x == null) return x;
        if (Array.isArray(x)) return x.map(norm);
        if (isPlainTag(x)) {
          if (x.tag === 1004 && typeof x.value === 'string') return x.value; // RFC3339 full-date
          if ((x.tag === 0 || x.tag === 1) && (typeof x.value === 'string' || typeof x.value === 'number')) return x.value;
          return norm(x.value);
        }
        if (x && typeof x === 'object') {
          const out = Array.isArray(x) ? [] : {};
          for (const [k, v] of Object.entries(x)) out[k] = norm(v);
          return out;
        }
        return x;
      };
      return norm(val);
    };
    const prettyPrintMaybeJSON = (input) => {
      try {
        let obj = input;
        if (typeof input === 'string') obj = JSON.parse(input);
        obj = normalizeTagDates(obj);
        return JSON.stringify(obj, null, 2);
      } catch { return null; }
    };

    // Helper: get requested order snapshot for a given docType
    const getOrderForDocType = (dt) => {
      try {
        if (window.REQUEST_ORDERS_BY_DOCTYPE && window.REQUEST_ORDERS_BY_DOCTYPE[dt]) return window.REQUEST_ORDERS_BY_DOCTYPE[dt];
        if (window.LAST_REQUEST_ORDER && window.LAST_REQUEST_ORDER.docType === dt) return window.LAST_REQUEST_ORDER;
      } catch {}
      return null;
    };

    documents.forEach((doc) => {
      const docType = doc?.docType || 'Unknown';
      const order = getOrderForDocType(docType);
      html += `
        <div class="document-card">
          <div class="document-type">üìÑ ${esc(docType)}</div>
      `;

      const nsObjRaw = doc?.issuerSigned?.nameSpaces;
      const nsObj = unwrapTaggedOrCbor(nsObjRaw) || {};
      let nsEntries = (nsObj instanceof Map)
        ? Array.from(nsObj.entries())
        : (Array.isArray(nsObj) ? [['Data', nsObj]] : Object.entries(nsObj));

      // Reorder namespaces to mirror request order when available
      if (order && Array.isArray(order.namespaceOrder) && order.namespaceOrder.length) {
        const dict = new Map(nsEntries);
        const used = new Set();
        const ordered = [];
        for (const nsName of order.namespaceOrder) {
          if (dict.has(nsName)) { ordered.push([nsName, dict.get(nsName)]); used.add(nsName); }
        }
        // Append any extra namespaces not in the original request order
        for (const [k, v] of nsEntries) { if (!used.has(k)) ordered.push([k, v]); }
        nsEntries = ordered;
      }

      nsEntries.forEach(([nsName, items]) => {
        html += `
          <div class="namespace-section">
            <div class="namespace-title">üì¶ ${esc(nsName)}</div>
        `;

        items = unwrapTaggedOrCbor(items);
        let itemsArr = (items instanceof Map)
          ? Array.from(items.values())
          : (Array.isArray(items) ? items : (items && typeof items === 'object' ? Object.values(items) : []));

        if ((!itemsArr || itemsArr.length === 0) && items && typeof items === 'object') {
          if (("elementIdentifier" in items) || ("elementValue" in items)) {
            itemsArr = [items];
          }
        }

        if (!Array.isArray(itemsArr) || itemsArr.length === 0) {
          // Try to use raw namespace snapshot from model if available
          const rawNs = (doc?.issuerSigned && doc.issuerSigned._rawNameSpaces)
            ? doc.issuerSigned._rawNameSpaces[nsName]
            : null;
          const previewSource = rawNs ?? items;
          if (previewSource) {
            const previewObj = normalizeForPreview(previewSource);
            try {
              const preview = JSON.stringify(previewObj, null, 2);
              html += `<div class="data-item"><div class="data-label">Raw items</div><div class="data-value"><pre style="margin:0;font-size:0.85em">${esc(preview)}</pre></div></div>`;
            } catch {
              html += '<div class="no-data">No items in namespace</div>';
            }
          } else {
            html += '<div class="no-data">No items in namespace</div>';
          }
          html += `</div>`;
          return;
        }

        // Sort items to mirror the field order from the request, when available
        if (order && order.fieldsOrder && Array.isArray(order.fieldsOrder[nsName])) {
          const seq = order.fieldsOrder[nsName];
          const pos = new Map();
          seq.forEach((k, i) => pos.set(String(k), i));
          itemsArr = itemsArr.slice().sort((a, b) => {
            const ida = (a && (a.elementIdentifier || a.label)) ? String(a.elementIdentifier || a.label) : '';
            const idb = (b && (b.elementIdentifier || b.label)) ? String(b.elementIdentifier || b.label) : '';
            const ia = pos.has(ida) ? pos.get(ida) : Number.MAX_SAFE_INTEGER;
            const ib = pos.has(idb) ? pos.get(idb) : Number.MAX_SAFE_INTEGER;
            if (ia !== ib) return ia - ib;
            return 0;
          });
        }

        itemsArr.forEach((entry0, idx) => {
          try {
            const entry = unwrapTaggedOrCbor(entry0) ?? entry0;
            const label = (entry && (entry.label || entry.elementIdentifier)) ? (entry.label || entry.elementIdentifier) : `Item ${idx+1}`;
            const kind = entry?.valueKind;
            let valueHtml = '';

            if (kind === 'date') {
              valueHtml = `<div class="data-value">üìÖ ${esc(entry.text ?? '')}</div>`;
            } else if (kind === 'time-rfc3339' || kind === 'time-epoch') {
              valueHtml = `<div class="data-value">üïê ${esc(entry.text ?? '')}</div>`;
            } else if (kind === 'boolean') {
              const yes = (entry.text || '').toLowerCase().startsWith('y');
              valueHtml = `<div class="data-value">${yes ? '‚úì Yes' : '‚úó No'}</div>`;
            } else if (kind === 'mrz') {
              // ICAO 9303 Machine Readable Zone
              const icao = entry.icao || {};
              const parsed = icao.parsed || {};
              let mrzHtml = `<div class="data-value mrz-display">`;
              mrzHtml += `<div style="margin-bottom: 0.75rem;">`;
              mrzHtml += `<strong>üìÑ ICAO 9303 Machine Readable Zone (MRZ)</strong>`;
              mrzHtml += `</div>`;
              // MRZ meta: format (TD1/TD2/TD3) and number of lines
              if (icao && (icao.format || (icao.lines && icao.lines.length))) {
                const fmt = icao.format ? String(icao.format) : '';
                const count = Array.isArray(icao.lines) ? icao.lines.length : 0;
                const width = (Array.isArray(icao.lines) && icao.lines.length > 0) ? (icao.lines[0]?.length || 0) : 0;
                mrzHtml += `<div class="chip-list">`;
                if (fmt) {
                  const dim = (count && width) ? ` (${count}√ó${width})` : '';
                  mrzHtml += `<span class="chip">Format: ${esc(fmt)}${esc(dim)}</span>`;
                }
                if (count) mrzHtml += `<span class="chip">${count} line(s)</span>`;
                mrzHtml += `</div>`;
              }
              
              // Raw MRZ lines in monospace
              if (icao.lines) {
                mrzHtml += `<div style="font-family: 'SFMono-Regular','JetBrains Mono',ui-monospace,monospace; font-size: 0.9rem; background: #f8fafc; padding: 0.5rem; border-radius: 4px; margin-bottom: 0.75rem; line-height: 1.2; border: 1px solid rgba(148,163,184,0.25);">`;
                icao.lines.forEach(line => {
                  mrzHtml += `${esc(line)}<br>`;
                });
                mrzHtml += `</div>`;
              }
              
              // Parsed fields
              if (Object.keys(parsed).length > 0) {
                mrzHtml += `<div style="display: grid; gap: 0.5rem; font-size: 0.9rem;">`;
                if (parsed.documentType) mrzHtml += `<div><strong>Document Type:</strong> ${esc(parsed.documentType)}</div>`;
                if (parsed.issuingCountry) mrzHtml += `<div><strong>Issuing Country:</strong> ${esc(parsed.issuingCountry)}</div>`;
                if (parsed.surname) mrzHtml += `<div><strong>Surname:</strong> ${esc(parsed.surname)}</div>`;
                if (parsed.givenNames) mrzHtml += `<div><strong>Given Names:</strong> ${esc(parsed.givenNames)}</div>`;
                if (parsed.passportNumber || parsed.documentNumber) mrzHtml += `<div><strong>Document Number:</strong> ${esc(parsed.passportNumber || parsed.documentNumber)}</div>`;
                if (parsed.nationality) mrzHtml += `<div><strong>Nationality:</strong> ${esc(parsed.nationality)}</div>`;
                if (parsed.dateOfBirth) mrzHtml += `<div><strong>Date of Birth:</strong> ${esc(parsed.dateOfBirth)}</div>`;
                if (parsed.sex) mrzHtml += `<div><strong>Sex:</strong> ${esc(parsed.sex)}</div>`;
                if (parsed.expirationDate) mrzHtml += `<div><strong>Expiration Date:</strong> ${esc(parsed.expirationDate)}</div>`;
                mrzHtml += `</div>`;
              }
              mrzHtml += `</div>`;
              valueHtml = mrzHtml;
            } else if (kind === 'array') {
              const pretty = typeof entry?.text === 'string' ? prettyPrintMaybeJSON(entry.text) : null;
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${esc(pretty ?? (entry.text ?? ''))}</pre></div>`;
            } else if (kind === 'object') {
              const pretty = typeof entry?.text === 'string' ? prettyPrintMaybeJSON(entry.text) : null;
              valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em">${esc(pretty ?? (entry.text ?? ''))}</pre></div>`;
            } else if (kind === 'portrait') {
              const meta = entry.binary || {};
              const icaoNote = entry.icao ? ' (ICAO DG2)' : '';
              // Only render an <img> when we truly have bytes to show
              if (meta.dataUri && meta.empty !== true && (meta.length || 0) > 0) {
                valueHtml = `
                  <div class="data-value portrait-preview">
                    <img src="${meta.dataUri}" alt="Portrait" class="portrait-thumbnail" />
                    <span class="binary">${(meta.length ?? '?').toString()} bytes (${esc(meta.formatLabel || 'image')})${esc(icaoNote)}</span>
                  </div>
                `;
              } else {
                const bytesLabel = (meta.length ?? '?').toString();
                const note = (meta.empty === true || (meta.length === 0)) ? ' ‚Äî no portrait image provided' : '';
                valueHtml = `<div class="data-value portrait-preview"><span class="binary">${bytesLabel} bytes (${esc(meta.formatLabel || 'image')})${esc(icaoNote)}${esc(note)}</span></div>`;
              }
            } else if (kind === 'bytes') {
              const meta = entry.binary || {};
              valueHtml = `<div class="data-value binary">&lt;binary data, ${(meta.length ?? '?').toString()} bytes (${esc(meta.formatLabel || meta.mimeType || 'binary')})&gt;</div>`;
            } else if (entry && typeof entry === 'object' && (entry.text != null)) {
              // If this is a long JSON-looking string, pretty-print it into a block
              let rendered = String(entry.text ?? '');
              let usedPre = false;
              if (rendered.trim().startsWith('{') || rendered.trim().startsWith('[')) {
                const pretty = prettyPrintMaybeJSON(rendered);
                if (pretty) { rendered = pretty; usedPre = true; }
              } else if (rendered.length > 160) {
                // Long content: show in a pre block for readability
                usedPre = true;
              }
              if (usedPre) {
                valueHtml = `<div class="data-value"><pre style="margin:0;font-size:0.85em; white-space:pre-wrap; word-break:break-word;">${esc(rendered)}</pre></div>`;
              } else {
                valueHtml = `<div class="data-value">${esc(rendered)}</div>`;
              }
            } else if (entry && typeof entry === 'object' && (entry.elementValue !== undefined)) {
              try {
                const unwrappedVal = unwrapTaggedOrCbor(entry.elementValue);
                const preview = JSON.stringify(unwrappedVal, null, 2);
                valueHtml = `<div class="data-value"><pre style=\"margin:0;font-size:0.85em\">${esc(preview)}</pre></div>`;
              } catch {
                valueHtml = `<div class="data-value binary">[unparsed item]</div>`;
              }
            } else {
              valueHtml = `<div class="data-value">${esc(String(entry ?? ''))}</div>`;
            }

            html += `
              <div class="data-item">
                <div class="data-label">${esc(fmtLabel(label))}</div>
                ${valueHtml}
              </div>
            `;
          } catch (e) {
            html += `
              <div class="data-item">
                <div class="data-label">Item ${idx+1}</div>
                <div class="data-value binary">(parse error: ${esc(e.message || e)})</div>
              </div>
            `;
          }
        });

        html += `</div>`;
      });

      const sig = doc?.signature;
      if (sig) {
        // Derive curve from certificate OID if possible
        let curveLabel = '';
        try {
          if (sig.coseSign1 && (sig.coseSign1[1] instanceof Map || typeof sig.coseSign1[1] === 'object')) {
            const unprot = sig.coseSign1[1];
            let cert = unprot instanceof Map ? unprot.get(33) : unprot?.[33];
            if (cert) {
              const certBytes = cert instanceof Uint8Array ? cert : new Uint8Array(cert.buffer, cert.byteOffset||0, cert.byteLength||cert.length||0);
              const cv = detectCurveFromCertOID(certBytes);
              if (cv) curveLabel = ` ‚Äî Curve: ${esc(cv)}`;
            }
          }
        } catch {}

        // Decode and normalize complete MSO from payload for JSON view
        let msoJson = null;
        try {
          // Helpers for MSO JSON formatting
          const timeKeys = new Set(['signed','validFrom','validUntil','expectedUpdate']);
          const toISOTime = (v) => {
            try {
              if (v == null) return v;
              if (v && typeof v === 'object' && typeof v.tag === 'number' && v.value !== undefined) {
                // Plain-object tag shape
                if (v.tag === 1) return new Date(v.value * 1000).toISOString();
                if (v.tag === 0 || v.tag === 1004) return new Date(v.value).toISOString();
                return toISOTime(v.value);
              }
              if (v && v.constructor && v.constructor.name === 'Tagged') {
                if (v.tag === 1) return new Date(v.value * 1000).toISOString();
                if (v.tag === 0 || v.tag === 1004) return new Date(v.value).toISOString();
                return toISOTime(v.value);
              }
              if (v instanceof Date) return v.toISOString();
              if (typeof v === 'number') return new Date(v * 1000).toISOString();
              if (typeof v === 'string') return new Date(v).toISOString();
              return v;
            } catch { return v; }
          };
          const massageMSO = (obj) => {
            if (obj == null) return obj;
            if (Array.isArray(obj)) return obj.map(massageMSO);
            if (obj instanceof Uint8Array) return obj; // handled by replacer
            if (obj && typeof obj === 'object') {
              const out = Array.isArray(obj) ? [] : {};
              for (const [k, v] of Object.entries(obj)) {
                if (timeKeys.has(k)) {
                  out[k] = toISOTime(v);
                } else {
                  out[k] = massageMSO(v);
                }
              }
              return out;
            }
            return obj;
          };
          const toBase64 = (bytes) => {
            try {
              let bin = '';
              for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
              return btoa(bin);
            } catch { return '';
            }
          };
          const msoReplacer = (_k, v) => {
            try {
              if (v instanceof Uint8Array || (v && v.constructor && v.constructor.name === 'Uint8Array')) {
                return { _type: 'bytes', _length: v.length, _base64: toBase64(v) };
              }
              // Detect Node.js Buffer-like objects: { type: 'Buffer', data: [..] }
              if (v && typeof v === 'object' && v.type === 'Buffer' && Array.isArray(v.data)) {
                const arr = v.data;
                let ok = true;
                for (let i = 0; i < arr.length; i++) {
                  const n = arr[i];
                  if (typeof n !== 'number' || n < 0 || n > 255) { ok = false; break; }
                }
                if (ok) {
                  const bytes = new Uint8Array(arr.length);
                  for (let i = 0; i < arr.length; i++) bytes[i] = arr[i] & 0xFF;
                  return { _type: 'bytes', _length: bytes.length, _base64: toBase64(bytes) };
                }
              }
              // Fallback: detect numeric-keyed byte-like objects and convert
              if (v && typeof v === 'object' && !Array.isArray(v)) {
                const keys = Object.keys(v);
                if (keys.length && keys.every(k => /^\d+$/.test(k))) {
                  const sorted = keys.map(k => parseInt(k,10)).sort((a,b)=>a-b);
                  const isSeq = sorted[0] === 0 && sorted[sorted.length-1] === sorted.length-1;
                  if (isSeq) {
                    let ok = true; const bytes = new Uint8Array(sorted.length);
                    for (let i=0;i<sorted.length;i++) {
                      const val = v[String(i)];
                      if (typeof val !== 'number' || val < 0 || val > 255) { ok = false; break; }
                      bytes[i] = val & 0xFF;
                    }
                    if (ok) return { _type: 'bytes', _length: bytes.length, _base64: toBase64(bytes) };
                  }
                }
              }
            } catch {}
            return v;
          };

          // Normalizer that unwraps Tagged/CBOR but PRESERVES Uint8Array for replacer
          const normalizePreserveBytes = (val) => {
            const cur = unwrapTaggedOrCbor(val);
            if (cur instanceof Map) {
              const obj = {};
              for (const [k, vv] of cur.entries()) obj[String(k)] = normalizePreserveBytes(vv);
              return obj;
            }
            if (Array.isArray(cur)) return cur.map(normalizePreserveBytes);
            // Preserve Date instances so they survive JSON.stringify (will become ISO)
            if (cur instanceof Date) return cur;
            // Preserve typed arrays so replacer can format them
            if (cur instanceof Uint8Array) return cur;
            if (cur && typeof cur === 'object') {
              const obj = {};
              for (const [k, vv] of Object.entries(cur)) obj[k] = normalizePreserveBytes(vv);
              return obj;
            }
            return cur;
          };

          const payload = sig.coseSign1?.[2];
          if (payload) {
            const pBytes = payload instanceof Uint8Array ? payload : new Uint8Array(payload.buffer || payload, payload.byteOffset||0, payload.byteLength||payload.length||0);
            const msoFull = CBOR.decode(pBytes);
            const normalized = normalizePreserveBytes(msoFull);
            const transformed = massageMSO(normalized);
            msoJson = JSON.stringify(transformed, msoReplacer, 2);
          }
          // Fallback: if payload decode path fails to yield, try signature.mso from model
          if (!msoJson && sig.mso) {
            const normalized = normalizePreserveBytes(sig.mso);
            const transformed = massageMSO(normalized);
            msoJson = JSON.stringify(transformed, msoReplacer, 2);
          }
        } catch {}

        const docIdxLocal = documents.indexOf(doc);
        const detailsId = `issuerDetails-${docIdxLocal}`;
        const msoViewId = `msoView-${docIdxLocal}`;
        const sigStatusId = `sigStatus-${docIdxLocal}`;
        const chainStatusId = `chainStatus-${docIdxLocal}`;

        // Format MSO dates
        const fmtDate = (s) => { try { return s ? new Date(s).toLocaleDateString() : '‚Äî'; } catch { return s || '‚Äî'; } };
        const fmtDateTime = (s) => { try { return s ? new Date(s).toLocaleString() : '‚Äî'; } catch { return s || '‚Äî'; } };

        html += `
          <div class="signer-section" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
            <div style="display:flex; justify-content:space-between; align-items:center; gap: 8px;">
              <div style="font-weight: bold; color: #007bff;">üîê Issuer Signature Information</div>
              <button 
                onclick="toggleDetails('${detailsId}')" 
                style="
                  background: #e2e8f0;
                  color: #0f172a;
                  border: 1px solid #cbd5e1;
                  padding: 4px 10px;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: 0.85rem;
                  font-weight: 600;
                  display: inline-flex;
                  align-items: center;
                  gap: 6px;
                "
                onmouseover="this.style.background='#cbd5e1'"
                onmouseout="this.style.background='#e2e8f0'"
              >
                <span id="${detailsId}-icon">‚ñ∂</span>
                <span>Details</span>
              </button>
            </div>

            <div class="verification-section" style="margin-top: 12px; padding: 12px; background: #ffffff; border-radius: 8px; border: 1px solid #e2e8f0;">
              <div style="font-weight: 600; margin-bottom: 8px; color: #0f172a;">‚úçÔ∏è Verification Status</div>
              <div class="data-item">
                <div class="data-label">Signature</div>
                <div class="data-value" id="${sigStatusId}">‚Ä¶ verifying</div>
              </div>
              <div class="data-item">
                <div class="data-label">Chain</div>
                <div class="data-value" id="${chainStatusId}">‚Ä¶ validating</div>
              </div>
            </div>

            <div id="${detailsId}" style="display:none; margin-top: 10px;">
              <div class="data-item"><div class="data-label" style="white-space: nowrap;">üì¶ MSO (Mobile Security Object)</div><div class="data-value"></div></div>
              ${sig.mso ? `
                <div class="data-item"><div class="data-label">MSO DocType</div><div class="data-value">${esc(sig.mso.docType || '‚Äî')}</div></div>
                <div class="data-item"><div class="data-label">Signed</div><div class="data-value">üìÖ ${fmtDateTime(sig.mso.signed)}</div></div>
                <div class="data-item"><div class="data-label">Valid From</div><div class="data-value">üìÖ ${fmtDate(sig.mso.validFrom)}</div></div>
                <div class="data-item"><div class="data-label">Valid Until</div><div class="data-value">üìÖ ${fmtDate(sig.mso.validUntil)}</div></div>
                <div class="data-item"><div class="data-label">Digest Algorithm</div><div class="data-value">${esc(sig.mso.digestAlgorithm || '‚Äî')}</div></div>
              ` : ''}

              ${msoJson ? `
                <div style="margin:8px 0 4px 0;">
                  <details>
                    <summary style="cursor: pointer; user-select: none; font-weight: 600;">View complete MSO Structure</summary>
                    <div style="margin-top: 8px;">
                      <pre id="${msoViewId}" style="max-height: 240px; overflow: auto; background: #0f172a; color: #e2e8f0; padding: 8px; border-radius: 6px;">${esc(msoJson)}</pre>
                      <button type="button" data-action="copy-mso" data-target="${msoViewId}" 
                        style="margin-top:6px; background: #e2e8f0; color: #0f172a; border: 1px solid #cbd5e1; padding: 4px 10px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 600;"
                        onmouseover="this.style.background='#cbd5e1'" onmouseout="this.style.background='#e2e8f0'"
                      >Copy</button>
                    </div>
                  </details>
                </div>
              ` : ''}

              <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 12px 0;" />

              <div class="data-item"><div class="data-label">üßæ Document signer</div><div class="data-value"></div></div>
              <div class="data-item"><div class="data-label">Signature Algorithm</div><div class="data-value">${esc(sig.algorithm || '‚Äî')}${curveLabel}</div></div>
              ${sig.certificate ? `
                <div class="data-item"><div class="data-label">Subject</div><div class="data-value">${esc(sig.certificate.subject || '‚Äî')}</div></div>
                <div class="data-item"><div class="data-label">Issuer</div><div class="data-value">${esc(sig.certificate.issuer || '‚Äî')}</div></div>
                <div class="data-item"><div class="data-label">Valid From</div><div class="data-value">üìÖ ${sig.certificate.notBefore ? fmtDateTime(sig.certificate.notBefore) : '‚Äî'}</div></div>
                <div class="data-item"><div class="data-label">Valid Until</div><div class="data-value">üìÖ ${sig.certificate.notAfter ? fmtDateTime(sig.certificate.notAfter) : '‚Äî'}</div></div>
              ` : ''}
            </div>
          </div>
        `;
      }

      html += `</div>`;
    });

  // Inject the assembled HTML
  responseDisplayEl.innerHTML = html;
  if (typeof showResponseSectionAndScroll === 'function') showResponseSectionAndScroll();

    const copyBtn = document.getElementById('btnCopyResponse');
    if (copyBtn) {
      copyBtn.addEventListener('click', async () => {
        try {
          const payload = (typeof convertToJSON === 'function') ? convertToJSON(model) : model;
          const text = (typeof payload === 'string') ? payload : JSON.stringify(payload, null, 2);
          await navigator.clipboard.writeText(text);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => (copyBtn.textContent = 'üìã Copy as JSON'), 1200);
        } catch {}
      });
    }

    // Wire MSO JSON copy buttons
    const copyMsoButtons = responseDisplayEl.querySelectorAll('[data-action="copy-mso"]');
    copyMsoButtons.forEach((btn) => {
      const targetId = btn.getAttribute('data-target');
      const targetEl = document.getElementById(targetId);
      if (!targetEl) return;
      btn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(targetEl.textContent || '');
          const old = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => { btn.textContent = old; }, 1200);
        } catch {}
      });
    });

    const verifyButtons = responseDisplayEl.querySelectorAll('[data-action="verify"][data-doc-index]');
    verifyButtons.forEach((btn) => {
      const idxStr = btn.getAttribute('data-doc-index');
      const idx = idxStr != null ? parseInt(idxStr, 10) : NaN;
      if (Number.isNaN(idx) || !documents[idx] || !documents[idx].signature || !documents[idx].signature.coseSign1) return;
      const doc = documents[idx];
      const sig = doc.signature;
      const resultEl = btn?.parentElement?.querySelector('.verify-result');
      const sigEl = document.getElementById(`sigStatus-${idx}`);
      const chainEl = document.getElementById(`chainStatus-${idx}`);
      btn.addEventListener('click', async () => {
        btn.disabled = true; const prev = btn.textContent; btn.textContent = 'Verifying‚Ä¶'; if (resultEl) resultEl.textContent='';
        try {
          const res = await window.verifyCOSESign1SignatureWithChain(sig.coseSign1);
          const parts = [];
          parts.push(res.signatureValid ? '‚úî Signature valid' : '‚úó Signature invalid');
          if (res.chainValid != null) parts.push(res.chainValid ? '‚úî Chain valid' : '‚úó Chain invalid');
          if (res.chainInfo && Array.isArray(res.chainInfo.chain)) parts.push('Chain: ' + res.chainInfo.chain.join(' '));
          if (Array.isArray(res.errors) && res.errors.length) parts.push('Errors: ' + res.errors.join('; '));
          if (resultEl) { resultEl.textContent = parts.join(' ¬∑ '); resultEl.style.color = (res.signatureValid && (res.chainValid !== false)) ? '#065f46' : '#991b1b'; }
          if (sigEl) { sigEl.textContent = res.signatureValid ? '‚úÖ Valid' : '‚ùå Invalid'; sigEl.style.color = res.signatureValid ? '#065f46' : '#991b1b'; }
          if (chainEl) { chainEl.textContent = res.chainValid ? '‚úÖ Valid' : '‚ùå Invalid'; chainEl.style.color = res.chainValid ? '#065f46' : '#991b1b'; }
        } catch (err) {
          if (resultEl) { resultEl.textContent = 'Verification error: ' + (err.message || err); resultEl.style.color = '#991b1b'; }
          if (sigEl) { sigEl.textContent = '‚ùå Error'; sigEl.style.color = '#991b1b'; }
          if (chainEl) { chainEl.textContent = '‚ùå Error'; chainEl.style.color = '#991b1b'; }
        } finally {
          btn.disabled = false; btn.textContent = prev;
        }
      });
    });

    // Wire signature section toggles
    const toggleButtons = responseDisplayEl.querySelectorAll('.mso-toggle');
    toggleButtons.forEach((tb) => {
      tb.addEventListener('click', () => {
        const id = tb.getAttribute('data-target');
        const el = document.getElementById(id);
        if (!el) return;
        const visible = el.style.display !== 'none';
        el.style.display = visible ? 'none' : 'block';
      });
    });

    // Auto-verify signature and chain if verifier is available
    if (typeof window.verifyCOSESign1SignatureWithChain === 'function') {
      documents.forEach(async (doc, idx) => {
        try {
          const sig = doc?.signature; if (!sig || !sig.coseSign1) return;
          const sigEl = document.getElementById(`sigStatus-${idx}`);
          const chainEl = document.getElementById(`chainStatus-${idx}`);
          const res = await window.verifyCOSESign1SignatureWithChain(sig.coseSign1);
          if (sigEl) { sigEl.textContent = res.signatureValid ? '‚úÖ Valid' : '‚ùå Invalid'; sigEl.style.color = res.signatureValid ? '#065f46' : '#991b1b'; }
          if (chainEl) { 
            if (res.chainValid == null) { chainEl.textContent = '‚Äî'; chainEl.style.color = '#0f172a'; }
            else { chainEl.textContent = res.chainValid ? '‚úÖ Valid' : '‚ùå Invalid'; chainEl.style.color = res.chainValid ? '#065f46' : '#991b1b'; }
          }
        } catch (e) {
          const sigEl = document.getElementById(`sigStatus-${idx}`);
          const chainEl = document.getElementById(`chainStatus-${idx}`);
          if (sigEl) { sigEl.textContent = '‚ùå Error'; sigEl.style.color = '#991b1b'; }
          if (chainEl) { chainEl.textContent = '‚ùå Error'; chainEl.style.color = '#991b1b'; }
        }
      });
    }
  } catch (e) {
    console.error('Render error:', e);
    try {
      responseDisplayEl.textContent = 'Failed to render response: ' + (e.message || e);
  if (typeof showResponseSectionAndScroll === 'function') showResponseSectionAndScroll();
    } catch {}
  }
}

// New: Decrypt COSE_Encrypt0 response and render
async function decryptAndRenderResponse(encryptedBytes) {
  const deviceResponse = await window.WalletResponse.decryptCoseEncrypt0ToObject(encryptedBytes);
  const model = buildResponseViewModel(deviceResponse);
  console.log('Decrypted DeviceResponse view model:', model);
  renderResponseViewModel(model);
  // Auto-disconnect to release BLE icon (simplified)
  try {
    if (window.BLE && typeof window.BLE.disconnect === 'function') {
      window.BLE.disconnect();
    }
  } catch (e) { console.warn('Auto-disconnect failed:', e); }
}

// Bridge: AES-GCM decryption
const aesGcmDecrypt = (...args) => window.WalletResponse.aesGcmDecrypt(...args);

// ===== SIGNATURE VERIFICATION FUNCTIONS =====

// Extract public key from X.509 certificate (DER format)
// Supports NIST curves (P-256, P-384) via Web Crypto API
// Supports Brainpool curves (P-256r1, P-320r1, P-384r1, P-512r1) via @noble/curves
async function extractPublicKeyFromCert(certDer, quiet = false) {
  try {
    console.log('Extracting public key from certificate, size:', certDer.length);
    
    const cert = new Uint8Array(certDer);
    
    // Detect curve type from OID
    // NIST P-256: 1.2.840.10045.3.1.7 -> 0x2A 0x86 0x48 0xCE 0x3D 0x03 0x01 0x07
    // NIST P-384: 1.3.132.0.34 -> 0x2B 0x81 0x04 0x00 0x22
    // NIST P-521: 1.3.132.0.35 -> 0x2B 0x81 0x04 0x00 0x23
    // Brainpool P256r1: 1.3.36.3.3.2.8.1.1.7  -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x07
  // Brainpool P320r1: 1.3.36.3.3.2.8.1.1.9  -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x09
  // Brainpool P384r1: 1.3.36.3.3.2.8.1.1.11 -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x0B
    // Brainpool P512r1: 1.3.36.3.3.2.8.1.1.13 -> 0x2B 0x24 0x03 0x03 0x02 0x08 0x01 0x01 0x0D
    
    const curveOIDs = {
      'P-256': [0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07],
      'P-384': [0x2B, 0x81, 0x04, 0x00, 0x22],
      'P-521': [0x2B, 0x81, 0x04, 0x00, 0x23],
      'brainpoolP256r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07],
  'brainpoolP320r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09],
  'brainpoolP384r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B],
      'brainpoolP512r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D]
    };
    
    const findOID = (oid) => {
      for (let i = 0; i < cert.length - oid.length; i++) {
        if (cert.slice(i, i + oid.length).every((byte, idx) => byte === oid[idx])) {
          return i;
        }
      }
      return -1;
    };
    
    // Detect which curve is used
    let detectedCurve = null;
    for (const [curveName, oid] of Object.entries(curveOIDs)) {
      if (findOID(oid) !== -1) {
        detectedCurve = curveName;
        console.log(`‚úì Detected curve: ${curveName}`);
        break;
      }
    }
    
    if (!detectedCurve) {
      throw new Error('Could not detect EC curve from certificate OID');
    }
    
    // Determine expected key size based on curve
    const keySizes = {
      'P-256': 65,
      'P-384': 97,
      'P-521': 133,
      'brainpoolP256r1': 65,
      'brainpoolP320r1': 81,
      'brainpoolP384r1': 97,
      'brainpoolP512r1': 129
    };
    
    const coordSizes = {
      'P-256': 32,
      'P-384': 48,
      'P-521': 66,
      'brainpoolP256r1': 32,
      'brainpoolP320r1': 40,
      'brainpoolP384r1': 48,
      'brainpoolP512r1': 64
    };
    
    const keySize = keySizes[detectedCurve];
    const coordSize = coordSizes[detectedCurve];
    
    // Find the uncompressed EC public key (starts with 0x04)
    let publicKeyBytes = null;
    for (let i = 0; i < cert.length - keySize; i++) {
      if (cert[i] === 0x04) {
        const candidate = cert.slice(i, i + keySize);
        
        // Verify it's preceded by reasonable DER structure
        // Typically: 0x03 (BIT STRING tag), length, 0x00 (no unused bits), 0x04...
        if (i >= 2 && cert[i - 1] === 0x00 && cert[i - 2] >= keySize + 1) {
          publicKeyBytes = candidate;
          console.log(`Found ${detectedCurve} public key at offset ${i}`);
          break;
        }
      }
    }
    
    if (!publicKeyBytes) {
      throw new Error(`Could not find ${detectedCurve} public key in certificate`);
    }
    
    // Extract X and Y coordinates (skip the 0x04 prefix)
    const x = publicKeyBytes.slice(1, 1 + coordSize);
    const y = publicKeyBytes.slice(1 + coordSize, 1 + 2 * coordSize);
    
    console.log(`Extracted ${detectedCurve} X:`, hex(x));
    console.log(`Extracted ${detectedCurve} Y:`, hex(y));
    
    // Use @noble/curves for all curves (both NIST and Brainpool)
    if (!window.nobleCurves) {
      if (!quiet) console.error('‚ùå @noble/curves library not loaded');
      return null;
    }
    
    // Map curve names to noble-curves property names
    const curveMap = {
      'P-256': 'p256',
      'P-384': 'p384',
      'P-521': 'p521',
      'brainpoolP256r1': 'brainpoolP256r1',
  'brainpoolP320r1': 'brainpoolP320r1',
  'brainpoolP384r1': 'brainpoolP384r1',
      'brainpoolP512r1': 'brainpoolP512r1'
    };
    
    const nobleCurveName = curveMap[detectedCurve];
    if (!nobleCurveName || !window.nobleCurves[nobleCurveName]) {
      if (!quiet) console.error(`‚ùå Curve ${detectedCurve} (${nobleCurveName}) not available in @noble/curves`);
      if (!quiet) console.log('Available curves:', Object.keys(window.nobleCurves));
      return null;
    }
    
    // Return raw key data for noble-curves verification
    console.log(`‚úÖ ${detectedCurve} public key extracted (using @noble/curves for verification)`);
    return {
      key: publicKeyBytes, // Full uncompressed point (0x04 || X || Y)
      curve: detectedCurve,
      nobleCurveName: nobleCurveName,
      type: 'noble',
      x: x,
      y: y
    };
    
  } catch (err) {
    if (!quiet) console.error('Error extracting public key:', err.message);
    return null;
  }
}

// Lightweight helper for UI: detect EC curve from certificate OID without requiring a crypto implementation
// Returns one of: 'P-256','P-384','P-521','brainpoolP256r1','brainpoolP320r1','brainpoolP384r1','brainpoolP512r1', or null if not found
function detectCurveFromCertOID(certDer) {
  try {
    const cert = certDer instanceof Uint8Array ? certDer : new Uint8Array(certDer);
    const curveOIDs = {
      'P-256': [0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07],
      'P-384': [0x2B, 0x81, 0x04, 0x00, 0x22],
      'P-521': [0x2B, 0x81, 0x04, 0x00, 0x23],
      'brainpoolP256r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07],
      'brainpoolP320r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x09],
      'brainpoolP384r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B],
      'brainpoolP512r1': [0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D]
    };
    const findOID = (oid) => {
      for (let i = 0; i <= cert.length - oid.length; i++) {
        let ok = true;
        for (let j = 0; j < oid.length; j++) {
          if (cert[i + j] !== oid[j]) { ok = false; break; }
        }
        if (ok) return i;
      }
      return -1;
    };
    for (const [curveName, oid] of Object.entries(curveOIDs)) {
      if (findOID(oid) !== -1) return curveName;
    }
    return null;
  } catch {
    return null;
  }
}

// Extract certificate information (Subject CN, Issuer CN) from X.509 DER certificate
function extractCertInfo(certDer) {
  try {
    const cert = new Uint8Array(certDer);
    
    // Helper to parse DER length
    function parseDerLength(bytes, offset) {
      const firstByte = bytes[offset];
      if (firstByte < 0x80) {
        return { length: firstByte, bytesUsed: 1 };
      }
      const numBytes = firstByte & 0x7F;
      let length = 0;
      for (let i = 0; i < numBytes; i++) {
        length = (length << 8) | bytes[offset + 1 + i];
      }
      return { length, bytesUsed: 1 + numBytes };
    }
    
    // Helper to extract PrintableString or UTF8String
    function extractString(bytes, offset) {
      const tag = bytes[offset];
      const lenInfo = parseDerLength(bytes, offset + 1);
      const strStart = offset + 1 + lenInfo.bytesUsed;
      const strEnd = strStart + lenInfo.length;
      
      // Tags: 0x0C = UTF8String, 0x13 = PrintableString, 0x16 = IA5String
      if (tag === 0x0C || tag === 0x13 || tag === 0x16) {
        const strBytes = bytes.slice(strStart, strEnd);
        return new TextDecoder().decode(strBytes);
      }
      return null;
    }
    
    // Find Common Name (CN) in a Name structure
    // CN OID is 2.5.4.3 = 06 03 55 04 03
    function findCN(bytes, start, end) {
      const cnOid = new Uint8Array([0x06, 0x03, 0x55, 0x04, 0x03]);
      
      for (let i = start; i < end - 10; i++) {
        // Check if we found the CN OID
        if (bytes[i] === 0x06 && bytes[i + 1] === 0x03 &&
            bytes[i + 2] === 0x55 && bytes[i + 3] === 0x04 && bytes[i + 4] === 0x03) {
          // CN OID found, next should be the string value
          // Skip to the string (usually right after the OID)
          let offset = i + 5;
          // The string is typically wrapped in a SET, then the actual string
          if (bytes[offset] === 0x31) { // SET tag
            offset++; // skip tag
            const lenInfo = parseDerLength(bytes, offset);
            offset += lenInfo.bytesUsed;
          }
          // Now should be the string (PrintableString, UTF8String, etc.)
          const cn = extractString(bytes, offset);
          if (cn) return cn;
        }
      }
      return null;
    }
    
    // Parse complete Distinguished Name (DN) structure
    function parseDN(bytes, start, end) {
      // Common X.509 attribute OIDs
      const oidMap = {
        '06 03 55 04 03': 'CN',    // Common Name
        '06 03 55 04 05': 'SN',    // Serial Number
        '06 03 55 04 06': 'C',     // Country
        '06 03 55 04 07': 'L',     // Locality
        '06 03 55 04 08': 'ST',    // State/Province
        '06 03 55 04 0A': 'O',     // Organization
        '06 03 55 04 0B': 'OU',    // Organizational Unit
        '06 09 2A 86 48 86 F7 0D 01 09 01': 'E', // Email
      };
      
      const components = [];
      let offset = start;
      
      // DN is a SEQUENCE of SETs, each SET contains a SEQUENCE with OID and value
      while (offset < end) {
        // Expect SET tag (0x31)
        if (bytes[offset] !== 0x31) {
          offset++;
          continue;
        }
        offset++; // skip SET tag
        
        const setLenInfo = parseDerLength(bytes, offset);
        offset += setLenInfo.bytesUsed;
        const setEnd = offset + setLenInfo.length;
        
        // Inside SET, expect SEQUENCE (0x30)
        if (offset < setEnd && bytes[offset] === 0x30) {
          offset++; // skip SEQUENCE tag
          const seqLenInfo = parseDerLength(bytes, offset);
          offset += seqLenInfo.bytesUsed;
          
          // Now should have OID followed by value
          if (bytes[offset] === 0x06) { // OID tag
            const oidOffset = offset;
            offset++; // skip OID tag
            const oidLenInfo = parseDerLength(bytes, offset);
            offset += oidLenInfo.bytesUsed;
            const oidBytes = bytes.slice(offset, offset + oidLenInfo.length);
            offset += oidLenInfo.length;
            
            // Convert OID bytes to string key
            const oidKey = Array.from(oidBytes).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            const oidKey2 = `06 ${oidLenInfo.length.toString(16).padStart(2, '0').toUpperCase()} ${oidKey}`;
            
            // Get attribute name
            const attrName = oidMap[oidKey2] || `OID(${oidKey})`;
            
            // Extract value string
            const value = extractString(bytes, offset);
            if (value) {
              components.push(`${attrName}=${value}`);
            }
          }
        }
        
        offset = setEnd;
      }
      
      return components.join(', ');
    }
    
    // X.509 Certificate structure:
    // SEQUENCE {
    //   tbsCertificate SEQUENCE {
    //     version [0] EXPLICIT
    //     serialNumber
    //     signature (algorithm)
    //     issuer Name      <-- We want CN from here
    //     validity
    //     subject Name     <-- We want CN from here
    //     ...
    //   }
    // }
    
    // Start by finding the main SEQUENCE
    let offset = 0;
    if (cert[offset] !== 0x30) throw new Error('Not a valid DER certificate');
    offset++;
    
    const certLenInfo = parseDerLength(cert, offset);
    offset += certLenInfo.bytesUsed;
    
    // Now we're inside the certificate SEQUENCE
    // Next should be tbsCertificate SEQUENCE
    if (cert[offset] !== 0x30) throw new Error('Invalid tbsCertificate');
    offset++;
    
    const tbsLenInfo = parseDerLength(cert, offset);
    const tbsStart = offset + tbsLenInfo.bytesUsed;
    const tbsEnd = tbsStart + tbsLenInfo.length;
    offset = tbsStart;
    
    // Skip version (optional [0] EXPLICIT)
    if (cert[offset] === 0xA0) {
      offset++; // skip tag
      const verLenInfo = parseDerLength(cert, offset);
      offset += verLenInfo.bytesUsed + verLenInfo.length;
    }
    
    // Skip serialNumber (INTEGER)
    if (cert[offset] === 0x02) {
      offset++; // skip tag
      const snLenInfo = parseDerLength(cert, offset);
      offset += snLenInfo.bytesUsed + snLenInfo.length;
    }
    
    // Skip signature algorithm (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const algLenInfo = parseDerLength(cert, offset);
      offset += algLenInfo.bytesUsed + algLenInfo.length;
    }
    
    // Now we should be at issuer Name (SEQUENCE)
    let issuerCN = null;
    let issuerDN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const issuerLenInfo = parseDerLength(cert, offset);
      const issuerStart = offset + issuerLenInfo.bytesUsed;
      const issuerEnd = issuerStart + issuerLenInfo.length;
      
      issuerCN = findCN(cert, issuerStart, issuerEnd);
      issuerDN = parseDN(cert, issuerStart, issuerEnd);
      
      offset = issuerEnd;
    }
    
    // Skip validity (SEQUENCE)
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const valLenInfo = parseDerLength(cert, offset);
      offset += valLenInfo.bytesUsed + valLenInfo.length;
    }
    
    // Now we should be at subject Name (SEQUENCE)
    let subjectCN = null;
    let subjectDN = null;
    if (cert[offset] === 0x30) {
      offset++; // skip tag
      const subjectLenInfo = parseDerLength(cert, offset);
      const subjectStart = offset + subjectLenInfo.bytesUsed;
      const subjectEnd = subjectStart + subjectLenInfo.length;
      
      subjectCN = findCN(cert, subjectStart, subjectEnd);
      subjectDN = parseDN(cert, subjectStart, subjectEnd);
    }
    
    return { subjectCN, issuerCN, subjectDN, issuerDN };
    
  } catch (err) {
    console.warn('Error parsing certificate info:', err);
    return { subjectCN: null, issuerCN: null, subjectDN: null, issuerDN: null };
  }
}

// Extract validity dates from X.509 DER certificate
function extractCertValidity(certDer) {
  try {
    const cert = new Uint8Array(certDer);
    
    // Helper to parse DER length
    function parseDerLength(bytes, offset) {
      const firstByte = bytes[offset];
      if (firstByte < 0x80) {
        return { length: firstByte, bytesUsed: 1 };
      }
      const numBytes = firstByte & 0x7F;
      let length = 0;
      for (let i = 0; i < numBytes; i++) {
        length = (length << 8) | bytes[offset + 1 + i];
      }
      return { length, bytesUsed: 1 + numBytes };
    }
    
    // Helper to parse ASN.1 time (UTCTime or GeneralizedTime)
    function parseTime(bytes, offset) {
      const tag = bytes[offset];
      const lenInfo = parseDerLength(bytes, offset + 1);
      const timeStart = offset + 1 + lenInfo.bytesUsed;
      const timeEnd = timeStart + lenInfo.length;
      const timeBytes = bytes.slice(timeStart, timeEnd);
      const timeStr = new TextDecoder().decode(timeBytes);
      
      // UTCTime: 0x17 (YYMMDDHHMMSSZ)
      // GeneralizedTime: 0x18 (YYYYMMDDHHMMSSZ)
      if (tag === 0x17) {
        // UTCTime format: YYMMDDHHMMSSZ
        const year = parseInt(timeStr.substr(0, 2));
        const fullYear = year >= 50 ? 1900 + year : 2000 + year;
        const month = parseInt(timeStr.substr(2, 2)) - 1;
        const day = parseInt(timeStr.substr(4, 2));
        const hour = parseInt(timeStr.substr(6, 2));
        const minute = parseInt(timeStr.substr(8, 2));
        const second = parseInt(timeStr.substr(10, 2));
        return new Date(Date.UTC(fullYear, month, day, hour, minute, second));
      } else if (tag === 0x18) {
        // GeneralizedTime format: YYYYMMDDHHMMSSZ
        const year = parseInt(timeStr.substr(0, 4));
        const month = parseInt(timeStr.substr(4, 2)) - 1;
        const day = parseInt(timeStr.substr(6, 2));
        const hour = parseInt(timeStr.substr(8, 2));
        const minute = parseInt(timeStr.substr(10, 2));
        const second = parseInt(timeStr.substr(12, 2));
        return new Date(Date.UTC(year, month, day, hour, minute, second));
      }
      return null;
    }
    
    // Navigate to validity field
    let offset = 0;
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const certLenInfo = parseDerLength(cert, offset);
    offset += certLenInfo.bytesUsed;
    
    // TBSCertificate SEQUENCE
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const tbsLenInfo = parseDerLength(cert, offset);
    offset += tbsLenInfo.bytesUsed;
    
    // Skip version (optional [0] EXPLICIT)
    if (cert[offset] === 0xA0) {
      offset++;
      const verLenInfo = parseDerLength(cert, offset);
      offset += verLenInfo.bytesUsed + verLenInfo.length;
    }
    
    // Skip serialNumber
    if (cert[offset] === 0x02) {
      offset++;
      const snLenInfo = parseDerLength(cert, offset);
      offset += snLenInfo.bytesUsed + snLenInfo.length;
    }
    
    // Skip signature algorithm
    if (cert[offset] === 0x30) {
      offset++;
      const algLenInfo = parseDerLength(cert, offset);
      offset += algLenInfo.bytesUsed + algLenInfo.length;
    }
    
    // Skip issuer
    if (cert[offset] === 0x30) {
      offset++;
      const issuerLenInfo = parseDerLength(cert, offset);
      offset += issuerLenInfo.bytesUsed + issuerLenInfo.length;
    }
    
    // Now at validity SEQUENCE
    if (cert[offset] !== 0x30) return { notBefore: null, notAfter: null };
    offset++;
    
    const valLenInfo = parseDerLength(cert, offset);
    offset += valLenInfo.bytesUsed;
    
    // Parse notBefore
    const notBefore = parseTime(cert, offset);
    offset++;
    const notBeforeLenInfo = parseDerLength(cert, offset);
    offset += notBeforeLenInfo.bytesUsed + notBeforeLenInfo.length;
    
    // Parse notAfter
    const notAfter = parseTime(cert, offset);
    
    return { notBefore, notAfter };
    
  } catch (err) {
    console.warn('Error extracting certificate validity:', err);
    return { notBefore: null, notAfter: null };
  }
}

// Verify COSE_Sign1 signature
async function verifyCoseSign1(coseSign1, publicKey) {
  try {
    console.log('=== VERIFYING COSE_Sign1 SIGNATURE ===');
    
    // COSE_Sign1 = [protected, unprotected, payload, signature]
    if (!Array.isArray(coseSign1) || coseSign1.length < 4) {
      throw new Error('Invalid COSE_Sign1 structure');
    }
    
    const [protectedHeader, unprotectedHeader, payload, signature] = coseSign1;
    
    console.log('Protected header length:', protectedHeader?.length || 0);
    console.log('Payload length:', payload?.length || 0);
    console.log('Signature length:', signature?.length || 0);
    
    // Convert protected header to Uint8Array if it's not already
    const protectedHeaderBytes = protectedHeader instanceof Uint8Array 
      ? protectedHeader 
      : new Uint8Array(protectedHeader);
    
    const payloadBytes = payload instanceof Uint8Array 
      ? payload 
      : new Uint8Array(payload);
      
    console.log('Protected header bytes:', hex(protectedHeaderBytes));
    console.log('Payload bytes (first 32):', hex(payloadBytes.slice(0, 32)));
    
    // Decode protected header to extract algorithm (may be overridden by key curve mapping per ISO 18013-5)
    let alg = -7; // Default to ES256
    let algName = 'ES256';
    let hashAlg = 'SHA-256';
    let expectedSigLength = 64; // r||s length in bytes
    let curve = 'P-256';

    // ISO 18013-5 mapping helper: curve ‚Üí (algName, hash, expectedSigLen)
    function specAlgFromCurve(nobleCurveName) {
      const name = (nobleCurveName || '').toLowerCase();
      // Defaults
      let out = { algName: 'ES256', hash: 'SHA-256', sigLen: 64, curveLabel: nobleCurveName };
      if (!name) return out;
      // ES256 curves
      if (name.includes('p256') || name.includes('brainpoolp256')) {
        return { algName: 'ES256', hash: 'SHA-256', sigLen: 64, curveLabel: name.includes('brainpool') ? 'brainpoolP256r1' : 'P-256' };
      }
      // ES384 curves
      if (name.includes('p384') || name.includes('brainpoolp384') || name.includes('brainpoolp320')) {
        // 384-bit ‚Üí 96 bytes; 320-bit ‚Üí 80 bytes
        const sigLen = name.includes('320') ? 80 : 96;
        const curveLabel = name.includes('brainpoolp320') ? 'brainpoolP320r1' : (name.includes('brainpool') ? 'brainpoolP384r1' : 'P-384');
        return { algName: 'ES384', hash: 'SHA-384', sigLen, curveLabel };
      }
      // ES512 curves
      if (name.includes('p521') || name.includes('brainpoolp512')) {
        // P-521 ‚Üí 66+66=132; brainpoolP512r1 ‚Üí 64+64=128
        const sigLen = name.includes('p521') ? 132 : 128;
        const curveLabel = name.includes('p521') ? 'P-521' : 'brainpoolP512r1';
        return { algName: 'ES512', hash: 'SHA-512', sigLen, curveLabel };
      }
      // EdDSA (if ever present)
      if (name.includes('ed25519') || name.includes('ed448')) {
        // Note: Current verifier path is ECDSA-only; EdDSA not supported here
        return { algName: 'EdDSA', hash: 'NONE', sigLen: 64, curveLabel: name.includes('ed448') ? 'Ed448' : 'Ed25519' };
      }
      return out;
    }
    
    try {
  const decodedHeader = CBOR.decode(protectedHeaderBytes);
      console.log('Decoded protected header:', decodedHeader);
      
      // Handle both Map and plain object
      if (decodedHeader instanceof Map) {
        alg = decodedHeader.get(1) || -7;
      } else if (typeof decodedHeader === 'object') {
        alg = decodedHeader[1] || -7;
      }
      
      // Set parameters based on protected header alg (initial)
      if (alg === -35) { // ES384
        algName = 'ES384';
        hashAlg = 'SHA-384';
        expectedSigLength = 96;
        curve = 'P-384';
      } else if (alg === -7) { // ES256
        algName = 'ES256';
        hashAlg = 'SHA-256';
        expectedSigLength = 64;
        curve = 'P-256';
      } else {
        console.warn('‚ö†Ô∏è Unknown algorithm label in protected header:', alg, '- defaulting to ES256');
      }

      // Override by spec mapping from actual key curve, if it differs
      const pkCurve = publicKey?.nobleCurveName || '';
      const mapped = specAlgFromCurve(pkCurve);
      if (mapped.algName !== algName || mapped.sigLen !== expectedSigLength) {
        console.warn(`‚ö†Ô∏è Protected alg suggests ${algName}, but key curve '${pkCurve}' maps to ${mapped.algName}. Adjusting.`);
        algName = mapped.algName;
        hashAlg = mapped.hash;
        expectedSigLength = mapped.sigLen;
        curve = mapped.curveLabel;
      }

      console.log(`Algorithm (effective): ${algName} (label ${alg}), Hash: ${hashAlg}, Curve: ${curve}, Expected Sig Len: ${expectedSigLength}`);
    } catch (e) {
      console.warn('Could not decode protected header, using default ES256:', e.message);
    }
    
    // Reconstruct Sig_structure per RFC 8152 Section 4.4
    // Sig_structure = [
    //   context : "Signature1",
    //   body_protected : bstr .cbor header_map,
    //   external_aad : bstr,
    //   payload : bstr
    // ]
    // 
    // CRITICAL: protectedHeaderBytes and payloadBytes are ALREADY CBOR-encoded,
    // so we need to manually build the array with them as bstr, not let CBOR.encode()
    // double-encode them.
    
    // Manually construct Sig_structure CBOR:
    // 84                    # array(4)
    //   6A 5369676E617475726531  # text(10) "Signature1"
    //   43 <protected bytes>      # bstr(3) - protected header (already CBOR)
    //   40                        # bstr(0) - empty AAD
    //   59 XXXX <payload bytes>   # bstr(length) - payload (already CBOR)
    
    function encodeBstr(bytes) {
      // CBOR byte string encoding
      const len = bytes.length;
      if (len <= 23) {
        return new Uint8Array([0x40 + len, ...bytes]);
      } else if (len <= 0xFF) {
        return new Uint8Array([0x58, len, ...bytes]);
      } else if (len <= 0xFFFF) {
        return new Uint8Array([0x59, len >> 8, len & 0xFF, ...bytes]);
      } else {
        throw new Error('Payload too large for this implementation');
      }
    }
    
    const sigStructureParts = [];
    
    // Array header: 84 (array of 4 elements)
    sigStructureParts.push(new Uint8Array([0x84]));
    
    // Element 1: "Signature1" as text string
    const contextStr = "Signature1";
    const contextBytes = new TextEncoder().encode(contextStr);
    sigStructureParts.push(new Uint8Array([0x6A, ...contextBytes])); // 0x6A = text(10)
    
    // Element 2: body_protected as bstr
    // protectedHeaderBytes is the serialized CBOR map (e.g., a1 01 26 for {1: -7})
    // For Sig_structure, we wrap it as a bstr
    console.log('DEBUG: protectedHeaderBytes for Sig_structure:', hex(protectedHeaderBytes));
    console.log('DEBUG: protectedHeaderBytes length:', protectedHeaderBytes.length);
    const encodedProtected = encodeBstr(protectedHeaderBytes);
    console.log('DEBUG: encoded protected (with bstr wrapper):', hex(encodedProtected));
    sigStructureParts.push(encodedProtected);
    
    // Element 3: external_aad as bstr (empty for COSE_Sign1)
    sigStructureParts.push(new Uint8Array([0x40])); // empty byte string
    
    // Element 4: payload as bstr
    sigStructureParts.push(encodeBstr(payloadBytes));
    
    // Concatenate all parts
    const totalLength = sigStructureParts.reduce((sum, part) => sum + part.length, 0);
    const sigStructureBytes = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of sigStructureParts) {
      sigStructureBytes.set(part, offset);
      offset += part.length;
    }
    
    console.log('Sig_structure CBOR (manual):', hex(sigStructureBytes));
    console.log('Sig_structure length:', sigStructureBytes.length);
    
    // Convert signature to the format expected by Web Crypto
    // COSE signature is raw r||s format
    // - ES256: 64 bytes (32-byte r + 32-byte s) for P-256
    // - ES384: 96 bytes (48-byte r + 48-byte s) for P-384
    // Web Crypto expects the same raw format for ECDSA
    const signatureBytes = new Uint8Array(signature);
    console.log('Signature bytes:', hex(signatureBytes));
    console.log(`Signature length: ${signatureBytes.length} bytes (expected ${expectedSigLength} for ${algName})`);
    
    if (signatureBytes.length !== expectedSigLength) {
      console.warn(`‚ö†Ô∏è Expected ${expectedSigLength}-byte signature for ${algName}, got`, signatureBytes.length);
    }
    
    // Use @noble/curves for all signature verification
    if (!publicKey || typeof publicKey !== 'object' || publicKey.type !== 'noble') {
      throw new Error('Invalid public key format - expected noble-curves key object');
    }
    
    if (!window.nobleCurves) {
      throw new Error('@noble/curves library not loaded');
    }
    
    const curveLib = window.nobleCurves[publicKey.nobleCurveName];
    if (!curveLib) {
      throw new Error(`Curve ${publicKey.nobleCurveName} not available in @noble/curves`);
    }
    
    console.log(`Using @noble/curves (${publicKey.nobleCurveName}) for signature verification`);
    
    console.log('üîç Verification inputs:');
    console.log('  Signature bytes:', hex(signatureBytes).substring(0, 64) + '...');
    console.log('  Message (Sig_structure):', hex(sigStructureBytes).substring(0, 64) + '...');
    console.log('  Public key (with 0x04 prefix):', hex(publicKey.key).substring(0, 66) + '...');
    console.log('  Curve library:', publicKey.nobleCurveName);
    
  // Verify using noble-curves
  let isValid = false;
    try {
      // @noble/curves verify signature:
      // verify(signature: Hex | Signature, message: Hex, publicKey: Hex)
      // IMPORTANT: Noble-curves hashes the message internally!
      // We pass the raw Sig_structure, NOT the hash
      // signature: Uint8Array (raw r||s)
      // message: the message to verify (noble will hash it)
      // publicKey: public key WITH 0x04 prefix (uncompressed point format)
      
      isValid = curveLib.verify(
        signatureBytes,
        sigStructureBytes, // Pass the MESSAGE, not the hash!
        publicKey.key // Keep 0x04 prefix - noble-curves expects full uncompressed point
      );
      
      console.log('‚úì Noble-curves verify() completed without error');
    } catch (verifyErr) {
      console.error('‚úó Noble-curves verification threw error:', verifyErr);
      console.error('  Error details:', {
        name: verifyErr.name,
        message: verifyErr.message,
        stack: verifyErr.stack?.substring(0, 200)
      });
      isValid = false;
    }
    
    // Low-S normalization fallback for ECDSA (some libs enforce canonical low-S)
    if (!isValid && (publicKey.nobleCurveName === 'p256' || publicKey.nobleCurveName === 'p384') &&
        (signatureBytes.length === 64 || signatureBytes.length === 96)) {
      try {
        const halfLen = signatureBytes.length / 2;
        const rBytes = signatureBytes.slice(0, halfLen);
        const sBytes = signatureBytes.slice(halfLen);
        const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
        const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
        let curveOrder = null;
        if (publicKey.nobleCurveName === 'p256') {
          curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
        } else if (publicKey.nobleCurveName === 'p384') {
          curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
        }
        if (curveOrder) {
          const half = curveOrder >> 1n;
          const sVal = bytesToBigIntBE(sBytes);
          if (sVal > half) {
            const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
            const sigNorm = new Uint8Array(signatureBytes.length);
            sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
            if (window.DEBUG_VERBOSE) console.log('Attempting low-S normalized verification for COSE_Sign1');
            try {
              isValid = curveLib.verify(sigNorm, sigStructureBytes, publicKey.key);
            } catch {}
          }
        }
      } catch {}
    }
    
  console.log('Signature verification result:', isValid);
    return isValid;
    
  } catch (err) {
    console.error('‚ùå Signature verification error:', err);
    throw err;
  }
}

// ===== CERTIFICATE CHAIN VALIDATION =====

/**
 * Parse X.509 certificate and extract signature and TBS (To Be Signed) portion
 * This is a simplified ASN.1 parser for basic certificate validation
 */
function parseX509Certificate(certBytes) {
  try {
    // X.509 Certificate structure (simplified):
    // Certificate ::= SEQUENCE {
    //   tbsCertificate       TBSCertificate,
    //   signatureAlgorithm   AlgorithmIdentifier,
    //   signatureValue       BIT STRING
    // }
    
    let pos = 0;
    
    // Read SEQUENCE tag
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected SEQUENCE');
    }
    
    // Read length (can be short or long form)
    let certLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      certLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        certLength = (certLength << 8) | certBytes[pos++];
      }
    } else {
      certLength = certBytes[pos++];
    }
    
    const certStart = pos;
    
    // TBSCertificate is the first SEQUENCE
    const tbsStart = pos;  // Save position BEFORE reading TBS SEQUENCE tag
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected TBSCertificate SEQUENCE');
    }
    
    // Read TBS length
    let tbsLength;
    const tbsLengthStart = pos;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      tbsLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        tbsLength = (tbsLength << 8) | certBytes[pos++];
      }
    } else {
      tbsLength = certBytes[pos++];
    }
    
    // TBSCertificate includes the SEQUENCE tag and length
    const tbsEnd = pos + tbsLength;
    const tbsCertificate = certBytes.slice(tbsStart, tbsEnd);
    
    // Skip to signature
    pos = tbsEnd;
    
    // Skip signatureAlgorithm SEQUENCE
    if (certBytes[pos++] !== 0x30) {
      throw new Error('Invalid certificate: Expected signatureAlgorithm SEQUENCE');
    }
    let sigAlgLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      sigAlgLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        sigAlgLength = (sigAlgLength << 8) | certBytes[pos++];
      }
    } else {
      sigAlgLength = certBytes[pos++];
    }
    pos += sigAlgLength;
    
    // Read signature BIT STRING
    if (certBytes[pos++] !== 0x03) {
      throw new Error('Invalid certificate: Expected signature BIT STRING');
    }
    let sigLength;
    if (certBytes[pos] & 0x80) {
      const numLengthBytes = certBytes[pos++] & 0x7f;
      sigLength = 0;
      for (let i = 0; i < numLengthBytes; i++) {
        sigLength = (sigLength << 8) | certBytes[pos++];
      }
    } else {
      sigLength = certBytes[pos++];
    }
    
    // Skip the number of unused bits (first byte of BIT STRING)
    const unusedBits = certBytes[pos++];
    sigLength -= 1; // Subtract the unused bits byte
    
    const signature = certBytes.slice(pos, pos + sigLength);
    
    console.log('üîç [X.509 Signature Extraction DEBUG]:');
    console.log('  Signature from BIT STRING (first 16 bytes):', Array.from(signature.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
    console.log('  Signature length:', signature.length);
    console.log('  First byte:', '0x' + signature[0].toString(16).padStart(2, '0'), signature[0] === 0x30 ? '(DER SEQUENCE ‚úì)' : '(NOT DER SEQUENCE!)');
    
    // For ECDSA, signature is DER-encoded, need to convert to raw r||s format
    const rawSignature = convertDERSignatureToRaw(signature);
    
    console.log('  After convertDERSignatureToRaw():');
    console.log('  Raw signature (first 16 bytes):', Array.from(rawSignature.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
    console.log('  Raw signature length:', rawSignature.length);
    
    return {
      tbsCertificate,
      signature: rawSignature,
      signatureDER: signature
    };
  } catch (e) {
    console.error('Failed to parse X.509 certificate:', e);
    return null;
  }
}

/**
 * Convert DER-encoded ECDSA signature to raw r||s format
 * Supports both P-256 (32-byte r/s) and P-384 (48-byte r/s)
 */
function convertDERSignatureToRaw(derSig) {
  try {
    // DER signature: SEQUENCE { r INTEGER, s INTEGER }
    let pos = 0;
    
    console.log(`üîç [DER to Raw Conversion]`);
    console.log(`   Input DER (first 32 bytes): ${hex(derSig.slice(0, Math.min(32, derSig.length)))}`);
    
    if (derSig[pos++] !== 0x30) {
      throw new Error('Invalid DER signature: Expected SEQUENCE');
    }
    
    let seqLength;
    if (derSig[pos] & 0x80) {
      const numBytes = derSig[pos++] & 0x7f;
      seqLength = 0;
      for (let i = 0; i < numBytes; i++) {
        seqLength = (seqLength << 8) | derSig[pos++];
      }
    } else {
      seqLength = derSig[pos++];
    }
    
    console.log(`   SEQUENCE length: ${seqLength}`);
    
    // Read r
    if (derSig[pos++] !== 0x02) {
      throw new Error('Invalid DER signature: Expected INTEGER for r');
    }
    let rLength = derSig[pos++];
    console.log(`   r length: ${rLength}`);
    let r = derSig.slice(pos, pos + rLength);
    console.log(`   r raw (with potential padding): ${hex(r)}`);
    pos += rLength;
    
    // Remove leading zero if present (DER encoding adds it for positive numbers with high bit set)
    if (r[0] === 0x00 && r.length > 1) {
      r = r.slice(1);
      console.log(`   r after removing 0x00 padding: ${hex(r)}`);
    }
    
    // Read s
    if (derSig[pos++] !== 0x02) {
      throw new Error('Invalid DER signature: Expected INTEGER for s');
    }
    let sLength = derSig[pos++];
    console.log(`   s length: ${sLength}`);
    let s = derSig.slice(pos, pos + sLength);
    console.log(`   s raw (with potential padding): ${hex(s)}`);
    
    // Remove leading zero if present
    if (s[0] === 0x00 && s.length > 1) {
      s = s.slice(1);
      console.log(`   s after removing 0x00 padding: ${hex(s)}`);
    }
    
    // Determine curve based on component size
    // P-256: 32 bytes, P-384: 48 bytes
    const componentSize = Math.max(r.length, s.length) <= 32 ? 32 : 48;
    
    // Pad to correct size (32 bytes for P-256, 48 bytes for P-384)
    const rPadded = new Uint8Array(componentSize);
    const sPadded = new Uint8Array(componentSize);
    
    if (r.length <= componentSize) {
      rPadded.set(r, componentSize - r.length);
    } else {
      rPadded.set(r.slice(r.length - componentSize), 0);
    }
    
    if (s.length <= componentSize) {
      sPadded.set(s, componentSize - s.length);
    } else {
      sPadded.set(s.slice(s.length - componentSize), 0);
    }
    
    // Concatenate r || s (64 bytes for P-256, 96 bytes for P-384)
    const rawSig = new Uint8Array(componentSize * 2);
    rawSig.set(rPadded, 0);
    rawSig.set(sPadded, componentSize);
    
    return rawSig;
  } catch (e) {
    console.error('Failed to convert DER signature:', e);
    return derSig; // Return as-is if conversion fails
  }
}

/**
 * Extract Authority Key Identifier (AKI) from X.509 certificate
 * AKI is in extensions and identifies the public key of the CA that signed this cert
 * OID: 2.5.29.15 (0x55 0x1d 0x23)
 * 
 * @param {Uint8Array} certBytes - The certificate bytes
 * @returns {string|null} Hex string of the key identifier, or null if not found
 */
function extractAuthorityKeyIdentifier(certBytes) {
  try {
    // Extensions are in TBSCertificate at the end
    // Structure: TBSCertificate SEQUENCE {
    //   version, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo,
    //   [3] EXPLICIT Extensions OPTIONAL
    // }
    
    const hex = Array.from(certBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Look for Authority Key Identifier OID: 55 1d 23
    // Typically in format: SEQUENCE { OID, OCTET STRING { [0] keyIdentifier } }
    const akiOidPattern = '551d23';
    const akiIndex = hex.indexOf(akiOidPattern);
    
    if (akiIndex === -1) {
      return null;
    }
    
    // After OID, there's usually an OCTET STRING (04), then inside that another [0] tag (80)
    // Extract the key identifier which is typically 20 bytes (40 hex chars)
    const afterOid = hex.substring(akiIndex + akiOidPattern.length);
    
    // Look for context tag [0] (0x80) followed by length 14 (0x14 = 20 bytes)
    const keyIdMatch = afterOid.match(/8014([0-9a-f]{40})/);
    
    if (keyIdMatch) {
      return keyIdMatch[1];
    }
    
    return null;
  } catch (e) {
    console.error('Failed to extract AKI:', e);
    return null;
  }
}

/**
 * Extract Subject Key Identifier (SKI) from X.509 certificate
 * SKI identifies the public key in this certificate
 * OID: 2.5.29.14 (0x55 0x1d 0x0e)
 * 
 * @param {Uint8Array} certBytes - The certificate bytes
 * @returns {string|null} Hex string of the key identifier, or null if not found
 */
function extractSubjectKeyIdentifier(certBytes) {
  try {
    const hex = Array.from(certBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Look for Subject Key Identifier OID: 55 1d 0e
    const skiOidPattern = '551d0e';
    const skiIndex = hex.indexOf(skiOidPattern);
    
    if (skiIndex === -1) {
      return null;
    }
    
    // After OID, there's an OCTET STRING (04) containing another OCTET STRING (04) with the key ID
    // Format: 04 <length> 04 14 <20 bytes>
    const afterOid = hex.substring(skiIndex + skiOidPattern.length);
    
    // Look for OCTET STRING tag (04) followed by length 14 (20 bytes)
    const keyIdMatch = afterOid.match(/0414([0-9a-f]{40})/);
    
    if (keyIdMatch) {
      return keyIdMatch[1];
    }
    
    return null;
  } catch (e) {
    console.error('Failed to extract SKI:', e);
    return null;
  }
}

/**
 * Validate that the mDoc issuer certificate is signed by one of our IACA root certificates
 * This establishes the trust chain: mDoc data ‚Üí Issuer Certificate ‚Üí IACA Root
 * Uses Authority Key Identifier (AKI) to match the correct IACA certificate
 * 
 * @param {Uint8Array} issuerCertBytes - The issuer certificate from the mDoc's COSE signature header
 * @returns {Object} Validation result with { valid, matchedIACA, chain, errors }
 */
async function validateCertificateChain(issuerCertBytes) {
  const result = {
    valid: false,
    matchedIACA: null,
    chain: [],
    errors: []
  };
  const DEBUG_VERBOSE = (typeof window !== 'undefined' && window.DEBUG_VERBOSE === true);
  
  try {
    console.log('=== VALIDATING ISSUER CERTIFICATE AGAINST IACA ROOTS ===');
    
    // Get active IACAs
    const activeIACAs = getActiveIACAs();
    
    if (activeIACAs.length === 0) {
      result.errors.push('No active IACA certificates available for validation');
      return result;
    }
    
    console.log(`Testing issuer certificate against ${activeIACAs.length} active IACA(s)`);
    
    // Parse the issuer certificate to extract signature and TBS
  if (DEBUG_VERBOSE) console.log('Parsing issuer certificate...');
    const parsedCert = parseX509Certificate(issuerCertBytes);
    
    if (!parsedCert) {
      result.errors.push('Failed to parse issuer certificate (invalid X.509 format)');
      return result;
    }
    
    console.log('‚úì Parsed issuer certificate');
  if (DEBUG_VERBOSE) {
      console.log('  TBS length:', parsedCert.tbsCertificate.length, 'bytes');
      console.log('  Signature length:', parsedCert.signature.length, 'bytes');
    }
    
    // Parse Certificate.signatureAlgorithm OID to select the correct hash (e.g., SHA-384)
    function parseCertSignatureAlgorithmOID(certBytes) {
      try {
        let pos = 0;
        if (certBytes[pos++] !== 0x30) return null; // Certificate SEQUENCE
        // Certificate length
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          for (let i = 0; i < n; i++) pos++;
        } else {
          pos++; // short form length
        }
        // TBSCertificate SEQUENCE
        if (certBytes[pos++] !== 0x30) return null;
        // TBS length
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          let tbsLen = 0; for (let i = 0; i < n; i++) tbsLen = (tbsLen << 8) | certBytes[pos++];
          pos += tbsLen;
        } else {
          const tbsLen = certBytes[pos++];
          pos += tbsLen;
        }
        // signatureAlgorithm SEQUENCE
        if (certBytes[pos++] !== 0x30) return null;
        // sigAlg length
        let sigAlgLen = 0;
        if (certBytes[pos] & 0x80) {
          const n = certBytes[pos++] & 0x7f;
          for (let i = 0; i < n; i++) sigAlgLen = (sigAlgLen << 8) | certBytes[pos++];
        } else {
          sigAlgLen = certBytes[pos++];
        }
        const sigAlgEnd = pos + sigAlgLen;
        // Inside AlgorithmIdentifier: OID (06 len value) [parameters may be absent]
        if (certBytes[pos++] !== 0x06) return null;
        let oidLen = certBytes[pos++];
        const oidBytes = certBytes.slice(pos, pos + oidLen);
        // Convert OID bytes to dot string for logging
        function decodeOID(bytes) {
          if (!bytes || bytes.length === 0) return '';
          const out = [];
          const first = bytes[0];
          out.push(Math.floor(first / 40));
          out.push(first % 40);
          let value = 0;
          for (let i = 1; i < bytes.length; i++) {
            const b = bytes[i];
            value = (value << 7) | (b & 0x7f);
            if ((b & 0x80) === 0) { out.push(value); value = 0; }
          }
          return out.join('.');
        }
        const oidStr = decodeOID(oidBytes);
        return { oidStr, oidBytes: new Uint8Array(oidBytes) };
      } catch (e) {
        console.warn('Failed to parse signatureAlgorithm OID:', e.message);
        return null;
      }
    }
    const sigAlg = parseCertSignatureAlgorithmOID(issuerCertBytes);
    if (sigAlg) {
      console.log(`  Signature Algorithm: ${sigAlg.oidStr}`);
  if (DEBUG_VERBOSE) console.log(`  OID hex: ${hex(sigAlg.oidBytes)}`);
    } else {
      console.log('  Signature Algorithm OID: unavailable');
    }
    
    // Extract Authority Key Identifier (AKI) from DS certificate
    const aki = extractAuthorityKeyIdentifier(issuerCertBytes);
    console.log('  Authority Key Identifier (AKI):', aki || 'not found');
    
    // Choose hash from OID (don‚Äôt guess from signature size)
    // 1.2.840.10045.4.3.1 = ecdsa-with-SHA224
    // 1.2.840.10045.4.3.2 = ecdsa-with-SHA256
    // 1.2.840.10045.4.3.3 = ecdsa-with-SHA384
    // 1.2.840.10045.4.3.4 = ecdsa-with-SHA512
    const certSigLength = parsedCert.signature.length;
    const hashFromOID = sigAlg?.oidStr === '1.2.840.10045.4.3.1' ? 'SHA-224'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.2' ? 'SHA-256'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.3' ? 'SHA-384'
      : sigAlg?.oidStr === '1.2.840.10045.4.3.4' ? 'SHA-512'
      : 'SHA-256';
    const algName = hashFromOID.replace('SHA-', 'ES');
  console.log(`  Using hash: ${hashFromOID}`);
  if (DEBUG_VERBOSE) console.log(`  Certificate signature length: ${certSigLength} bytes`);
    
    // Map signature length to expected curves
    const expectedCurves = certSigLength === 96 
      ? ['p384', 'brainpoolP384r1']  // 96-byte signature = P-384 or Brainpool P-384
      : ['p256', 'brainpoolP256r1'];  // 64-byte signature = P-256 or Brainpool P-256
    
    console.log(`  Expected IACA curves: ${expectedCurves.join(', ')}`);

    // (UI cert debug removed) ‚Äì keep console logs only
    
    // If AKI is available, use it to find the matching IACA by SKI
    let matchingIACAs = activeIACAs;
    
    if (aki) {
      console.log(`üîç Searching for IACA with matching SKI...`);
      const iacasWithSKI = [];
      
      for (const iaca of activeIACAs) {
        try {
          // Decode PEM to bytes
          const b64 = iaca.pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                             .replace(/-----END CERTIFICATE-----/, '')
                             .replace(/\s+/g, '');
          const binaryString = atob(b64);
          const iacaBytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            iacaBytes[i] = binaryString.charCodeAt(i);
          }
          
          const ski = extractSubjectKeyIdentifier(iacaBytes);
          
          if (ski) {
            console.log(`  ${iaca.name}: SKI = ${ski}`);
            if (ski.toLowerCase() === aki.toLowerCase()) {
              console.log(`  ‚úÖ MATCH! This IACA signed the DS certificate`);
              iacasWithSKI.push(iaca);
            }
          } else {
            console.log(`  ${iaca.name}: No SKI found`);
          }
        } catch (e) {
          console.warn(`  ${iaca.name}: Error extracting SKI:`, e.message);
        }
      }
      
      if (iacasWithSKI.length > 0) {
        matchingIACAs = iacasWithSKI;
        console.log(`‚úì Found ${matchingIACAs.length} IACA(s) with matching SKI`);
      } else {
        console.warn('‚ö†Ô∏è No IACA found with matching SKI, will try all IACAs');
      }
    }
    
    // Test the matching IACA(s)
    for (const iaca of matchingIACAs) {
      console.log(`Testing IACA: ${iaca.name}${matchingIACAs.length === 1 ? ' (matched by AKI/SKI)' : ''}`);
      
      try {
        // Decode IACA PEM to bytes for self-verification test
        const iacaB64 = iaca.pem.replace(/-----BEGIN CERTIFICATE-----/, '')
                                 .replace(/-----END CERTIFICATE-----/, '')
                                 .replace(/\s+/g, '');
        const iacaBinaryString = atob(iacaB64);
        const iacaCertBytes = new Uint8Array(iacaBinaryString.length);
        for (let i = 0; i < iacaBinaryString.length; i++) {
          iacaCertBytes[i] = iacaBinaryString.charCodeAt(i);
        }
        
        // Extract IACA public key from PEM
        const iacaPublicKey = await pemToCryptoKey(iaca.pem);
        
        if (!iacaPublicKey) {
          console.log(`  ‚úó Failed to import IACA public key (missing or invalid certificate)`);
          result.errors.push(`${iaca.name}: IACA certificate missing or invalid`);
          continue;
        }
        
        console.log(`  ‚úì Imported IACA public key (curve: ${iacaPublicKey.nobleCurveName})`);
        // (UI cert debug removed)
        
        // Use @noble/curves for all verification
        if (!iacaPublicKey || iacaPublicKey.type !== 'noble') {
          console.log('  ‚úó Invalid IACA public key format');
          result.errors.push(`${iaca.name}: Invalid key format`);
          continue;
        }
        
        // Check if IACA curve matches certificate signature length
        if (!expectedCurves.includes(iacaPublicKey.nobleCurveName)) {
          console.log(`  ‚äò Skipping: IACA curve ${iacaPublicKey.nobleCurveName} incompatible with ${algName} signature (${certSigLength} bytes)`);
          continue; // Skip incompatible curves without logging as error
        }
        
        if (!window.nobleCurves) {
          console.log('  ‚úó @noble/curves library not loaded');
          result.errors.push(`${iaca.name}: Crypto library not available`);
          continue;
        }
        
        const curveLib = window.nobleCurves[iacaPublicKey.nobleCurveName];
        if (!curveLib) {
          console.log(`  ‚úó Curve ${iacaPublicKey.nobleCurveName} not available`);
          result.errors.push(`${iaca.name}: Curve ${iacaPublicKey.nobleCurveName} not supported`);
          continue;
        }
        
  if (DEBUG_VERBOSE) console.log(`  Using @noble/curves (${iacaPublicKey.nobleCurveName}) for certificate verification`);
        
        // CRITICAL: X.509 certificates contain ECDSA signatures over the HASH of the TBS certificate
        // Noble-curves verify() expects a MESSAGE (which it will hash internally)
        // But X.509 already has the hash, so we need to convert it to look like the "message"
        // that would produce that hash when hashed by noble-curves
        
        // Actually, the proper way is to NOT hash the TBS certificate ourselves
        // Instead, pass the RAW TBS bytes to verify() and let noble-curves hash it
        // This is different from COSE_Sign1 because:
        // - COSE_Sign1: Signs the raw Sig_structure ‚Üí pass raw bytes ‚Üí noble hashes ‚Üí works ‚úì
        // - X.509: Signs the raw TBS ‚Üí pass raw bytes ‚Üí noble hashes ‚Üí should work ‚úì
        
  if (DEBUG_VERBOSE) {
          console.log(`  TBS certificate length: ${parsedCert.tbsCertificate.length} bytes`);
          console.log(`  TBS hex (first 64 bytes):`, hex(parsedCert.tbsCertificate.slice(0, 64)));
          console.log(`  TBS hex (last 32 bytes):`, hex(parsedCert.tbsCertificate.slice(-32)));
        }
        
        // DIAGNOSTIC: Verify TBS extraction is correct
  if (DEBUG_VERBOSE) console.log(`  üîç Diagnostic: Verifying TBS structure...`);
  if (DEBUG_VERBOSE) console.log(`     First byte: 0x${parsedCert.tbsCertificate[0].toString(16)} (should be 0x30 = SEQUENCE)`);
  if (DEBUG_VERBOSE) console.log(`     Second byte: 0x${parsedCert.tbsCertificate[1].toString(16)} (length indicator)`);
        if (parsedCert.tbsCertificate[1] === 0x82) {
          const tbsLengthFromTag = (parsedCert.tbsCertificate[2] << 8) | parsedCert.tbsCertificate[3];
          if (DEBUG_VERBOSE) console.log(`     TBS length from tag: ${tbsLengthFromTag} (should be ${parsedCert.tbsCertificate.length - 4})`);
          if (tbsLengthFromTag + 4 === parsedCert.tbsCertificate.length) {
            if (DEBUG_VERBOSE) console.log(`     ‚úì TBS length is correct`);
          } else {
            console.log(`     ‚úó TBS length mismatch! Expected ${tbsLengthFromTag + 4}, got ${parsedCert.tbsCertificate.length}`);
          }
        }
        
  if (DEBUG_VERBOSE) {
          console.log(`  Certificate signature (raw r||s):`, hex(parsedCert.signature));
          console.log(`  Certificate signature length: ${parsedCert.signature.length} bytes`);
          console.log(`  IACA public key (with 0x04 prefix):`, hex(iacaPublicKey.key));
          console.log(`  IACA public key length: ${iacaPublicKey.key.length} bytes`);
          console.log(`  IACA X coordinate:`, hex(iacaPublicKey.key.slice(1, 33)));
          console.log(`  IACA Y coordinate:`, hex(iacaPublicKey.key.slice(33, 65)));
        }
        console.log(`  Attempting verification`);
        
        // Debug: Compute chosen hash manually
        let preHash = null;
        try {
          const h = await crypto.subtle.digest(hashFromOID, parsedCert.tbsCertificate);
          preHash = new Uint8Array(h);
          if (DEBUG_VERBOSE) console.log(`  üìä ${hashFromOID}(TBS) computed`);
        } catch (e) {
          console.log(`  ‚ö†Ô∏è Unable to compute ${hashFromOID} digest: ${e.message}`);
        }
        
        // Verify signature using noble-curves
        // Pass the RAW TBS certificate bytes (not pre-hashed)
  let isValid = false;
  let lowSUsed = false;
        try {
          if (DEBUG_VERBOSE) {
            console.log(`  üî¨ Calling ${iacaPublicKey.nobleCurveName}.verify()...`);
            console.log(`     - signature length: ${parsedCert.signature.length}`);
            console.log(`     - message length: ${parsedCert.tbsCertificate.length}`);
            console.log(`     - publicKey length: ${iacaPublicKey.key.length}`);
          }
          
          // DIAGNOSTIC: Verify the public key looks structurally correct
          if (DEBUG_VERBOSE) console.log(`  üîç Diagnostic: Verifying IACA public key is valid...`);
          try {
            if (curveLib.ProjectivePoint && typeof curveLib.ProjectivePoint.fromHex === 'function') {
              const _ = curveLib.ProjectivePoint.fromHex(iacaPublicKey.key);
              if (DEBUG_VERBOSE) console.log(`     ‚úì Public key is a valid point on ${iacaPublicKey.nobleCurveName}`);
            } else {
              if (DEBUG_VERBOSE) console.log(`     (Skipping ProjectivePoint check: API not available)`);
            }
          } catch (pointErr) {
            console.log(`     ‚úó Public key is NOT a valid point: ${pointErr.message}`);
          }
          
          // DIAGNOSTIC: Let's check the signature format
          if (DEBUG_VERBOSE) {
            console.log(`  üîç Diagnostic: Checking signature format...`);
            const halfLen = parsedCert.signature.length/2;
            const r = parsedCert.signature.slice(0, halfLen);
            const s = parsedCert.signature.slice(halfLen);
            console.log(`     r first byte: 0x${r[0].toString(16)}`);
            console.log(`     s first byte: 0x${s[0].toString(16)}`);
            if (r[0] === 0x00) {
              console.log(`     ‚ö†Ô∏è WARNING: r has leading zero - might be padding issue`);
            }
            if (s[0] === 0x00) {
              console.log(`     ‚ö†Ô∏è WARNING: s has leading zero - might be padding issue`);
            }
          }
          
          
          // Streamlined verification order
          // 1) OID pre-hash
          if (preHash) {
            if (DEBUG_VERBOSE) console.log(`  üß™ Verify: signature vs ${hashFromOID}(TBS)`);
            isValid = curveLib.verify(parsedCert.signature, preHash, iacaPublicKey.key);
          }
          
          // 2) low-S normalization with pre-hash
          if (!isValid && preHash) {
            try {
              let curveOrder = curveLib?.CURVE?.n;
              if (!curveOrder) {
                if (iacaPublicKey.nobleCurveName === 'p256') {
                  curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                } else if (iacaPublicKey.nobleCurveName === 'p384') {
                  curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
                }
              }
              if (curveOrder) {
                const half = curveOrder >> 1n;
                const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
                const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
                const halfLen = parsedCert.signature.length / 2;
                const rBytes = parsedCert.signature.slice(0, halfLen);
                const sBytes = parsedCert.signature.slice(halfLen);
                const sVal = bytesToBigIntBE(sBytes);
                if (sVal > half) {
                  lowSUsed = true;
                  const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
                  const sigNorm = new Uint8Array(parsedCert.signature.length);
                  sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
                  if (DEBUG_VERBOSE) console.log(`  üß™ Verify: low-S signature vs ${hashFromOID}(TBS)`);
                  isValid = curveLib.verify(sigNorm, preHash, iacaPublicKey.key);
                }
              }
            } catch {}
          }

          // 3) RAW TBS (library hashes internally)
          if (!isValid) {
            try {
              if (DEBUG_VERBOSE) console.log(`  üß™ Verify: signature vs RAW_TBS`);
              isValid = curveLib.verify(parsedCert.signature, parsedCert.tbsCertificate, iacaPublicKey.key);
            } catch (e) {
              if (DEBUG_VERBOSE) console.log(`     verify threw: ${e.message}`);
            }
          }

          // 4) RAW TBS with low-S
          if (!isValid) {
            try {
              let curveOrder = curveLib?.CURVE?.n;
              if (!curveOrder) {
                if (iacaPublicKey.nobleCurveName === 'p256') {
                  curveOrder = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
                } else if (iacaPublicKey.nobleCurveName === 'p384') {
                  curveOrder = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973');
                }
              }
              if (curveOrder) {
                const half = curveOrder >> 1n;
                const bytesToBigIntBE = (arr) => arr.reduce((n,b)=> (n<<8n) | BigInt(b), 0n);
                const bigIntToBytesBE = (num, len) => { const out = new Uint8Array(len); let n = num; for (let i=len-1;i>=0;i--){out[i]=Number(n&0xffn); n>>=8n;} return out; };
                const halfLen = parsedCert.signature.length / 2;
                const rBytes = parsedCert.signature.slice(0, halfLen);
                const sBytes = parsedCert.signature.slice(halfLen);
                const sVal = bytesToBigIntBE(sBytes);
                if (sVal > half) {
                  lowSUsed = true;
                  const sNorm = bigIntToBytesBE(curveOrder - sVal, sBytes.length);
                  const sigNorm = new Uint8Array(parsedCert.signature.length);
                  sigNorm.set(rBytes, 0); sigNorm.set(sNorm, rBytes.length);
                  if (DEBUG_VERBOSE) console.log(`  üß™ Verify: low-S signature vs RAW_TBS`);
                  isValid = curveLib.verify(sigNorm, parsedCert.tbsCertificate, iacaPublicKey.key);
                }
              }
            } catch {}
          }

          // Deep diagnostics behind verbose flag
          if (!isValid && DEBUG_VERBOSE) {
            try {
              console.log(`  üß™ Attempt E: verify(signature_DER, RAW_TBS, publicKey)`);
              const res = curveLib.verify(
                parsedCert.signatureDER,
                parsedCert.tbsCertificate,
                iacaPublicKey.key
              );
              console.log(`     Result: ${res}`);
              isValid = res;
            } catch (e) {
              console.log(`     Attempt E threw: ${e.message}`);
            }
          }

          if (!isValid && DEBUG_VERBOSE) {
            try {
              console.log(`  üß™ Attempt F: verify(signature_DER, ${hashFromOID}(TBS), publicKey)`);
              const preHashBuf = await crypto.subtle.digest(hashFromOID, parsedCert.tbsCertificate);
              const preHash = new Uint8Array(preHashBuf);
              const res = curveLib.verify(
                parsedCert.signatureDER,
                preHash,
                iacaPublicKey.key
              );
              console.log(`     Result: ${res}`);
              isValid = res;
            } catch (e) {
              console.log(`     Attempt F threw: ${e.message}`);
            }
          }

          if (!isValid && DEBUG_VERBOSE && window.crypto?.subtle) {
            try {
              console.log(`  üß™ Attempt G: WebCrypto.verify(ECDSA, ${hashFromOID})`);
              const namedCurve = iacaPublicKey.nobleCurveName === 'p256' ? 'P-256'
                : iacaPublicKey.nobleCurveName === 'p384' ? 'P-384'
                : null;
              if (namedCurve) {
                const wcKey = await crypto.subtle.importKey(
                  'raw',
                  iacaPublicKey.key,
                  { name: 'ECDSA', namedCurve },
                  false,
                  ['verify']
                );
                const ok = await crypto.subtle.verify(
                  { name: 'ECDSA', hash: { name: hashFromOID } },
                  wcKey,
                  parsedCert.signatureDER,
                  parsedCert.tbsCertificate
                );
                console.log(`     WebCrypto verify result: ${ok}`);
                isValid = ok;
              } else {
                console.log(`     (Skipping Attempt G: unsupported curve ${iacaPublicKey.nobleCurveName})`);
              }
            } catch (e) {
              console.log(`     Attempt G threw: ${e.message}`);
            }
          }
          
          // If still failing, optionally do DS/IACA sanity checks (verbose only)
          if (!isValid && DEBUG_VERBOSE) {
            console.log(`  üß™ Attempt 3: Sanity check - re-verify DS certificate COSE_Sign1`);
            console.log(`     (This should succeed since it worked earlier)`);
            
            // We know the DS certificate public key verified successfully
            // Let's extract it properly (skip the 04 prefix at offset 382)
            console.log(`     DS cert byte at 382: 0x${issuerCertBytes[382].toString(16)} (should be 0x04)`);
            console.log(`     DS cert public key X: ${hex(issuerCertBytes.slice(383, 383+32))}`);
            console.log(`     DS cert public key Y: ${hex(issuerCertBytes.slice(383+32, 383+64))}`);
            
            // Compare with what we extracted earlier during COSE_Sign1 verification
            console.log(`     Previously verified: COSE_Sign1 with DS cert public key = WORKS ‚úì`);
            console.log(`     Now failing: X.509 cert with IACA public key = FAILS ‚úó`);
            console.log(`     But wait - let's check if the issue is with IACA cert or DS cert...`);
            
            // Ultimate test: Verify the IACA certificate itself (should be self-signed)
            console.log(`  üß™ Attempt 4: Verify IACA is self-signed (sanity check)`);
            try {
              // Parse the IACA certificate
              const iacaParsed = parseX509Certificate(iacaCertBytes);
              if (iacaParsed) {
                console.log(`     IACA TBS length: ${iacaParsed.tbsCertificate.length}`);
                console.log(`     IACA signature length: ${iacaParsed.signature.length}`);
                
                // Verify IACA cert with its own public key (self-signed)
                const iacaSelfVerify = curveLib.verify(
                  iacaParsed.signature,
                  iacaParsed.tbsCertificate,
                  iacaPublicKey.key
                );
                console.log(`     IACA self-signed verification: ${iacaSelfVerify}`);
                
                if (iacaSelfVerify) {
                  console.log(`     ‚úì IACA is properly self-signed!`);
                  console.log(`     This means the IACA public key is correct.`);
                  console.log(`     Therefore, the DS certificate signature or TBS must be wrong.`);
                } else {
                  console.log(`     ‚úó IACA self-signed verification failed!`);
                  console.log(`     This could mean:`);
                  console.log(`       1. IACA public key extraction is wrong`);
                  console.log(`       2. Our signature/TBS extraction is fundamentally broken`);
                  console.log(`       3. noble-curves verification has an issue`);
                }
              }
            } catch (iacaErr) {
              console.log(`     Error verifying IACA: ${iacaErr.message}`);
            }
          }
          
          console.log(`  ‚úÖ Certificate verify result: ${isValid}`);
          // (UI cert debug removed)
        } catch (verifyErr) {
          console.log(`  ‚úó verify() threw error: ${verifyErr.message}`);
          console.error(verifyErr);
          isValid = false;
        }
        
        if (isValid) {
          console.log(`  ‚úÖ Issuer certificate is signed by this IACA!`);
          
          result.valid = true;
          result.matchedIACA = {
            name: iaca.name,
            issuer: iaca.issuer,
            test: iaca.test || false  // Include test flag
          };
          result.chain = [
            'mDoc Issuer Certificate',
            `‚Üì signed by`,
            `IACA Root: ${iaca.name}${iaca.test ? ' (TEST)' : ''}`
          ];
          // (UI cert debug removed)
          
          console.log(`‚úÖ Issuer certificate validated with IACA: ${iaca.name}${iaca.test ? ' (TEST)' : ''}`);
          return result;
        } else {
          console.log(`  ‚úó Signature does not match this IACA`);
        }
        
      } catch (e) {
        console.log(`  ‚úó Verification failed with this IACA:`, e.message);
        result.errors.push(`${iaca.name}: ${e.message}`);
      }
    }
    
    // No IACA matched
    if (!result.valid) {
      result.errors.push('Issuer certificate is not signed by any active IACA root certificate');
    }
    
  } catch (err) {
    console.error('Issuer certificate validation error:', err);
    result.errors.push(`Validation error: ${err.message}`);
  }
  
  return result;
}

/**
 * Enhanced signature verification with issuer certificate validation
 * Verifies the COSE signature and validates that the issuer certificate is signed by an IACA
 */
async function verifyCOSESign1SignatureWithChain(coseSign1) {
  const result = {
    signatureValid: false,
    chainValid: false,
    chainInfo: null,
    errors: []
  };
  
  try {
    // Step 1: Extract issuer certificate from unprotected header (COSE header parameter 33)
    console.log('Step 1: Extracting issuer certificate from x5chain...');
    
    const unprotectedHeader = coseSign1[1] || {};
    console.log('Unprotected header:', unprotectedHeader);
    console.log('Unprotected header type:', Object.prototype.toString.call(unprotectedHeader));
    
    // Handle both Map and plain object
    // COSE header parameter 33 (x5chain) contains the issuer certificate
    let issuerCert;
    if (unprotectedHeader instanceof Map) {
      console.log('Unprotected header is a Map');
      issuerCert = unprotectedHeader.get(33);
      console.log('Issuer cert from Map.get(33):', issuerCert);
    } else {
      console.log('Unprotected header is a plain object');
      issuerCert = unprotectedHeader[33];
      console.log('Issuer cert from object[33]:', issuerCert);
    }
    
    if (!issuerCert) {
      result.errors.push('No issuer certificate (x5chain) found in signature header');
      console.warn('‚ö†Ô∏è No x5chain (issuer certificate) found in unprotected header');
      console.log('Available header keys:', unprotectedHeader instanceof Map ? 
        Array.from(unprotectedHeader.keys()) : Object.keys(unprotectedHeader));
      return result;
    }
    
    // Convert to Uint8Array if needed
    let issuerCertBytes;
    if (issuerCert instanceof Uint8Array) {
      issuerCertBytes = issuerCert;
    } else if (ArrayBuffer.isView(issuerCert)) {
      issuerCertBytes = new Uint8Array(issuerCert.buffer, issuerCert.byteOffset, issuerCert.byteLength);
    } else if (issuerCert instanceof ArrayBuffer) {
      issuerCertBytes = new Uint8Array(issuerCert);
    } else {
      result.errors.push('Issuer certificate format not recognized');
      console.error('Issuer certificate is not a Uint8Array or ArrayBuffer:', typeof issuerCert);
      return result;
    }
    
    console.log('Issuer certificate size:', issuerCertBytes.length, 'bytes');
    
    // Step 2: Extract public key from issuer certificate and verify signature
    console.log('Step 2: Extracting public key and verifying signature...');
    try {
      const publicKey = await extractPublicKeyFromCert(issuerCertBytes);
      result.signatureValid = await verifyCoseSign1(coseSign1, publicKey);
      
      if (!result.signatureValid) {
        result.errors.push('COSE signature verification failed');
      }
    } catch (sigErr) {
      console.error('Signature verification error:', sigErr);
      result.errors.push(`Signature verification error: ${sigErr.message}`);
      result.signatureValid = false;
    }
    
    // Step 3: Validate that issuer certificate is signed by an IACA root
    console.log('Step 3: Validating issuer certificate against IACA roots...');
    result.chainInfo = await validateCertificateChain(issuerCertBytes);
    result.chainValid = result.chainInfo.valid;
    
    if (!result.chainValid) {
      result.errors.push(...result.chainInfo.errors);
    }
    
  } catch (err) {
    console.error('Signature verification with chain error:', err);
    result.errors.push(`Verification error: ${err.message}`);
  }
  
  return result;
}

// ===== IACA CERTIFICATE MANAGEMENT =====

// Default IACA certificates (exposed globally for IACA module)
const DEFAULT_IACA_CERTIFICATES = [
  {
    name: 'Autorit√© de Certification France Identit√© IACA',
    pem:`-----BEGIN CERTIFICATE-----
MIIDHTCCAsSgAwIBAgISESEhmoph1P1OOjDCLJAgGdBbMAoGCCqGSM49BAMCMIGf
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjE5MDcGA1UE
AwwwQXV0b3JpdMOpIGRlIENlcnRpZmljYXRpb24gRnJhbmNlIElkZW50aXTDqSBJ
QUNBMQowCAYDVQQFEwExMB4XDTI1MTAxNzAwMDAwMFoXDTM0MTAxNzAwMDAwMFow
gZ8xCzAJBgNVBAYTAkZSMTAwLgYDVQQKDCdBZ2VuY2UgTmF0aW9uYWxlIGRlcyBU
aXRyZXMgU8OpY3VyaXPDqXMxFzAVBgNVBAsMDjAwMDIgMTMwMDAzMjYyMTkwNwYD
VQQDDDBBdXRvcml0w6kgZGUgQ2VydGlmaWNhdGlvbiBGcmFuY2UgSWRlbnRpdMOp
IElBQ0ExCjAIBgNVBAUTATEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQqfRW/
7OTJS4K0IPMa/c8UicIUq62jTccQtGnHAYk6UnvXyRO3PC4/2pdq5QjhwIKwJVqC
FOr4fbGboMKLX+L/o4HdMIHaMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAG
AQH/AgEAMCwGA1UdEgQlMCOBIWZyYW5jZS1pZGVudGl0ZUBpbnRlcmlldXIuZ291
di5mcjBGBgNVHR8EPzA9MDugOaA3hjVodHRwOi8vY3JsLmFudHMuZ291di5mci9h
Y19mcmFuY2VfaWRlbnRpdGVfaWFjYV8xLmNybDAdBgNVHQ4EFgQUAQ1+Rjq9mU0k
AyKKyTwFdgjmwA4wHwYDVR0jBBgwFoAUAQ1+Rjq9mU0kAyKKyTwFdgjmwA4wCgYI
KoZIzj0EAwIDRwAwRAIgSNKCT8z4zaZLfdOd/rHevKYDbvjqylK723wjd4g4s0EC
IDnoWVWyJHwlO31z3QmK7QapM00sOCJnsTIvEGi1Fz/I
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorit√© de Certification France Identit√© IACA, C=FR',
    test: false,
    active: true
  },
  {
    name: 'Autorit√© de Certification France Attestations IACA',
    pem:`-----BEGIN CERTIFICATE-----
MIIDLTCCAtKgAwIBAgISESEFJUbpBJovlg7lg3Eb5YTCMAoGCCqGSM49BAMCMIGi
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjE8MDoGA1UE
AwwzQXV0b3JpdMOpIGRlIENlcnRpZmljYXRpb24gRnJhbmNlIEF0dGVzdGF0aW9u
cyBJQUNBMQowCAYDVQQFEwExMB4XDTI1MTAxNzAwMDAwMFoXDTM0MTAxNzAwMDAw
MFowgaIxCzAJBgNVBAYTAkZSMTAwLgYDVQQKDCdBZ2VuY2UgTmF0aW9uYWxlIGRl
cyBUaXRyZXMgU8OpY3VyaXPDqXMxFzAVBgNVBAsMDjAwMDIgMTMwMDAzMjYyMTww
OgYDVQQDDDNBdXRvcml0w6kgZGUgQ2VydGlmaWNhdGlvbiBGcmFuY2UgQXR0ZXN0
YXRpb25zIElBQ0ExCjAIBgNVBAUTATEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNC
AASa4ZI0w4Mn4FW6kYdKPUlYYgVbwFf1A6lBDnurRsoPJxM3+dVupbkGl9O+QnJ3
6wc8ngoXE3oH1hP11flDmWsIo4HlMIHiMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMB
Af8ECDAGAQH/AgEAMDAGA1UdEgQpMCeBJWZyYW5jZS1hdHRlc3RhdGlvbnNAaW50
ZXJpZXVyLmdvdXYuZnIwSgYDVR0fBEMwQTA/oD2gO4Y5aHR0cDovL2NybC5hbnRz
LmdvdXYuZnIvYWNfZnJhbmNlX2F0dGVzdGF0aW9uc19pYWNhXzEuY3JsMB0GA1Ud
DgQWBBT/dscZoX+tou0+F2dDsFrTPfsMpzAfBgNVHSMEGDAWgBT/dscZoX+tou0+
F2dDsFrTPfsMpzAKBggqhkjOPQQDAgNJADBGAiEAmMD8Kpgnctmx12gCBYrj98kn
oKDSPlO5SucThy1EEqwCIQDsYM80Ere4Yw0fHNJQQHl6D1rAITDV3qFKP62Uq7xt
sQ==
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorit√© de Certification France Attestations IACA, C=FR',
    test: false,
    active: true
  },
  {
    name: 'France Attestations - Test IACA',
    pem: `-----BEGIN CERTIFICATE-----
MIIDUzCCAvmgAwIBAgISESHtNjf+2KAQ0ttWtR9EhAAPMAoGCCqGSM49BAMCMIHF
MQswCQYDVQQGEwJGUjEwMC4GA1UECgwnQWdlbmNlIE5hdGlvbmFsZSBkZXMgVGl0
cmVzIFPDqWN1cmlzw6lzMRcwFQYDVQQLDA4wMDAyIDEzMDAwMzI2MjEmMCQGA1UE
CwwdUE9VUiBRVUFMSUZJQ0FUSU9OIFVOSVFVRU1FTlQxNzA1BgNVBAMMLkF1dG9y
aXTDqSBkZSBDZXJ0aWZpY2F0aW9uIEZyYW5jZSBBdHRlc3RhdGlvbnMxCjAIBgNV
BAUTATEwHhcNMjUwMTI5MDAwMDAwWhcNMzAwMTI5MDAwMDAwWjCBxTELMAkGA1UE
BhMCRlIxMDAuBgNVBAoMJ0FnZW5jZSBOYXRpb25hbGUgZGVzIFRpdHJlcyBTw6lj
dXJpc8OpczEXMBUGA1UECwwOMDAwMiAxMzAwMDMyNjIxJjAkBgNVBAsMHVBPVVIg
UVVBTElGSUNBVElPTiBVTklRVUVNRU5UMTcwNQYDVQQDDC5BdXRvcml0w6kgZGUg
Q2VydGlmaWNhdGlvbiBGcmFuY2UgQXR0ZXN0YXRpb25zMQowCAYDVQQFEwExMFkw
EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoCYCM9LYS8zUk8I1xL2B2G9voa4yFsko
qohrsEQkpNEeKb59J3VDHausTqFWCOfwEGUzi6yocLIbE+gfz59pnaOBxjCBwzAO
BgNVHQ8BAf8EBAMCAQYwMAYDVR0SBCkwJ4ElZnJhbmNlLWF0dGVzdGF0aW9uc0Bp
bnRlcmlldXIuZ291di5mcjASBgNVHRMBAf8ECDAGAQH/AgEAMEwGA1UdHwRFMEMw
QaA/oD2GO2h0dHA6Ly9jcmwucXVhbGlmLmFudHMuZ291di5mci9hY19mcmFuY2Vf
YXR0ZXN0YXRpb25zXzEuY3JsMB0GA1UdDgQWBBR3bIy6PB3fPAlYHOvqk7nftps4
sDAKBggqhkjOPQQDAgNIADBFAiBrI2HGG1SZNRfEoaIwk3bjAjLBcE9tcKPi1gu0
oah58AIhAL+KWRF8FwT4JBblyZdmuoVVXJ36LMmAUcs5YwJpMiQW
-----END CERTIFICATE-----`,
    issuer: 'CN=Autorit√© de Certification France Attestations, C=FR',
    test: true,
    active: true
  },
  {
    name: 'IACA NL mDL',
    pem: `-----BEGIN CERTIFICATE-----
MIIChzCCAg6gAwIBAgIUNKLqlwyPhbMOSD0kBpBVr/8nR3wwCgYIKoZIzj0EAwMw
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDExFDASBgNV
BAMMC0lBQ0EgTkwgbURMMB4XDTIxMTIxNDEzMTMxMFoXDTI5MTIxNDEzMTMwOVow
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDExFDASBgNV
BAMMC0lBQ0EgTkwgbURMMHowFAYHKoZIzj0CAQYJKyQDAwIIAQELA2IABD0oIkWG
2SCr1imaAe1b41erTis67NlSA60xehE8IsYPVEzcn6FW5+gWrQ1p8+4ZizqdHFd3
v84WWSe7W19tjqUurnTFMKG5NxZ2KFxpDc1YZCmB128PgeyJ2KzC2aFZ16OByDCB
xTASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFNLoPEtlzS8edYK61ZVE
b0WqBUlAMEAGA1UdHwQ5MDcwNaAzoDGGL2h0dHA6Ly93d3ctZGllbnN0ZW4ucmR3
Lm5sL2NybC9JQUNBTkxtREwtMDEuY3JsMB0GA1UdDgQWBBTS6DxLZc0vHnWCutWV
RG9FqgVJQDAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0SBBYwFIYSaHR0cHM6Ly93d3cu
cmR3Lm5sMAoGCCqGSM49BAMDA2cAMGQCMCG8ctJf3PUfSB2LoYqgoy2iWe1Nqzjo
0FJxc9ePVPVeFfI2t2Mqe2mo50hJ9EKMqwIwBtek1Tpw/SRjLjI+L0PMBtiE9Tse
C6oqwQPIIuSJLgUWByKywFFlK+i8EqosLCVT
-----END CERTIFICATE-----`,
    issuer: 'C=NL, O=RDW, serialNumber=01, CN=IACA NL mDL',
    test: false,
    active: true
  },
  {
    name: 'IACA NL mVR',
    pem: `-----BEGIN CERTIFICATE-----
MIIChzCCAg6gAwIBAgIUApUuBv6PnHuN+DFrHMXDPCD1eSswCgYIKoZIzj0EAwMw
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDIxFDASBgNV
BAMMC0lBQ0EgTkwgbVZSMB4XDTIzMTAxMDExMzA1MFoXDTMxMTAxMDExMzA0OVow
PjELMAkGA1UEBhMCTkwxDDAKBgNVBAoMA1JEVzELMAkGA1UEBRMCMDIxFDASBgNV
BAMMC0lBQ0EgTkwgbVZSMHowFAYHKoZIzj0CAQYJKyQDAwIIAQELA2IABB9T038B
YLJ8EEA3WU23Y8uYShK9zvEB7zO6CcyvtpzDZLhefHc7qfibWATbI2Pa7EAtHAmb
z8HkLqgBNfFg2aDtyfr9fs892dA6yJ9zbVv2Pna7+77rriOjND5doNnhxaOByDCB
xTASBgNVHRMBAf8ECDAGAQH/AgEAMB8GA1UdIwQYMBaAFEOPFj/6DqRZUGdQH2Ir
/0wtL/+qMEAGA1UdHwQ5MDcwNaAzoDGGL2h0dHA6Ly93d3ctZGllbnN0ZW4ucmR3
Lm5sL2NybC9JQUNBTkxtVlItMDEuY3JsMB0GA1UdDgQWBBRDjxY/+g6kWVBnUB9i
K/9MLS//qjAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0SBBYwFIYSaHR0cHM6Ly93d3cu
cmR3Lm5sMAoGCCqGSM49BAMDA2cAMGQCMEQf7RWdfWBY3SlgyW75xdZNuUmJPaDZ
/mji/fMCSePodYkY/tg0uLUw/p6dFLytgQIwE4zKx4iQNBFW4jAgHdvfvS9qh0h6
ryXFc+YMxyMOmThPKdcIKg1FMQZ6ZSaTOxEM
-----END CERTIFICATE-----`,
    issuer: 'C=NL, O=RDW, serialNumber=02, CN=IACA NL mVR',
    test: false,
    active: true
  }
];

// Make defaults available to the IACA module
window.DEFAULT_IACA_CERTIFICATES = DEFAULT_IACA_CERTIFICATES;

// Bridge to external IACA module (preserve existing identifiers used across the app)
const initializeIACAs = (...args) => window.IacaManager.initializeIACAs(...args);
const getIACAs = (...args) => window.IacaManager.getIACAs(...args);
const getActiveIACAs = (...args) => window.IacaManager.getActiveIACAs(...args);
const addIACA = (...args) => window.IacaManager.addIACA(...args);
const removeIACA = (...args) => window.IacaManager.removeIACA(...args);
const toggleIACAStatus = (...args) => window.IacaManager.toggleIACAStatus(...args);
const parsePEMCertificate = (...args) => window.IacaManager.parsePEMCertificate(...args);
const pemToCryptoKey = (...args) => window.IacaManager.pemToCryptoKey(...args);
const updateIACAList = (...args) => window.IacaManager.updateIACAList(...args);

// Bridge: JSON conversion helper
const convertToJSON = (...args) => window.WalletResponse.convertToJSON(...args);

// Bridge: Display DeviceResponse
const displayDeviceResponse = (...args) => window.WalletResponse.displayDeviceResponse(...args);

// Helper: Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Expose selected helpers to external modules (used by js/iaca-management.js)
window.extractPublicKeyFromCert = extractPublicKeyFromCert;
window.parseX509Certificate = parseX509Certificate;
window.extractCertValidity = extractCertValidity;
window.detectCurveFromCertOID = detectCurveFromCertOID;
window.extractCertInfo = extractCertInfo;
window.escapeHtml = escapeHtml;
// Expose verification helper so wallet-response can call it after rendering
window.verifyCOSESign1SignatureWithChain = verifyCOSESign1SignatureWithChain;
// (Optionally expose the underlying helpers if needed elsewhere)
window.verifyCoseSign1 = verifyCoseSign1;
window.validateCertificateChain = validateCertificateChain;

// Bridge: Decrypt SessionEstablishment (raw AES-GCM)
const decryptSessionEstablishmentData = (...args) => window.WalletResponse.decryptSessionEstablishmentData(...args);

// Helper: Format field names to be more readable
function formatFieldName(fieldName) {
  return fieldName
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

async function processSessionResponse(assembled) {
  console.log('=== FINALIZING SESSION FROM WALLET RESPONSE ===');
  console.log('Raw response bytes:', hex(assembled));

  if (!readerKeyPair) {
    throw new Error('Reader ephemeral key pair not initialized');
  }

  let decoded;
  try {
  decoded = CBOR.decode(assembled);
  } catch (decodeError) {
    console.warn('Session response is not valid CBOR:', decodeError.message);
    decoded = null;
  }

  // Helper to coerce Map/Object into Map-like accessor
  const toMap = (value) => {
    if (!value) return null;
    if (value instanceof Map) return value;
    if (typeof value === 'object') {
      const map = new Map();
      for (const key of Object.keys(value)) {
        map.set(key, value[key]);
      }
      return map;
    }
    return null;
  };

  const decodedMap = toMap(decoded);
  let eDeviceKey = null;

  const possibleLabels = ['eDeviceKey', 'publicKey', 'deviceKey'];
  if (decodedMap) {
    for (const label of possibleLabels) {
      if (decodedMap.has(label)) {
        eDeviceKey = decodedMap.get(label);
        console.log(`Found potential wallet key under label "${label}"`);
        break;
      }
    }
  }

  // Some wallets nest the key inside the "deviceEngagement" or similar structures
  if (!eDeviceKey && decodedMap) {
    for (const value of decodedMap.values()) {
      const nested = toMap(value);
      if (nested) {
        for (const label of possibleLabels) {
          if (nested.has(label)) {
            eDeviceKey = nested.get(label);
            console.log(`Found nested wallet key under label "${label}"`);
            break;
          }
        }
      }
      if (eDeviceKey) break;
    }
  }

  let walletKeyMap = null;
  if (eDeviceKey) {
    if (eDeviceKey instanceof CBOR.Tagged) {
      console.log('Wallet key is CBOR.Tagged - decoding value');
      const value = eDeviceKey.value;
      const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);
  walletKeyMap = toMap(CBOR.decode(bytes));
    } else if (eDeviceKey instanceof Uint8Array) {
      console.log('Wallet key is raw Uint8Array - decoding');
  walletKeyMap = toMap(CBOR.decode(new Uint8Array(eDeviceKey.buffer, eDeviceKey.byteOffset, eDeviceKey.byteLength)));
    } else if (ArrayBuffer.isView(eDeviceKey)) {
      console.log('Wallet key is ArrayBuffer view - decoding');
      const bytes = new Uint8Array(eDeviceKey.buffer, eDeviceKey.byteOffset, eDeviceKey.byteLength);
  walletKeyMap = toMap(CBOR.decode(bytes));
    } else {
      walletKeyMap = toMap(eDeviceKey);
    }
  }

  let sharedSecretBuffer = null;

  // log('‚ö†Ô∏è Wallet response did not contain an ephemeral key. Falling back to static DeviceEngagement key.');
  const mdocPub = await window.SessionCrypto.importMdocPubKeyXY(mdocPubKey.x, mdocPubKey.y);
  sharedSecretBuffer = await window.SessionCrypto.deriveSharedSecretBits(readerKeyPair.privateKey, mdocPub);

  const sharedSecretBytes = new Uint8Array(sharedSecretBuffer);
  transcriptAAD = await window.SessionEstablishment.buildTranscriptAAD(deBytes);
  const keys = await window.SessionCrypto.deriveSessionKey(sharedSecretBytes, transcriptAAD);

  skReader = keys.readerKey;
  skDevice = keys.deviceKey;
  window.skDevice = skDevice;
  sessionKey = skReader;
  sessionEstablished = true;
  window.sessionEstablished = true;

  console.log('Session keys ready. SKReader:', hex(skReader));
  console.log('Session keys ready. SKDevice:', hex(skDevice));

  log('‚úÖ Session ready using static DeviceEngagement key');

  // Now decrypt and display the documents from the 'data' field
  log('üîì Decrypting wallet response to extract documents...');

  // Get the 'data' field from the response (decodedMap already declared above)
  const responseData = decodedMap ? (decodedMap.get('data') || decodedMap.get(4)) : null;

  // Normalize the 'data' into a Uint8Array for WebCrypto
  const toBytes = (v) => {
    try {
      // Unwrap CBOR.Tagged(bstr .cbor ...) or Tagged(bstr ...)
      if (v && typeof v === 'object' && v.constructor && v.constructor.name === 'Tagged') {
        v = v.value;
      }
    } catch {}
    if (v instanceof Uint8Array) return v;
    if (ArrayBuffer.isView(v)) return new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
    if (v instanceof ArrayBuffer) return new Uint8Array(v);
    if (Array.isArray(v)) return new Uint8Array(v);
    // Last resort: try length + numeric indices
    if (v && typeof v.length === 'number') {
      try { return new Uint8Array(v); } catch {}
    }
    return null;
  };

  const dataBytes = toBytes(responseData);
  if (dataBytes && dataBytes.length > 0) {
    try {
      // First try RAW AES-GCM as per spec (ciphertext || 16-byte tag with SKDevice)
      const deviceResponse = await decryptSessionEstablishmentData(dataBytes);
      const model = buildResponseViewModel(deviceResponse);
      renderResponseViewModel(model);
      // Auto-disconnect to release BLE icon (simplified)
      try {
        if (window.BLE && typeof window.BLE.disconnect === 'function') {
          window.BLE.disconnect();
        }
      } catch (e) { console.warn('Auto-disconnect failed:', e); }
    } catch (decryptError) {
      console.warn('RAW AES-GCM decrypt failed, attempting COSE_Encrypt0 fallback:', decryptError);
      // Some wallets return COSE_Encrypt0 here. Detect/fallback.
      try {
        // Quick heuristic: CBOR array major type initial byte 0x80..0x9f (e.g., 0x83)
        const b0 = dataBytes[0];
        const looksLikeCborArray = b0 >= 0x80 && b0 <= 0x9f;
        if (looksLikeCborArray) {
          await decryptAndRenderResponse(dataBytes);
        } else {
          // As a last resort, try decoding as CBOR and check shape
          try {
            const dec = CBOR.decode(dataBytes);
            if (Array.isArray(dec) && dec.length === 3) {
              await decryptAndRenderResponse(dataBytes);
            } else {
              throw decryptError;
            }
          } catch (_) {
            throw decryptError;
          }
        }
      } catch (fallbackErr) {
        console.error('Failed to decrypt documents:', fallbackErr);
        log('‚ùå Failed to decrypt documents: ' + (fallbackErr.message || fallbackErr));
      }
    }
  } else {
    const t = responseData ? (responseData.constructor && responseData.constructor.name) : 'null/undefined';
    console.warn('No usable document data found in wallet response. Type:', t);
    log('‚ö†Ô∏è No document data found in wallet response');
  }
}
// Removed writeState/sendFragmented wrappers in favor of direct BLE module calls

// ==== QR scanning ====
function stopCamera() {
  scanRunning = false;
  video.pause();
  
  // Stop all video tracks to release the camera
  if (video.srcObject) {
    const stream = video.srcObject;
    const tracks = stream.getTracks();
    tracks.forEach(track => {
      track.stop();
      console.log('Camera track stopped:', track.kind);
    });
    video.srcObject = null;
    log('üìπ Camera stopped');
  }
}

// Disconnect existing BLE connection if any
function disconnectBLE() {
  try {
    if (window.BLE && typeof window.BLE.disconnect === 'function') {
      window.BLE.disconnect();
    }
  } catch (e) {
    console.warn('Error disconnecting BLE device:', e);
  }
  // Reset session-related state
  sessionEstablished = false;
  readerKeyPair = null;
  skReader = null;
  skDevice = null;
  window.skDevice = skDevice;
  sessionKey = null;
  transcriptAAD = null;
  walletEphemeralKey = null;

  // Remove existing connect button if present
  const existingBtn = document.getElementById('btnAutoConnect');
  if (existingBtn) {
    existingBtn.remove();
    console.log('Removed existing connect button');
  }

  console.log('BLE connection state reset');
}

async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
  video.srcObject = stream;
  await video.play();
  canvas.width = video.videoWidth || 1280;
  canvas.height = video.videoHeight || 720;
  scanRunning = true;
  statusEl.textContent = 'Scanning‚Ä¶';
  requestAnimationFrame(tick);
}
function tick() {
  if (!scanRunning) return;
  const ctx2d = canvas.getContext('2d', { willReadFrequently:true });
  ctx2d.drawImage(video, 0, 0, canvas.width, canvas.height);
  const img = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
  const code = jsQR(img.data, img.width, img.height, { inversionAttempts: "dontInvert" });
  if (code?.data) {
    stopCamera(); // Properly stop the camera
    statusEl.textContent='QR detected';
    handleQrPayload(code.data, 'camera scan');
    return;
  }
  requestAnimationFrame(tick);
}
btnScan.addEventListener('click', () => {
  // Ensure previous BLE session is fully closed so old notifications won't repopulate UI
  try { disconnectBLE(); } catch {}
  resetResponseAndLog();
  startCamera().catch(e => log('Camera error: '+e.message));
});

// Normalize QR payloads coming from camera, manual paste, or laser scanner.
async function handleQrPayload(raw, sourceLabel) {
  const payload = (raw || '').trim();
  if (!payload) {
    log('‚ö†Ô∏è No QR payload provided');
    statusEl.textContent = 'No payload';
    return;
  }

  // Disconnect any existing BLE connection before processing new QR code
  disconnectBLE();

  try {
    const { uuid, addr } = parseMdocUriAndDE(payload);
    svcUUID = uuid;
    bleAddr = addr;
    svcUuidEl.textContent = uuid || '‚Äî';
    bleAddrEl.textContent = addr || '‚Äî';
    statusEl.textContent = `Parsed from ${sourceLabel}`;
    qrInput.value = payload;
    updateBleRoleUI();
    log(`‚úÖ Parsed QR payload from ${sourceLabel}. Service UUID: ${uuid || 'n/a'}`);
    
    // Show message to user about clicking to connect
    log('üöÄ Ready to connect! Click "Connect & Request Digital Credentials" below to continue...');
    
    // Enable and show a connect button
    if (!document.getElementById('btnAutoConnect')) {
      const connectBtn = document.createElement('button');
      connectBtn.id = 'btnAutoConnect';
      connectBtn.textContent = 'üöÄ Connect & Request Digital Credentials';
      connectBtn.style.cssText = 'margin: 1rem 0; padding: 0.75rem 1.5rem; font-size: 1.1em; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;';
      connectBtn.onclick = async () => {
        connectBtn.disabled = true;
        connectBtn.textContent = 'Connecting...';
        try {
          await autoConnectFlow();
          connectBtn.remove(); // Remove button after successful connection
        } catch (error) {
          connectBtn.disabled = false;
          connectBtn.textContent = 'üöÄ Connect & Start Session';
          log(`‚ùå Connection failed: ${error.message}`);
        }
      };
      
      // Insert button after the QR section
      const qrSection = document.getElementById('qrSection');
      qrSection.appendChild(connectBtn);
    }
    
  } catch (e) {
    log(`‚ùå ${sourceLabel} QR parse error: ${e.message}`);
    statusEl.textContent = 'Parse failed';
  }
}

// Removed bleConnect wrapper; connect inline in autoConnectFlow

// Automated connection and session establishment flow
async function autoConnectFlow() {
  try {
    // Step 1: Connect to wallet
    const connected = !!(window.BLE && typeof window.BLE.isConnected === 'function' && window.BLE.isConnected());
    if (!connected) {
      if (!svcUUID) throw new Error('Service UUID missing (scan QR or use override)');
      if (!window.BLE || typeof window.BLE.connect !== 'function' || typeof window.BLE.init !== 'function') {
        throw new Error('BLE module not available');
      }
      // Initialize BLE module bindings on first use
      window.BLE.init({
        onAssembled: processS2CAssembled,
        logger: log,
        defaultChunk: parseInt(chunkInput.value, 10) || 185,
      });
      log(`Connecting to wallet (service ${svcUUID})‚Ä¶`);
      await window.BLE.connect(svcUUID);
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait for connection to stabilize
    }
    
    // Step 2: Start session (state 0x01)
    log('üé¨ Starting session (state 0x01)...');
    await window.BLE.writeState(0x01);
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Step 3: Send SessionEstablishment
    log('üîê Sending SessionEstablishment...');
    
    // Reset session state
    if (window.SessionEstablishment && typeof window.SessionEstablishment.resetReaderCoseKeyCache === 'function') {
      window.SessionEstablishment.resetReaderCoseKeyCache();
    }
    skReader = null;
    skDevice = null;
    window.skDevice = skDevice;
    sessionKey = null;
    transcriptAAD = null;
    walletEphemeralKey = null;
    sessionEstablished = false;
    window.sessionEstablished = false;

    // Generate ephemeral key pair
  readerKeyPair = await window.SessionEstablishment.makeReaderEphemeralKeyPair();
  await window.SessionEstablishment.exportReaderPublicToCoseKey(readerKeyPair);
    log('‚úÖ Generated ephemeral key pair');
    
    // Build SessionTranscript immediately (needed for reader authentication)
    // SessionTranscript = [DeviceEngagement, EReaderKey, Handover]
    // All components are now available:
    //  - DeviceEngagement (deBytes) from QR scan
    //  - EReaderKey (readerKeyPair) just generated
    //  - Handover (null for BLE)
    console.log('Building SessionTranscript for reader authentication...');
  transcriptAAD = await window.SessionEstablishment.buildTranscriptAAD(deBytes);
    console.log('‚úÖ SessionTranscript built, length:', transcriptAAD.length, 'bytes');
    
    // Build and send SessionEstablishment message
    const { message: legacyMessage, keys, transcriptAAD: aad } = await window.SessionEstablishment.buildLegacySessionEstablishmentWithData({
      deBytes,
      mdocPubKey,
      readerKeyPair,
      transcriptAAD,
      skReader,
      buildRequestByType,
      log,
      CBOR,
    });
    if (keys) {
      skReader = keys.readerKey;
      skDevice = keys.deviceKey;
      window.skDevice = skDevice;
      sessionKey = skReader;
      sessionEstablished = true;
      window.sessionEstablished = true;
    }
    if (aad) transcriptAAD = aad;
    console.log('SessionEstablishment message length:', legacyMessage.length);
    await window.BLE.sendFragmented(legacyMessage, parseInt(chunkInput.value, 10) || 185);
    
    log('üì§ SessionEstablishment sent (includes encrypted document request).');
    
    // Note: The wallet will first respond with SessionEstablishment response (to finalize session keys)
    // Then it will send DeviceResponse with the actual documents
    log('‚è≥ Waiting for wallet to process request...');
    log('ÔøΩ You may need to approve data sharing in your wallet app');
    
  } catch (error) {
    console.error('Auto-connect flow error:', error);
    log(`‚ùå Auto-connect failed: ${error.message}`);
  }
}

btnParseQr.addEventListener('click', () => { 
  resetResponseAndLog();
  handleQrPayload(qrInput.value, 'manual input');
});
btnClearQr.addEventListener('click', () => {
  qrInput.value = '';
  statusEl.textContent = 'Idle';
  qrInput.focus();
});

qrInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    resetResponseAndLog();
    handleQrPayload(qrInput.value, 'manual input');
  }
});

// ==== IACA Management Event Listeners ====
btnAddIaca.addEventListener('click', () => {
  const pem = iacaInput.value.trim();
  const isTest = document.getElementById('iacaIsTest').checked;
  
  if (!pem) {
    alert('Please paste a PEM certificate');
    return;
  }
  
  if (!pem.includes('-----BEGIN CERTIFICATE-----')) {
    alert('Invalid PEM format. Certificate must start with "-----BEGIN CERTIFICATE-----"');
    return;
  }
  
  try {
    const added = addIACA(pem, null, isTest);
    log(`‚úÖ Added IACA: ${added.name}${isTest ? ' (test)' : ''}`);
    iacaInput.value = '';
    document.getElementById('iacaIsTest').checked = false;
    updateIACAList();
    alert(`Certificate added successfully:\n${added.name}${isTest ? '\n‚ö†Ô∏è Marked as test/development certificate' : ''}`);
  } catch (e) {
    console.error('Failed to add IACA:', e);
    alert(`Failed to add certificate:\n${e.message}`);
  }
});

btnClearIacaInput.addEventListener('click', () => {
  iacaInput.value = '';
  document.getElementById('iacaIsTest').checked = false;
  iacaInput.focus();
});

// ==== VICAL Import Event Listeners ====
function setVicalStatus(message, isError = false) {
  if (!vicalImportStatus) return;
  vicalImportStatus.textContent = message;
  vicalImportStatus.style.color = isError ? '#b91c1c' : '#64748b';
}

async function handleVicalResult(result) {
  try {
    updateIACAList();
  } catch {}
  if (!result || typeof result !== 'object') {
    setVicalStatus('Import completed.');
    return;
  }
  const total = result.total ?? result.count ?? result.entries ?? undefined;
  const added = result.imported ?? result.added ?? result.success ?? undefined;
  const skipped = result.skipped ?? result.duplicates ?? undefined;
  const errors = Array.isArray(result.errors) ? result.errors.length : (result.errors ?? 0);
  const unknown = result.unknown ?? undefined;
  const parts = [];
  if (total !== undefined) parts.push(`${total} item(s)`);
  if (added !== undefined) parts.push(`${added} imported`);
  if (skipped !== undefined) parts.push(`${skipped} skipped`);
  if (unknown !== undefined) parts.push(`${unknown} unknown`);
  if (errors) parts.push(`${errors} error(s)`);
  const summary = parts.length ? parts.join(', ') : 'completed';
  setVicalStatus(`VICAL import ${summary}.`);
}

btnImportVicalUri?.addEventListener('click', async () => {
  const uri = (vicalUri?.value || '').trim();
  if (!uri) {
    alert('Please enter a VICAL URI (https://... or data:application/cbor;base64,...)');
    vicalUri?.focus();
    return;
  }
  if (!window.IacaManager || typeof window.IacaManager.importVICALFromUri !== 'function') {
    setVicalStatus('VICAL import not available in this build.', true);
    return;
  }
  btnImportVicalUri.disabled = true;
  setVicalStatus('Importing from URI‚Ä¶');
  try {
    const res = await window.IacaManager.importVICALFromUri(uri, { markTest: !!vicalMarkTest?.checked });
    await handleVicalResult(res);
  } catch (e) {
    console.error('VICAL import (URI) failed:', e);
    setVicalStatus(`Import failed: ${e.message || e}`, true);
  } finally {
    btnImportVicalUri.disabled = false;
  }
});

btnImportVicalFile?.addEventListener('click', async () => {
  const file = vicalFile?.files && vicalFile.files[0];
  if (!file) {
    alert('Please select a VICAL CBOR file to import.');
    vicalFile?.focus();
    return;
  }
  if (!window.IacaManager || typeof window.IacaManager.importVICALFromBytes !== 'function') {
    setVicalStatus('VICAL import not available in this build.', true);
    return;
  }
  btnImportVicalFile.disabled = true;
  setVicalStatus('Importing from file‚Ä¶');
  try {
    const buf = await file.arrayBuffer();
    const bytes = new Uint8Array(buf);
    const res = await window.IacaManager.importVICALFromBytes(bytes, { markTest: !!vicalMarkTest?.checked });
    await handleVicalResult(res);
  } catch (e) {
    console.error('VICAL import (file) failed:', e);
    setVicalStatus(`Import failed: ${e.message || e}`, true);
  } finally {
    btnImportVicalFile.disabled = false;
    try { if (vicalFile) vicalFile.value = ''; } catch {}
  }
});

// Initialize IACA list on page load
updateIACAList();

// ==== Reader Authentication UI Wiring ====
function setReaderAuthStatus(message, level = 'info') {
  if (!readerAuthStatus) return;
  readerAuthStatus.textContent = message;
  readerAuthStatus.style.display = 'block';
  // Basic styling by level
  if (level === 'error') {
    readerAuthStatus.style.background = '#fee2e2';
    readerAuthStatus.style.border = '1px solid #ef4444';
    readerAuthStatus.style.color = '#991b1b';
  } else if (level === 'success') {
    readerAuthStatus.style.background = '#dcfce7';
    readerAuthStatus.style.border = '1px solid #22c55e';
    readerAuthStatus.style.color = '#14532d';
  } else {
    readerAuthStatus.style.background = '#e5e7eb';
    readerAuthStatus.style.border = '1px solid #9ca3af';
    readerAuthStatus.style.color = '#111827';
  }
}

function initReaderAuthUI() {
  try {
    if (!window.ReaderAuth) return;
    const cfg = window.ReaderAuth.getConfig ? window.ReaderAuth.getConfig() : null;
    if (!cfg) return;
    if (enableReaderAuth) enableReaderAuth.checked = !!cfg.enabled;
    if (readerAuthConfig) readerAuthConfig.style.display = cfg.enabled ? 'block' : 'none';
  // readerOrgName removed; show Common Name from certificate instead
    if (readerCertificate) readerCertificate.value = cfg.certsPem || '';
    if (readerPrivateKey) readerPrivateKey.value = cfg.keyPem || '';
    if (cfg.enabled) setReaderAuthStatus('Reader Authentication is enabled. Saved key and certificate will be used to sign requests.', 'info');
  } catch (e) {
    console.warn('ReaderAuth UI init failed:', e);
  }
}

enableReaderAuth?.addEventListener('change', (e) => {
  const on = !!e.target.checked;
  try { window.ReaderAuth?.setEnabled?.(on); } catch {}
  if (readerAuthConfig) readerAuthConfig.style.display = on ? 'block' : 'none';
  setReaderAuthStatus(on ? 'Reader Authentication enabled.' : 'Reader Authentication disabled.', 'info');
  // Refresh CN display when toggling visibility
  try { updateReaderCommonName(); } catch {}
});

btnSaveReaderCert?.addEventListener('click', () => {
  const certPem = (readerCertificate?.value || '').trim();
  const keyPem = (readerPrivateKey?.value || '').trim();
  if (!certPem || !keyPem) {
    setReaderAuthStatus('Please provide both a certificate (PEM) and a private key (PKCS#8 PEM).', 'error');
    return;
  }
  try {
    window.ReaderAuth?.setCertsPem?.(certPem);
    window.ReaderAuth?.setKeyPem?.(keyPem);
    setReaderAuthStatus('Saved reader key and certificate. Requests will include a signed ReaderAuthentication COSE_Sign1.', 'success');
    // Update CN display from the provided certificate
    try { updateReaderCommonName(certPem); } catch {}
  } catch (e) {
    console.error('Failed to save reader auth config:', e);
    setReaderAuthStatus('Failed to save reader authentication settings: ' + (e.message || e), 'error');
  }
});

btnClearReaderCert?.addEventListener('click', () => {
  try {
    if (readerCertificate) readerCertificate.value = '';
    if (readerPrivateKey) readerPrivateKey.value = '';
    window.ReaderAuth?.setCertsPem?.('');
    window.ReaderAuth?.setKeyPem?.('');
    setReaderAuthStatus('Cleared reader authentication settings.', 'info');
    if (readerCommonNameEl) readerCommonNameEl.textContent = '‚Äî';
  } catch (e) {
    setReaderAuthStatus('Failed to clear settings: ' + (e.message || e), 'error');
  }
});

// Initialize on load
initReaderAuthUI();
// Live-update CN preview as the user pastes/edits the certificate
readerCertificate?.addEventListener('input', () => {
  try { updateReaderCommonName(readerCertificate.value); } catch {}
});

// Helper: parse first CERTIFICATE block from PEM to DER bytes (Uint8Array)
function pemFirstCertToDer(pem) {
  if (!pem) return null;
  const m = pem.match(/-----BEGIN CERTIFICATE-----([\s\S]*?)-----END CERTIFICATE-----/);
  if (!m) return null;
  const b64 = m[1].replace(/[^A-Za-z0-9+/=\-_]/g, '').replace(/-/g, '+').replace(/_/g, '/');
  const raw = atob(b64);
  const out = new Uint8Array(raw.length);
  for (let i=0;i<raw.length;i++) out[i] = raw.charCodeAt(i);
  return out;
}

function updateReaderCommonName(certPemFromArg) {
  try {
    const pem = (certPemFromArg && certPemFromArg.trim()) || (window.ReaderAuth?.getConfig?.().certsPem || '').trim();
    const der = pemFirstCertToDer(pem);
    if (!der) { if (readerCommonNameEl) readerCommonNameEl.textContent = '‚Äî'; return; }
    const info = extractCertInfo(der);
    const cn = info?.subjectCN || '‚Äî';
    if (readerCommonNameEl) readerCommonNameEl.textContent = cn;
  } catch (e) {
    console.warn('Failed to update Reader Common Name:', e);
    if (readerCommonNameEl) readerCommonNameEl.textContent = '‚Äî';
  }
}

// Populate CN at startup if cert is already saved
try { updateReaderCommonName(); } catch {}

// ==== Robust mdoc URI ‚Üí CBOR extraction helpers ====
function b64ToBytesBrowserSafe(...args){ return window.DeviceEngagement.b64ToBytesBrowserSafe(...args); }
function b64urlToBytesSafe(...args){ return window.DeviceEngagement.b64urlToBytesSafe(...args); }
function looksLikeHex(...args){ return window.DeviceEngagement.looksLikeHex(...args); }
function hexToBytes(...args){ return window.DeviceEngagement.hexToBytes(...args); }
function extractCborFromMdocUri(...args){ return window.DeviceEngagement.extractCborFromMdocUri(...args); }

function tryExtractBleOptions(...args){ return window.DeviceEngagement.tryExtractBleOptions(...args); }


const asUuidString = (bytes) => {
  if (!(bytes instanceof Uint8Array) || bytes.length !== 16) return null;
  const h = [...bytes].map(b=>b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
};

// ==== Parse mdoc URI + Device Engagement ====
function parseMdocUriAndDE(uri){
  mdocUriEl.textContent = uri;
  const res = window.DeviceEngagement.parseMdocUriAndDE(uri);
  // Update module-scoped state expected by the rest of the app
  deBytes = res.deBytes;
  if (res.x && res.y) mdocPubKey = { x: res.x, y: res.y };
  return { uuid: res.uuid, addr: res.addr };
}

// ==== Session Establishment (ECDH + HKDF, Transcript AAD) ====
// Removed crypto/session wrappers duplicated with SessionCrypto/SessionEstablishment modules

// Build different request types for common use cases
// Can now accept array of request types to create multiple docRequests
// Bridge to external Request Builder module
const buildRequestByType = (...args) => window.RequestBuilder.buildRequestByType(...args);

// Helper: Build a single document request based on type
const buildSingleDocRequest = (...args) => window.RequestBuilder.buildSingleDocRequest(...args);

// ==== Mode switching ====
function updateBleRoleUI() {
  // Function kept for compatibility but no longer manages button states
  // Requests are sent automatically after session establishment
}

// Handle request type changes (now supports multiple selections)
requestTypeCheckboxes.forEach(checkbox => {
  checkbox.addEventListener('change', (e) => {
    const selected = Array.from(document.querySelectorAll('input[name="requestType"]:checked'))
      .map(cb => cb.value);
    
    if (selected.length === 0) {
      log('‚ö†Ô∏è No document types selected - will default to mDL Full');
    } else if (selected.length === 1) {
      const type = selected[0];
      let description = '';
      switch(type) {
        case 'mdl_basic':
          description = 'Basic ID: name, birth_date, portrait';
          break;
        case 'mdl_age':
          description = 'Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'mdl_driving':
          description = 'Driving license: name, birth_date, driving_privileges, license info, portrait';
          break;
        case 'mdl_full':
          description = 'Full mDL: all available fields including address, physical characteristics';
          break;
        case 'pid_basic':
          description = 'Basic EU PID: name, birth_date, portrait';
          break;
        case 'pid_age':
          description = 'EU PID Age verification: age_over_18, age_over_21, birth_date';
          break;
        case 'pid_full':
          description = 'Full EU PID: all available fields including address, nationality, birth details';
          break;
        case 'age_verify_18':
          description = 'Age Verification 18+: age_over_18 only';
          break;
        case 'age_verify_21':
          description = 'Age Verification 21+: age_over_18, age_over_21';
          break;
        case 'age_verify_full':
          description = 'Age Verification Full: age checks, birth_date, age_in_years, issuing info';
          break;
        case 'photoid_full':
          description = 'ISO 23220 Photo ID: name, birth_date, portrait, nationality, physical characteristics, address';
          break;
        case 'micov_full':
          description = 'mICOV: identity + vaccination details (vtr) plus attestation namespace';
          break;
        case 'mvc_full':
          description = 'mVC: vehicle registration details, vehicle characteristics, owner';
          break;
      }
      log(`Selected request type: ${type} - ${description}`);
    } else {
      // Multiple documents selected
      const docTypes = selected.map(t => {
        if (t.startsWith('pid_')) return 'EU PID';
        if (t.startsWith('age_verify_')) return 'Age Verification';
        if (t.startsWith('photoid_')) return 'Photo ID';
        if (t.startsWith('micov_')) return 'mICOV';
        if (t.startsWith('mvc_')) return 'mVC';
        return 'mDL';
      });
      const uniqueTypes = [...new Set(docTypes)];
      log(`üìã Multi-document request: ${selected.length} document(s) selected (${uniqueTypes.join(' + ')})`);
    }
  });
});

// Initialize UI
updateBleRoleUI();

// ==== UI actions ====

// ========================================
// PWA Service Worker Registration
// ========================================
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      // Skip SW registration if sw.js is not reachable (avoids addAll precache failures in dev)
      let canRegister = true;
      try {
        const resp = await fetch('/sw.js', { cache: 'no-store' });
        if (!resp.ok) {
          canRegister = false;
          console.warn('‚ö†Ô∏è Skipping Service Worker: /sw.js not reachable (status', resp.status, ')');
        }
      } catch (e) {
        canRegister = false;
        console.warn('‚ö†Ô∏è Skipping Service Worker: fetch(/sw.js) failed:', e?.message || e);
      }

      if (!canRegister) return;

      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });
      
      console.log('‚úÖ Service Worker registered successfully:', registration.scope);
      
      // Check for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('üîÑ Service Worker update found');
        
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('‚ú® New content available, please refresh');
            // Optionally show a toast notification to user
            showUpdateNotification();
          }
        });
      });
      
      // Handle controller change (after update)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('‚ôªÔ∏è Service Worker controller changed, reloading...');
        window.location.reload();
      });
      
      // Check for updates periodically (every 60 seconds)
      setInterval(() => {
        registration.update().then(() => {
          console.log('üîç Checked for Service Worker updates');
        }).catch(err => {
          console.warn('Update check failed:', err);
        });
      }, 60000); // Check every minute
      
      // Also check for updates when page becomes visible
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && registration) {
          registration.update();
          console.log('üîç Checking for updates (page visible)');
        }
      });
      
    } catch (error) {
      console.error('‚ùå Service Worker registration failed:', error);
    }
  });
}

// PWA Install Prompt
let deferredPrompt;
const pwaInstallBanner = document.createElement('div');

// Footer: show APP_VERSION
window.addEventListener('DOMContentLoaded', () => {
  const footerVersion = document.getElementById('appVersionFooter');
  if (footerVersion) {
    footerVersion.innerText = `v${APP_VERSION}`;
  }
});

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;
  
  // Show custom install banner
  showInstallBanner();
});

function showInstallBanner() {
  pwaInstallBanner.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #1d4ed8, #2563eb);
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 12px;
    box-shadow: 0 10px 40px -15px rgba(29, 78, 216, 0.6);
    display: flex;
    align-items: center;
    gap: 1rem;
    z-index: 10000;
    max-width: 90%;
    animation: slideUp 0.3s ease-out;
  `;
  
  pwaInstallBanner.innerHTML = `
    <div style="flex: 1;">
      <div style="font-weight: 600; margin-bottom: 0.25rem;">Install mDL Reader</div>
      <div style="font-size: 0.875rem; opacity: 0.9;">Access offline and faster</div>
    </div>
    <button id="installBtn" style="
      background: white;
      color: #1d4ed8;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.875rem;
    ">Install</button>
    <button id="dismissInstall" style="
      background: transparent;
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
    ">‚úï</button>
  `;
  
  document.body.appendChild(pwaInstallBanner);
  
  // Install button handler
  document.getElementById('installBtn').addEventListener('click', async () => {
    if (!deferredPrompt) return;
    
    // Show the install prompt
    deferredPrompt.prompt();
    
    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);
    
    // Clear the deferred prompt
    deferredPrompt = null;
    
    // Hide the banner
    pwaInstallBanner.remove();
  });
  
  // Dismiss button handler
  document.getElementById('dismissInstall').addEventListener('click', () => {
    pwaInstallBanner.remove();
    // Remember dismissal for 7 days
    localStorage.setItem('pwa-install-dismissed', Date.now().toString());
  });
  
  // Check if dismissed recently
  const dismissed = localStorage.getItem('pwa-install-dismissed');
  if (dismissed && (Date.now() - parseInt(dismissed)) < 7 * 24 * 60 * 60 * 1000) {
    pwaInstallBanner.remove();
  }
}

// Add slideUp animation
const style = document.createElement('style');
style.textContent = `
  @keyframes slideUp {
    from {
      transform: translateX(-50%) translateY(100px);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
`;
document.head.appendChild(style);

// Track successful installation
window.addEventListener('appinstalled', () => {
  console.log('‚úÖ PWA installed successfully');
  pwaInstallBanner.remove();
  deferredPrompt = null;
});

// Show update notification
function showUpdateNotification() {
  const updateBanner = document.createElement('div');
  updateBanner.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #059669;
    color: white;
    padding: 0.75rem 1.25rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    gap: 1rem;
    z-index: 10001;
    animation: slideDown 0.3s ease-out;
  `;
  
  updateBanner.innerHTML = `
    <span>‚ú® Update available!</span>
    <button id="updateBtn" style="
      background: white;
      color: #059669;
      border: none;
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.875rem;
    ">Refresh</button>
  `;
  
  document.body.appendChild(updateBanner);
  
  document.getElementById('updateBtn').addEventListener('click', () => {
    window.location.reload();
  });
  
  // Auto-dismiss after 10 seconds
  setTimeout(() => {
    updateBanner.style.animation = 'slideUp 0.3s ease-out reverse';
    setTimeout(() => updateBanner.remove(), 300);
  }, 10000);
}

const slideDownStyle = document.createElement('style');
slideDownStyle.textContent = `
  @keyframes slideDown {
    from {
      transform: translateX(-50%) translateY(-100px);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
`;
document.head.appendChild(slideDownStyle);

</script>
</html>